# Agenda: Advanced Array Problems and Two-Pointer Applications

## Outcome Expected:
By the end of this hour, students will be able to solve complex array problems using advanced two-pointer techniques, understand sliding window variations, and tackle interview-style problems involving subarrays and optimization. This prepares students for challenging coding interview questions.

## Topics Covered
1. Advanced Two-Pointer Techniques (Sliding Window, Variable Window).  
2. Subarray Problems (Sum, Length, Constraints).  
3. Kadane’s Algorithm for Maximum Subarray Sum.  
4. Prefix Sum Technique for Array Queries.  
5. Common Interview Patterns and Optimization Strategies.

## Detailed Explanation of Topics Covered

### 1. Advanced Two-Pointer Techniques (Sliding Window)
The sliding window technique, a variation of two-pointer, maintains a window of elements satisfying a condition, adjusting its size dynamically. It’s ideal for subarray or substring problems.

Example (Fixed Window - Maximum Sum of k Consecutive Elements):
```cpp
#include <iostream>
int maxSumK(int arr[], int n, int k) {
    if (k > n) return 0;
    int sum = 0;
    for (int i = 0; i < k; i++) sum += arr[i]; // First window
    int maxSum = sum;
    for (int i = k; i < n; i++) {
        sum += arr[i] - arr[i - k]; // Slide: add next, remove first
        maxSum = std::max(maxSum, sum);
    }
    return maxSum;
}
int main() {
    int arr[] = {1, 4, 2, 10, 2, 3, 1, 0, 20};
    std::cout << maxSumK(arr, 9, 4) << std::endl; // Output: 24
    return 0;
}
```

### 2. Subarray Problems
Subarray problems involve finding a contiguous portion of an array meeting specific criteria (e.g., sum, length).

Example (Variable Window - Longest Subarray with Sum <= k):
```cpp
#include <iostream>
int longestSubarray(int arr[], int n, int k) {
    int sum = 0, maxLen = 0, left = 0;
    for (int right = 0; right < n; right++) {
        sum += arr[right];
        while (sum > k && left <= right) sum -= arr[left++];
        maxLen = std::max(maxLen, right - left + 1);
    }
    return maxLen;
}
int main() {
    int arr[] = {1, 2, 3, 4};
    std::cout << longestSubarray(arr, 4, 5) << std::endl; // Output: 2
    return 0;
}
```

### 3. Kadane’s Algorithm for Maximum Subarray Sum
Kadane’s algorithm finds the maximum sum of a contiguous subarray in O(n) time.

Example:
```cpp
#include <iostream>
int maxSubArray(int arr[], int n) {
    int maxSum = arr[0], currSum = arr[0];
    for (int i = 1; i < n; i++) {
        currSum = std::max(arr[i], currSum + arr[i]);
        maxSum = std::max(maxSum, currSum);
    }
    return maxSum;
}
int main() {
    int arr[] = {-2, 1, -3, 4, -1, 2, 1, -5, 4};
    std::cout << maxSubArray(arr, 9) << std::endl; // Output: 6
    return 0;
}
```

### 4. Prefix Sum Technique
Prefix sums store cumulative sums to answer range queries efficiently.

Example (Range Sum Query):
```cpp
#include <iostream>
#include <vector>
std::vector<int> prefixSum(int arr[], int n) {
    std::vector<int> prefix(n + 1, 0);
    for (int i = 0; i < n; i++) prefix[i + 1] = prefix[i] + arr[i];
    return prefix;
}
int rangeSum(int arr[], int n, int left, int right) {
    auto prefix = prefixSum(arr, n);
    return prefix[right + 1] - prefix[left];
}
int main() {
    int arr[] = {1, 2, 3, 4, 5};
    std::cout << rangeSum(arr, 5, 1, 3) << std::endl; // Output: 9
    return 0;
}
```

### 5. Common Interview Patterns
- **Sliding Window:** Fixed or variable size for subarray problems.
- **Kadane’s Algorithm:** Maximum subarray sum or variations.
- **Prefix Sum:** Efficient range queries.
- **Two-Pointer with Sorting:** For pair or triplet sums.

**Cheatsheet:**
| Technique | Use Case | Time Complexity | Space Complexity |
|-----------|----------|-----------------|------------------|
| Sliding Window | Subarray sums/lengths | O(n) | O(1) |
| Kadane’s | Max subarray sum | O(n) | O(1) |
| Prefix Sum | Range queries | O(n) preprocess, O(1) query | O(n) |

## Points to Remember
- Sliding window is versatile for subarray problems; master fixed and variable windows.
- Kadane’s handles negative numbers efficiently.
- Prefix sums are key for repeated range queries.
- Time complexity: O(n) for most techniques; sorting adds O(n log n).
- Space complexity: O(1) for Kadane’s/sliding window, O(n) for prefix sums.
- Common errors: Incorrect window adjustments, off-by-one errors.
- Interview tip: Clarify input constraints (e.g., negative numbers, empty arrays).
- Use `std::vector` for dynamic arrays when needed (Week 1).