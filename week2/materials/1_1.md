# Agenda: Introduction to Arrays in C++

## Outcome Expected:
By the end of this hour, students will be able to declare, initialize, and manipulate basic arrays in C++, understand their memory representation, and apply them in simple programs. This foundational knowledge will prepare them for more advanced array operations and interview questions involving data storage and access efficiency.

## Topics Covered
1. What is an Array?  
2. Declaring Arrays in C++.  
3. Initializing Arrays.  
4. Accessing and Modifying Array Elements.  
5. Array Size and Bounds Checking.  
6. Arrays and Memory Layout.  
7. Common Pitfalls and Best Practices.

## Detailed Explanation of Topics Covered

### 1. What is an Array?
An array is a fixed-size collection of elements of the same data type stored in contiguous memory locations. It allows efficient access to elements via indices, starting from 0. Arrays are useful for storing lists of items like numbers, characters, or objects.

Simple Example:
```cpp
// A simple array to store 5 integers
int numbers[5];  // Declares an array but doesn't initialize it
```
In interviews, arrays often represent datasets, and questions test your ability to handle indexing without errors.

### 2. Declaring Arrays in C++
To declare an array, specify the type, name, and size in square brackets. The size must be a constant expression (or use dynamic allocation for variable sizes, but we'll cover basics here).

Example with Comments:
```cpp
#include <iostream>

int main() {
    int arr[10];  // Declares an array of 10 integers
    // Elements are not initialized, so they contain garbage values
    std::cout << arr[0] << std::endl;  // Might print random value
    return 0;
}
```
Note: In C++11+, you can use `std::array` from `<array>` header for safer fixed-size arrays.

### 3. Initializing Arrays
Arrays can be initialized at declaration using curly braces. Partial initialization fills remaining elements with defaults (e.g., 0 for ints).

Example:
```cpp
#include <iostream>

int main() {
    int arr[5] = {1, 2, 3, 4, 5};  // Fully initialized
    int partial[5] = {1, 2};       // Remaining elements are 0
    int zeroInit[5] = {};          // All elements initialized to 0

    for(int i = 0; i < 5; i++) {
        std::cout << arr[i] << " ";  // Output: 1 2 3 4 5
    }
    std::cout << std::endl;
    return 0;
}
```
Cheatsheet for Initialization:
| Method | Example | Notes |
|--------|---------|-------|
| Full | `int a[3] = {1,2,3};` | All elements set. |
| Partial | `int a[3] = {1};` | a[1] and a[2] = 0. |
| Zero | `int a[3] = {};` | All zero. |
| No Init | `int a[3];` | Garbage values. |

### 4. Accessing and Modifying Array Elements
Use index in square brackets to access. Indices range from 0 to size-1. Modifying is straightforward.

Example with Loop:
```cpp
#include <iostream>

int main() {
    int arr[5] = {10, 20, 30, 40, 50};
    arr[2] = 100;  // Modify third element

    // Traverse and print
    for(int i = 0; i < 5; i++) {
        std::cout << arr[i] << " ";  // Output: 10 20 100 40 50
    }
    std::cout << std::endl;
    return 0;
}
```
Interview Tip: Always check bounds to avoid undefined behavior.

### 5. Array Size and Bounds Checking
Use `sizeof(arr)/sizeof(arr[0])` for size in raw arrays. No built-in bounds checking—out-of-bounds access leads to crashes or undefined behavior.

Example:
```cpp
#include <iostream>

int main() {
    int arr[5] = {1,2,3,4,5};
    size_t size = sizeof(arr) / sizeof(arr[0]);  // size = 5
    std::cout << "Size: " << size << std::endl;

    // Manual bounds check
    int index = 6;
    if(index >= 0 && index < size) {
        std::cout << arr[index] << std::endl;
    } else {
        std::cout << "Out of bounds!" << std::endl;
    }
    return 0;
}
```

### 6. Arrays and Memory Layout
Arrays are stored contiguously. The name of the array is a pointer to the first element.

Example:
```cpp
#include <iostream>

int main() {
    int arr[3] = {10, 20, 30};
    std::cout << arr << std::endl;     // Address of first element
    std::cout << &arr[0] << std::endl; // Same as above
    std::cout << *(arr + 1) << std::endl;  // Access second element: 20
    return 0;
}
```
This ties into pointers from C++ fundamentals.

### 7. Common Pitfalls and Best Practices
- Avoid out-of-bounds access.
- Use loops for traversal.
- Prefer `std::vector` from STL for dynamic sizes (from Week 1).

## Points to Remember
- Arrays have fixed size; can't resize raw arrays easily.
- Indices start at 0; last index is size-1.
- Uninitialized arrays have garbage values—always initialize.
- `sizeof` operator for size calculation in functions requires care (decays to pointer).
- In interviews, expect questions on array vs. vector trade-offs (fixed vs. dynamic).
- Time complexity: Access O(1), Traversal O(n).
- Common error: Off-by-one in loops.
- Arrays decay to pointers when passed to functions—pass size separately.
- Use const for read-only arrays.
- For large arrays, consider stack vs. heap allocation to avoid stack overflow.