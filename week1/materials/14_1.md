# Hour 14: STL Iterators and Iterator Adaptors

**Agenda**: Introduce students to STL iterators and iterator adaptors, building on containers and algorithms from Hours 1â€“13. Use real-world analogies and fully commented programs to simplify concepts. Emphasize practical usage, iterator manipulation, and coding interview preparation.

**Outcome Expected**:  
By the end of this hour, students will:  
- Understand iterator types: input, output, forward, bidirectional, random-access.  
- Master iterator adaptors: reverse iterators, inserters (back_inserter, front_inserter, inserter).  
- Apply iterators with containers and algorithms.  
- Handle iterator invalidation and edge cases.  
- Write C++ programs using iterators for complex operations.  
- Solve LeetCode problems using iterator-based approaches.

## Topics Covered
1. **Introduction to STL Iterators**  
   - Iterator categories and hierarchy.  
   - Real-world analogy: Iterators as library book pointers.  
   - Container iterator support (e.g., vector, set, map).  
2. **Iterator Types**  
   - Input, output, forward, bidirectional, random-access iterators.  
   - Iterator operations (e.g., increment, dereference).  
3. **Iterator Adaptors**  
   - Reverse iterators: `rbegin()`, `rend()`.  
   - Inserters: `back_inserter`, `front_inserter`, `inserter`.  
4. **Practical Applications**  
   - Combining iterators with algorithms and containers.  
   - Iterator invalidation and safe usage.  

## Detailed Explanation of Topics Covered

### 1. Introduction to STL Iterators
Iterators are generalized pointers that traverse container elements, enabling algorithms to work uniformly across containers (e.g., vectors, sets, maps). Think of iterators as pointers to books in a library, guiding operations like reading or modifying.

**Key Features**:  
- **Header**: `<iterator>` for iterator utilities.  
- **Role**: Define ranges `[begin, end)` for algorithms.  
- **Access**: `begin()`, `end()`, `rbegin()`, `rend()`.  

### 2. Iterator Types
Iterators are categorized by capabilities:  
- **Input**: Read-only, forward movement (e.g., `istream_iterator`).  
- **Output**: Write-only, forward movement (e.g., `ostream_iterator`).  
- **Forward**: Read/write, single direction (e.g., `forward_list`).  
- **Bidirectional**: Read/write, forward/backward (e.g., set, map).  
- **Random-Access**: Read/write, direct access (e.g., vector, deque).  

**Example Program**: Iterator types with vector and set.

```cpp
#include <iostream>
#include <vector>
#include <set>
using namespace std;

int main() {
    vector<int> v = {1, 2, 3};
    set<int> s = {4, 5, 6};
    
    // Vector: Random-access iterator
    auto v_it = v.begin();
    v_it += 2;  // Direct access
    cout << "Vector third element: " << *v_it << endl;  // Output: 3
    
    // Set: Bidirectional iterator
    auto s_it = s.begin();
    ++s_it;  // Forward only
    cout << "Set second element: " << *s_it << endl;  // Output: 5
    
    return 0;
}
```

**Explanation**:  
- Vector supports random-access (`+=`).  
- Set supports bidirectional (`++`, `--`).

### 3. Iterator Adaptors
Iterator adaptors modify iterator behavior:  
- **Reverse Iterators**: Traverse backwards (`rbegin()`, `rend()`).  
- **Inserters**: Facilitate insertion into containers.  
  - `back_inserter`: Appends to end (e.g., vector).  
  - `front_inserter`: Prepends to front (e.g., deque).  
  - `inserter`: Inserts at iterator position (e.g., set).  

**Example Program**: Using iterator adaptors.

```cpp
#include <iostream>
#include <vector>
#include <deque>
#include <algorithm>
#include <iterator>
using namespace std;

int main() {
    vector<int> v = {1, 2, 3};
    
    // Reverse iterator
    cout << "Reverse vector: ";
    for (auto it = v.rbegin(); it != v.rend(); ++it) {
        cout << *it << " ";  // Output: 3 2 1
    }
    cout << endl;
    
    // Back inserter
    vector<int> result;
    copy(v.begin(), v.end(), back_inserter(result));
    cout << "Copied: ";
    for (int x : result) cout << x << " ";  // Output: 1 2 3
    cout << endl;
    
    // Front inserter with deque
    deque<int> dq;
    copy(v.begin(), v.end(), front_inserter(dq));
    cout << "Front inserted: ";
    for (int x : dq) cout << x << " ";  // Output: 3 2 1
    cout << endl;
    
    return 0;
}
```

**Explanation**:  
- `rbegin()` iterates backwards.  
- `back_inserter` appends to vector.  
- `front_inserter` prepends to deque.

### 4. Practical Applications
Iterators and adaptors enhance algorithm-container interactions.

**Example Program**: Combining iterators with algorithms.

```cpp
#include <iostream>
#include <vector>
#include <set>
#include <algorithm>
#include <iterator>
using namespace std;

int main() {
    vector<int> v = {1, 2, 3};
    set<int> s;
    
    // Copy vector to set using inserter
    copy(v.begin(), v.end(), inserter(s, s.begin()));
    cout << "Set: ";
    for (int x : s) cout << x << " ";  // Output: 1 2 3
    cout << endl;
    
    // Transform with back_inserter
    vector<int> result;
    transform(v.begin(), v.end(), back_inserter(result), [](int x) { return x * 2; });
    cout << "Doubled: ";
    for (int x : result) cout << x << " ";  // Output: 2 4 6
    cout << endl;
    
    return 0;
}
```

**Explanation**:  
- `inserter` adds to set at valid position.  
- `back_inserter` dynamically grows vector.

## Points to Remember (Interview Preparation)
1. **Headers**: `<iterator>` for adaptors; `<algorithm>` for operations.  
2. **Iterator Types**: Match iterator to algorithm requirements.  
3. **Invalidation**: Modifying containers (e.g., `vector::push_back`) may invalidate iterators.  
4. **Use Cases**: Reverse iterators for backward traversal; inserters for copying.  
5. **Common Errors**: Dereferencing `end()`; using wrong iterator type.  
6. **Interview Questions**: Expect problems involving iterator traversal, copying, or merging.