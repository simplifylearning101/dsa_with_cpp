# Hour 8: Maps in STL

**Agenda**: Introduce students to C++ STL `map` and `unordered_map`, building on their understanding of vectors (Hour 1), arrays/deques (Hour 2), strings (Hour 3), stacks (Hour 4), queues (Hour 5), priority queues (Hour 6), and sets (Hour 7). Use real-world analogies and fully commented programs to simplify concepts. Emphasize practical usage, map operations, and preparation for coding interviews.

**Outcome Expected**:  
By the end of this hour, students will:  
- Understand STL `map` (ordered key-value pairs) and `unordered_map` (unordered key-value pairs).  
- Master map operations (e.g., insert, find, erase).  
- Compare maps with other containers like sets and vectors.  
- Write C++ programs using maps with proper syntax and error handling.  
- Be ready to solve LeetCode problems involving map-based algorithms.

## Topics Covered
1. **STL Map: Ordered Key-Value Pairs**  
   - Declaration, initialization, and basic operations.  
   - Underlying structure: Red-black tree.  
   - Real-world analogy: Map as a dictionary.  
2. **STL Unordered Map: Unordered Key-Value Pairs**  
   - Declaration, initialization, and hash-based operations.  
   - Underlying structure: Hash table.  
   - Real-world analogy: Unordered map as a phone book.  
3. **Map Operations**  
   - `insert`, `erase`, `find`, `count`, `size`, `empty`, `operator[]`.  
   - Iterating over maps.  
4. **Comparison with Other Containers**  
   - Maps vs. sets (key-value vs. keys only).  
   - Maps vs. vectors (key-value lookup vs. indexed access).  

## Detailed Explanation of Topics Covered

### 1. STL Map: Ordered Key-Value Pairs
The STL `map` is a container that stores key-value pairs in sorted order by key, implemented using a red-black tree. Think of a `map` as a dictionary where words (keys) are sorted alphabetically, and each word has a definition (value).

**Key Features**:  
- **Declaration**: `map<K, V> m;` (e.g., `map<string, int>` for word counts).  
- **Initialization**: Insert key-value pairs.  
- **Operations**: `insert`, `erase`, `find`, `count`, `size`, `empty`, `operator[]`.  
- **Advantages**: O(log n) for insert/erase/find; keys sorted.  
- **Limitations**: No random access; no duplicate keys.

**Example Program**: Basic map operations.

```cpp
#include <iostream>
#include <map>
#include <string>
using namespace std;

int main() {
    // Declare map
    map<string, int> dictionary;

    // Insert key-value pairs
    dictionary["apple"] = 5; // O(log n)
    dictionary["banana"] = 3;
    dictionary["apple"] = 7; // Updates value for "apple"

    // Print size
    cout << "Size: " << dictionary.size() << endl; // Output: 2

    // Print elements (sorted by key)
    cout << "Dictionary: ";
    for (const auto& pair : dictionary) {
        cout << pair.first << ":" << pair.second << " "; // Output: apple:7 banana:3
    }
    cout << endl;

    // Find key
    auto it = dictionary.find("banana");
    cout << "Find banana: " << (it != dictionary.end() ? to_string(it->second) : "Not found") << endl; // Output: 3

    // Erase key
    dictionary.erase("apple");
    cout << "After erasing apple, size: " << dictionary.size() << endl; // Output: 1

    // Check if empty
    cout << "Is map empty? " << (dictionary.empty() ? "Yes" : "No") << endl; // Output: No

    return 0;
}
```

**Explanation**:  
- `#include <map>`: Imports the map library.  
- `operator[]`: Inserts or updates key-value pair (O(log n)).  
- `erase(key)`: Removes key-value pair (O(log n)).  
- `find(key)`: Returns iterator to pair or `end()` (O(log n)).  
- Keys are automatically sorted; duplicates are not allowed.

### 2. STL Unordered Map: Unordered Key-Value Pairs
The STL `unordered_map` stores key-value pairs in no particular order, implemented using a hash table. Think of it as a phone book where names (keys) map to numbers (values), and order doesn’t matter.

**Key Features**:  
- **Declaration**: `unordered_map<K, V> um;` (e.g., `unordered_map<string, int>`).  
- **Operations**: Similar to `map` but O(1) average case for insert/erase/find.  
- **Advantages**: Faster than `map` for lookups (O(1) average).  
- **Limitations**: No sorting; hash collisions may degrade performance to O(n).

**Example Program**: Unordered map operations.

```cpp
#include <iostream>
#include <unordered_map>
#include <string>
using namespace std;

int main() {
    // Declare unordered map
    unordered_map<string, int> phone_book;

    // Insert key-value pairs
    phone_book["Alice"] = 1234567890;
    phone_book["Bob"] = 9876543210;
    phone_book["Alice"] = 1112223333; // Updates value

    // Print size
    cout << "Size: " << phone_book.size() << endl; // Output: 2

    // Print elements (order not guaranteed)
    cout << "Phone book: ";
    for (const auto& pair : phone_book) {
        cout << pair.first << ":" << pair.second << " "; // Output: e.g., Alice:1112223333 Bob:9876543210
    }
    cout << endl;

    // Check if key exists
    cout << "Is Bob in phone book? " << (phone_book.count("Bob") ? "Yes" : "No") << endl; // Output: Yes

    // Erase key
    phone_book.erase("Alice");
    cout << "After erasing Alice, size: " << phone_book.size() << endl; // Output: 1

    return 0;
}
```

**Explanation**:  
- `#include <unordered_map>`: Imports the unordered map library.  
- `count(key)`: Returns 1 if key exists, 0 otherwise (O(1) average).  
- Ideal for fast lookups when order isn’t needed.

### 3. Map Operations
Both `map` and `unordered_map` support key operations for managing key-value pairs. Iterating over `map` yields sorted order by key; `unordered_map` yields arbitrary order.

**Key Operations**:  
- `insert({key, value})`: Adds key-value pair if key not present.  
- `erase(key)`: Removes key-value pair.  
- `find(key)`: Returns iterator to pair or `end()`.  
- `count(key)`: Returns 1 or 0 (no duplicate keys).  
- `operator[]`: Accesses or inserts value for key.  
- `size()`: Number of pairs.  
- `empty()`: Checks if map is empty.

**Example Program**: Comparing map and unordered map.

```cpp
#include <iostream>
#include <map>
#include <unordered_map>
#include <string>
using namespace std;

int main() {
    // Ordered map
    map<string, int> m;
    m["apple"] = 5; m["banana"] = 3;
    cout << "Map (sorted): ";
    for (const auto& pair : m) {
        cout << pair.first << ":" << pair.second << " "; // Output: apple:5 banana:3
    }
    cout << endl;

    // Unordered map
    unordered_map<string, int> um;
    um["apple"] = 5; um["banana"] = 3;
    cout << "Unordered map: ";
    for (const auto& pair : um) {
        cout << pair.first << ":" << pair.second << " "; // Output: e.g., banana:3 apple:5
    }
    cout << endl;

    // Find in map
    cout << "Find banana in map: " << (m.find("banana") != m.end() ? to_string(m["banana"]) : "Not found") << endl; // Output: 3

    // Count in unordered map
    cout << "Count banana in unordered map: " << um.count("banana") << endl; // Output: 1

    return 0;
}
```

**Explanation**:  
- `map` maintains sorted order by key; `unordered_map` does not.  
- Use `map` for sorted key access; `unordered_map` for fast lookups.

### 4. Comparison with Other Containers
- **Map vs. Set**: `map` stores key-value pairs; `set` stores only keys (Hour 7).  
- **Map vs. Vector**: `map` provides key-based lookup; `vector` provides indexed access (Hour 1).

**Example Program**: Map vs. set for key-value storage.

```cpp
#include <iostream>
#include <map>
#include <set>
#include <string>
using namespace std;

int main() {
    // Using map
    map<string, int> word_count;
    word_count["apple"] = 5; word_count["banana"] = 3;
    cout << "Map size: " << word_count.size() << endl; // Output: 2
    cout << "Apple count: " << word_count["apple"] << endl; // Output: 5

    // Using set
    set<string> words;
    words.insert("apple"); words.insert("banana");
    cout << "Set size: " << words.size() << endl; // Output: 2
    cout << "Apple in set? " << (words.count("apple") ? "Yes" : "No") << endl; // Output: Yes

    return 0;
}
```

**Explanation**:  
- `map` stores values associated with keys; `set` only tracks keys.  
- `map` is ideal for key-value mappings like word counts.

## Points to Remember (Interview Preparation)
1. **Map**: Ordered, unique keys, O(log n) operations, red-black tree.  
2. **Unordered Map**: Unordered, unique keys, O(1) average operations, hash table.  
3. **Time Complexities**:  
   - `map`: O(log n) for insert/erase/find.  
   - `unordered_map`: O(1) average, O(n) worst case.  
4. **Use Cases**: Maps for key-value mappings; unordered maps for fast lookups.  
5. **Safety**: Check `find()` result against `end()`; use `count()` for `unordered_map`.  
6. **Interview Questions**: Be ready for frequency counting, two-sum, or pattern-matching problems.  
7. **Common Errors**: Avoid assuming order in `unordered_map`; `operator[]` inserts if key absent.