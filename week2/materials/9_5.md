# Deep Dive: Review of Arrays and Strings

This deep dive consolidates key algorithms and their logic for arrays and strings.

## Key Programs and Logic

### Two-Sum
**Logic**: Use a hash map to store number-index pairs, checking for the complement (target - nums[i]) in O(1) time.
```cpp
#include <vector>
#include <unordered_map>
std::vector<int> twoSum(std::vector<int>& nums, int target) {
    std::unordered_map<int, int> map;
    for (int i = 0; i < nums.size(); i++) {
        int complement = target - nums[i];
        if (map.count(complement)) return {map[complement], i};
        map[nums[i]] = i;
    }
    return {};
}
```
**Complexity**: O(n) time, O(n) space.

### Maximum Subarray
**Logic**: Kadane’s algorithm maintains a running sum, resetting when negative.
```cpp
#include <vector>
int maxSubArray(std::vector<int>& nums) {
    int maxSum = nums[0], currSum = nums[0];
    for (int i = 1; i < nums.size(); i++) {
        currSum = std::max(nums[i], currSum + nums[i]);
        maxSum = std::max(maxSum, currSum);
    }
    return maxSum;
}
```
**Complexity**: O(n) time, O(1) space.

### KMP Pattern Search
**Logic**: LPS array tracks longest prefix-suffix, skipping redundant comparisons.
```cpp
#include <vector>
#include <string>
std::vector<int> computeLPS(std::string pattern) {
    int m = pattern.length();
    std::vector<int> lps(m, 0);
    int len = 0, i = 1;
    while (i < m) {
        if (pattern[i] == pattern[len]) lps[i++] = ++len;
        else if (len != 0) len = lps[len - 1];
        else lps[i++] = 0;
    }
    return lps;
}
int KMPSearch(std::string text, std::string pattern) {
    int n = text.length(), m = pattern.length();
    std::vector<int> lps = computeLPS(pattern);
    int i = 0, j = 0;
    while (i < n) {
        if (text[i] == pattern[j]) { i++; j++; }
        if (j == m) return i - j;
        if (i < n && text[i] != pattern[j]) {
            if (j != 0) j = lps[j - 1];
            else i++;
        }
    }
    return -1;
}
```
**Complexity**: O(n+m) time, O(m) space.

### Edit Distance
**Logic**: DP table tracks minimum operations (insert, delete, replace).
```cpp
#include <string>
#include <vector>
int minDistance(std::string word1, std::string word2) {
    int m = word1.length(), n = word2.length();
    std::vector<std::vector<int>> dp(m + 1, std::vector<int>(n + 1, 0));
    for (int i = 0; i <= m; i++) dp[i][0] = i;
    for (int j = 0; j <= n; j++) dp[0][j] = j;
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (word1[i - 1] == word2[j - 1]) dp[i][j] = dp[i - 1][j - 1];
            else dp[i][j] = std::min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;
        }
    }
    return dp[m][n];
}
```
**Complexity**: O(m*n) time, O(m*n) space.

### Interview Questions and Insights
1. **Two-Sum**: Use hash map for O(n) vs. O(n log n) with sorting.
2. **Maximum Subarray**: Kadane’s avoids nested loops.
3. **KMP**: LPS array is key to avoiding backtracking.
4. **Edit Distance**: Initialize DP table correctly for edge cases.

**Pitfalls**:
- Arrays: Mishandling duplicates or empty inputs.
- Strings: Incorrect LPS computation, hash collisions in Rabin-Karp.