# Hour 6: Priority Queues in STL

**Agenda**: Introduce students to C++ STL `priority_queue`, building on their understanding of vectors (Hour 1), arrays/deques (Hour 2), strings (Hour 3), stacks (Hour 4), and queues (Hour 5). Use real-world analogies and fully commented programs to simplify concepts. Emphasize practical usage, priority queue operations, and preparation for coding interviews.

**Outcome Expected**:  
By the end of this hour, students will:  
- Understand STL `priority_queue` as a max-heap or min-heap container.  
- Master priority queue operations (e.g., push, pop, top).  
- Compare priority queues with regular queues and other containers.  
- Write C++ programs using priority queues with proper syntax and error handling.  
- Be ready to solve LeetCode problems involving priority queue-based algorithms.

## Topics Covered
1. **STL Priority Queue: Heap-Based Container**  
   - Declaration, initialization, and basic operations.  
   - Underlying container (default: vector, max-heap).  
   - Real-world analogy: Priority queue as a hospital triage system.  
2. **Priority Queue Operations**  
   - `push`, `pop`, `top`, `empty`, `size`.  
   - Custom comparators for min-heap or custom priorities.  
   - Real-world analogy: Prioritizing urgent tasks.  
3. **Comparison with Other Containers**  
   - Priority queues vs. queues (priority vs. FIFO).  
   - Priority queues vs. sets (dynamic vs. sorted).  

## Detailed Explanation of Topics Covered

### 1. STL Priority Queue: Heap-Based Container
The STL `priority_queue` is a container adapter that maintains elements in a heap structure, ensuring the highest-priority element (largest by default) is always at the top. Itâ€™s built on top of a vector (default) or deque, using a max-heap. Think of a priority queue as a hospital triage system: patients with the most urgent conditions are treated first.

**Key Features**:  
- **Declaration**: `priority_queue<T> pq;` (e.g., `priority_queue<int>` for max-heap).  
- **Initialization**: Push elements to build the heap.  
- **Operations**: `push()`, `pop()`, `top()`, `empty()`, `size()`.  
- **Advantages**: O(log n) for push/pop, O(1) for top.  
- **Limitations**: No direct access to non-top elements; no iterators.

**Example Program**: Basic priority queue operations.

```cpp
#include <iostream>
#include <queue> // Include priority_queue library
using namespace std;

int main() {
    // Declare max-heap priority queue
    priority_queue<int> triage;

    // Push elements (patients with urgency levels)
    triage.push(3); // Moderate
    triage.push(5); // Critical
    triage.push(1); // Low

    // Print size
    cout << "Size: " << triage.size() << endl; // Output: 3

    // Access top element
    cout << "Top: " << triage.top() << endl; // Output: 5 (highest priority)

    // Pop top element
    triage.pop();
    cout << "After pop, top: " << triage.top() << endl; // Output: 3

    // Check if empty
    cout << "Is priority queue empty? " << (triage.empty() ? "Yes" : "No") << endl; // Output: No

    // Handle empty priority queue
    priority_queue<int> empty_triage;
    cout << "Is empty_triage empty? " << (empty_triage.empty() ? "Yes" : "No") << endl; // Output: Yes

    return 0;
}
```

**Explanation**:  
- `#include <queue>`: Imports the priority queue library.  
- `push(x)`: Adds element and maintains heap property (O(log n)).  
- `pop()`: Removes top element (O(log n)).  
- `top()`: Returns top element (O(1)).  
- `empty()`: Checks if priority queue is empty.  
- Default is max-heap: largest element is at the top.

### 2. Priority Queue Operations
STL `priority_queue` provides an efficient interface for heap-based operations. Imagine prioritizing tasks in a to-do list where the most urgent task is always processed first.

**Key Operations**:  
- `push(x)`: Adds element `x` and re-heapifies.  
- `pop()`: Removes top element (no return value).  
- `top()`: Returns reference to top element.  
- `empty()`: Returns `true` if empty.  
- `size()`: Returns number of elements.  
- **Custom Comparator**: Use for min-heap or custom ordering.

**Example Program**: Min-heap using custom comparator.

```cpp
#include <iostream>
#include <queue>
using namespace std;

int main() {
    // Min-heap priority queue (smallest element on top)
    priority_queue<int, vector<int>, greater<int>> min_heap;

    // Push elements
    min_heap.push(3);
    min_heap.push(1);
    min_heap.push(5);

    // Process elements
    while (!min_heap.empty()) {
        cout << min_heap.top() << " "; // Output: 1 3 5
        min_heap.pop();
    }
    cout << endl;

    return 0;
}
```

**Explanation**:  
- `priority_queue<int, vector<int>, greater<int>>`: Creates a min-heap.  
- `greater<int>` comparator ensures smallest element is at the top.  
- Useful for problems like finding the smallest k elements.

### 3. Comparison with Other Containers
- **Priority Queue vs. Queue**: Priority queue prioritizes elements (heap); queue is FIFO (Hour 5).  
- **Priority Queue vs. Set**: Priority queue allows duplicates and is dynamic; set is sorted and unique.

**Example Program**: Priority queue vs. queue for task processing.

```cpp
#include <iostream>
#include <queue>
using namespace std;

int main() {
    // Using priority queue (process highest priority first)
    priority_queue<int> pq;
    pq.push(1); pq.push(3); pq.push(2);
    cout << "Priority queue: ";
    while (!pq.empty()) {
        cout << pq.top() << " "; // Output: 3 2 1
        pq.pop();
    }
    cout << endl;

    // Using queue (FIFO)
    queue<int> q;
    q.push(1); q.push(3); q.push(2);
    cout << "Queue: ";
    while (!q.empty()) {
        cout << q.front() << " "; // Output: 1 3 2
        q.pop();
    }
    cout << endl;

    return 0;
}
```

**Explanation**:  
- Priority queue processes highest priority (largest) first.  
- Queue processes in insertion order (FIFO).  
- Priority queue is ideal for tasks with varying urgency.

## Points to Remember (Interview Preparation)
1. **Heap Principle**: Max-heap (default) or min-heap with custom comparator.  
2. **Time Complexities**:  
   - `push`, `pop`: O(log n).  
   - `top`, `size`, `empty`: O(1).  
3. **Use Cases**: Priority queues for scheduling, kth largest/smallest, merging sorted data.  
4. **Safety**: Check `empty()` before `top` or `pop` to avoid undefined behavior.  
5. **Underlying Container**: Default is `vector`; can use `deque`.  
6. **Interview Questions**: Be ready for kth largest, merging lists, or stream processing.  
7. **Common Errors**: Avoid accessing `top`/`pop` on empty priority queue; no iterator support.