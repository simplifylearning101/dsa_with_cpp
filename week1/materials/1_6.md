# Hour 1 LeetCode Problem: Remove Duplicates from Sorted Array

This document illustrates a LeetCode problem to reinforce C++ STL vector usage, focusing on **LeetCode 26: Remove Duplicates from Sorted Array**. It provides a detailed explanation of the problem, coding patterns, brute-force and optimized solutions, time and space complexity analysis, and comprehensive test cases, including edge cases. The goal is to help students develop an optimization mindset, understand vector operations in a practical context, and prepare for coding interviews.

## Agenda
- Introduce the LeetCode problem and its relevance to vectors.
- Explain the coding pattern (Two Pointers) used in the solution.
- Provide brute-force and optimized solutions with detailed comments.
- Analyze time and space complexities.
- Include test cases covering various scenarios and edge cases.

## Outcome Expected
By the end of this reading, students will:
- Understand how to manipulate vectors to solve array-based problems.
- Master the Two Pointers pattern for in-place array modifications.
- Learn to transition from brute-force to optimized solutions.
- Be able to handle edge cases and analyze complexities for interview problems.
- Gain confidence in solving LeetCode problems using STL vectors.

## Problem Statement: LeetCode 26 - Remove Duplicates from Sorted Array
**Link**: [LeetCode 26](https://leetcode.com/problems/remove-duplicates-from-sorted-array/)

**Description**:  
Given an integer array `nums` sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Return the number of unique elements in `nums`.

**Constraints**:
- The array is sorted in non-decreasing order.
- `0 <= nums.length <= 3 * 10^4`.
- `-100 <= nums[i] <= 100`.
- Modify the array in-place with O(1) extra space.

**Example**:
- Input: `nums = [1,1,2]`  
  Output: `2`, `nums = [1,2,_]`  
  Explanation: The function returns `2`, with the first two elements being `1` and `2`. The remaining elements (denoted `_`) are not considered.

- Input: `nums = [0,0,1,1,1,2,2,3,3,4]`  
  Output: `5`, `nums = [0,1,2,3,4,_,_,_,_,_]`  
  Explanation: The function returns `5`, with the first five elements being unique.

**Real-World Analogy**: Imagine a sorted list of student IDs where duplicates exist (e.g., due to data entry errors). Your task is to keep only one copy of each ID in the same order, moving duplicates to the end of the list, and report how many unique IDs remain.

## Coding Pattern: Two Pointers
This problem is ideally solved using the **Two Pointers** pattern, a common technique for array problems, especially those requiring in-place modifications. The pattern involves:
- Using two pointers to track positions in the array:
  - One pointer (`write`) indicates where to place the next unique element.
  - Another pointer (`read`) scans through the array to find unique elements.
- Since the array is sorted, duplicates are adjacent, allowing us to compare consecutive elements.
- The pattern ensures O(1) extra space by modifying the array in-place.

**Why Two Pointers?**  
- Efficient for sorted arrays, as we can skip duplicates by comparing adjacent elements.
- Avoids unnecessary data structures, meeting the O(1) space requirement.
- Common in interview problems like removing elements or partitioning arrays.

## Brute-Force Solution
The brute-force approach uses an additional data structure (e.g., a set) to track unique elements, then reconstructs the array. While intuitive, it violates the O(1) space constraint.

**Algorithm**:
1. Create a set to store unique elements.
2. Iterate through the array, adding elements to the set.
3. Copy unique elements back to the array in order.
4. Return the size of the set.

**Code**:
```cpp
#include <vector>
#include <set>
using namespace std;

class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        // Create a set to store unique elements
        set<int> unique_nums;

        // Add all elements to the set (duplicates are automatically removed)
        for (int num : nums) {
            unique_nums.insert(num); // O(log n) per insertion
        }

        // Copy unique elements back to nums
        int index = 0;
        for (int num : unique_nums) {
            nums[index++] = num; // Place unique elements at the front
        }

        // Return the number of unique elements
        return unique_nums.size();
    }
};
```

**Time Complexity**: O(n log n)  
- Inserting into a set: O(log n) per element, total O(n log n).
- Copying back: O(n).
- Overall: O(n log n).

**Space Complexity**: O(n)  
- The set stores up to n unique elements, violating the O(1) space requirement.

**Why It’s Not Optimal**:
- Uses extra space (set), which is not allowed.
- Slower due to logarithmic set operations.
- Doesn’t leverage the sorted nature of the array.

**Interview Insight**: Interviewers may accept this as a starting point but will push for an in-place solution with O(1) space, testing your ability to optimize.

## Optimized Solution (Two Pointers)
The optimized solution uses the Two Pointers pattern to modify the array in-place, leveraging the sorted property to compare adjacent elements.

**Algorithm**:
1. If the array is empty, return 0.
2. Use a `write` pointer to track the position for the next unique element.
3. Iterate with a `read` pointer starting from index 1.
4. If `nums[read]` differs from `nums[write-1]`, it’s a new unique element:
   - Place it at `nums[write]` and increment `write`.
5. Return `write` as the number of unique elements.

**Code**:
```cpp
#include <vector>
using namespace std;

class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        // Handle empty array edge case
        if (nums.empty()) return 0;

        // Initialize write pointer for next unique element
        int write = 1;

        // Iterate with read pointer starting from second element
        for (int read = 1; read < nums.size(); ++read) {
            // If current element differs from the last unique element
            if (nums[read] != nums[write - 1]) {
                nums[write] = nums[read]; // Place unique element
                write++; // Move write pointer forward
            }
        }

        // Return the number of unique elements
        return write;
    }
};
```

**Time Complexity**: O(n)  
- Single pass through the array with the `read` pointer.
- Each operation (comparison, assignment) is O(1).
- Total: O(n).

**Space Complexity**: O(1)  
- Only uses two pointers, no extra data structures.

**Explanation**:
- `write` starts at 1 because the first element (`nums[0]`) is always unique.
- `read` scans from index 1, comparing with the last unique element (`nums[write-1]`).
- When a new unique element is found, it’s placed at `write`, and `write` is incremented.
- The array is modified in-place, and `write` gives the count of unique elements.

**Why It’s Optimal**:
- Meets O(1) space requirement by modifying in-place.
- Leverages sorted property to avoid extra data structures.
- Single pass ensures O(n) time.

**Interview Insight**: This solution demonstrates mastery of in-place array manipulation and the Two Pointers pattern, a favorite in interviews. Interviewers may ask follow-ups like handling unsorted arrays or additional constraints.

## Optimization Mindset
To develop the optimization mindset, students should:
1. **Start with Brute-Force**: Understand the problem and write a simple solution, even if inefficient.
2. **Identify Constraints**: The O(1) space requirement rules out extra data structures like sets.
3. **Leverage Properties**: The sorted array allows comparing adjacent elements, avoiding sorting or searching.
4. **Use Patterns**: Recognize Two Pointers as a fit for in-place modifications.
5. **Iterate**: Refine the solution by reducing space/time complexity, testing with edge cases.

**Example Transition**:
- Brute-force used a set (O(n) space, O(n log n) time).
- Realized sorted array allows linear scanning.
- Adopted Two Pointers to achieve O(n) time and O(1) space.

## Test Cases
Below are test cases covering typical scenarios, edge cases, and boundary conditions to ensure robustness.

1. **Typical Case (Duplicates Present)**  
   **Input**: `nums = [0,0,1,1,1,2,2,3,3,4]`  
   **Output**: `5`, `nums = [0,1,2,3,4,_,_,_,_,_]`  
   **Explanation**: Removes duplicates, keeping one copy of each unique element.

2. **No Duplicates**  
   **Input**: `nums = [1,2,3,4,5]`  
   **Output**: `5`, `nums = [1,2,3,4,5]`  
   **Explanation**: No duplicates, so the array remains unchanged.

3. **All Elements Same**  
   **Input**: `nums = [1,1,1,1]`  
   **Output**: `1`, `nums = [1,_,_,_]`  
   **Explanation**: Only one unique element remains.

4. **Empty Array (Edge Case)**  
   **Input**: `nums = []`  
   **Output**: `0`, `nums = []`  
   **Explanation**: Empty array returns 0, no modifications needed.

5. **Single Element (Edge Case)**  
   **Input**: `nums = [1]`  
   **Output**: `1`, `nums = [1]`  
   **Explanation**: Single element is unique, no changes needed.

6. **Large Array with Many Duplicates**  
   **Input**: `nums = [1,1,1,2,2,3,3,3,3,3]`  
   **Output**: `3`, `nums = [1,2,3,_,_,_,_,_,_,_]`  
   **Explanation**: Handles multiple duplicates efficiently.

7. **Negative Numbers**  
   **Input**: `nums = [-2,-2,-1,0,0,1]`  
   **Output**: `4`, `nums = [-2,-1,0,1,_,_]`  
   **Explanation**: Works with negative numbers in sorted order.

**Test Case Implementation**:
```cpp
#include <iostream>
#include <vector>
using namespace std;

int removeDuplicates(vector<int>& nums) {
    if (nums.empty()) return 0;
    int write = 1;
    for (int read = 1; read < nums.size(); ++read) {
        if (nums[read] != nums[write - 1]) {
            nums[write] = nums[read];
            write++;
        }
    }
    return write;
}

void printResult(vector<int>& nums, int k) {
    cout << "Length: " << k << ", Array: ";
    for (int i = 0; i < k; ++i) cout << nums[i] << " ";
    cout << endl;
}

int main() {
    // Test Case 1: Typical case
    vector<int> nums1 = {0,0,1,1,1,2,2,3,3,4};
    int k1 = removeDuplicates(nums1);
    printResult(nums1, k1);

    // Test Case 2: No duplicates
    vector<int> nums2 = {1,2,3,4,5};
    int k2 = removeDuplicates(nums2);
    printResult(nums2, k2);

    // Test Case 3: All same
    vector<int> nums3 = {1,1,1,1};
    int k3 = removeDuplicates(nums3);
    printResult(nums3, k3);

    // Test Case 4: Empty array
    vector<int> nums4 = {};
    int k4 = removeDuplicates(nums4);
    printResult(nums4, k4);

    // Test Case 5: Single element
    vector<int> nums5 = {1};
    int k5 = removeDuplicates(nums5);
    printResult(nums5, k5);

    // Test Case 6: Large with many duplicates
    vector<int> nums6 = {1,1,1,2,2,3,3,3,3,3};
    int k6 = removeDuplicates(nums6);
    printResult(nums6, k6);

    // Test Case 7: Negative numbers
    vector<int> nums7 = {-2,-2,-1,0,0,1};
    int k7 = removeDuplicates(nums7);
    printResult(nums7, k7);

    return 0;
}
```

**Output**:
```
Length: 5, Array: 0 1 2 3 4
Length: 5, Array: 1 2 3 4 5
Length: 1, Array: 1
Length: 0, Array:
Length: 1, Array: 1
Length: 3, Array: 1 2 3
Length: 4, Array: -2 -1 0 1
```

## Additional Practice
To further master vector-based problems and the Two Pointers pattern, try these LeetCode problems:
- **LeetCode 27: Remove Element** (Easy) - Similar in-place removal.
- **LeetCode 80: Remove Duplicates from Sorted Array II** (Medium) - Allows up to two duplicates.
- **LeetCode 283: Move Zeroes** (Easy) - In-place array manipulation.
- **LeetCode 189: Rotate Array** (Medium) - Uses vectors with rotation logic.

## Key Takeaways
- **Understand Constraints**: The O(1) space requirement drives the Two Pointers approach.
- **Leverage Sorted Property**: Adjacent duplicates simplify the problem.
- **Test Edge Cases**: Always consider empty arrays, single elements, and all duplicates.
- **Optimization Mindset**: Start with brute-force, then refine to meet constraints.
- **Vector Mastery**: Use `vector` operations like indexing and in-place modification efficiently.

This problem reinforces vector manipulation skills and introduces a key coding pattern, preparing students for more complex array-based interview questions.