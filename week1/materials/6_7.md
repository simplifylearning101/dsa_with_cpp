# Hour 6 Additional LeetCode Problems: Priority Queue Solutions

This document provides detailed solutions for four LeetCode problems recommended in `6_2.md`: **LeetCode 703: Kth Largest Element in a Stream**, **LeetCode 295: Find Median from Data Stream**, **LeetCode 215: Kth Largest Element in an Array**, and **LeetCode 347: Top K Frequent Elements**. Each solution includes a problem description, coding pattern, optimized solution with commented C++ code using STL `priority_queue`, time and space complexity analysis, and test cases covering typical and edge cases.

## Agenda
- Provide optimized solutions for four priority queue-based LeetCode problems.
- Explain coding patterns (e.g., kth largest, two heaps, frequency counting).
- Analyze time and space complexities.
- Include test cases to ensure robustness.

## Outcome Expected
Students will:
- Master priority queue usage for kth largest, median finding, and frequency problems.  
- Apply heap-based techniques for stream and array processing.  
- Handle edge cases and optimize for interviews.  
- Gain confidence in solving priority queue-based LeetCode problems.

---

## 1. LeetCode 703: Kth Largest Element in a Stream (Easy)

**Link**: [LeetCode 703](https://leetcode.com/problems/kth-largest-element-in-a-stream/)

**Description**:  
Design a class to find the kth largest element in a stream. The `KthLargest` class is initialized with an integer `k` and an array `nums`, and the `add` method returns the kth largest element after adding a new value.

**Constraints**:
- `1 <= k <= 10^4`
- `0 <= nums.length <= 10^4`
- `-10^4 <= nums[i], val <= 10^4`
- At most 10^4 calls to `add`.

**Example**:
- Input: `["KthLargest","add","add","add","add","add"]`, `[[3,[4,5,8,2]],[3],[5],[10],[9],[4]]`  
  Output: `[null,4,5,5,8,8]`  
  Explanation: Maintain k largest elements; return kth largest after each add.

**Coding Pattern**: Min-Heap for Kth Largest  
- Use a min-heap to maintain the k largest elements.  
- Pop smallest when size exceeds k.  
- Top of heap is the kth largest.

**Optimized Solution**:
```cpp
#include <queue>
#include <vector>
using namespace std;

class KthLargest {
private:
    priority_queue<int, vector<int>, greater<int>> pq; // Min-heap
    int k;
public:
    KthLargest(int k, vector<int>& nums) : k(k) {
        for (int num : nums) {
            pq.push(num);
            if (pq.size() > k) {
                pq.pop();
            }
        }
    }
    
    int add(int val) {
        pq.push(val);
        if (pq.size() > k) {
            pq.pop();
        }
        return pq.top();
    }
};
```

**Time Complexity**:  
- Constructor: O(n log k) for n elements.  
- `add`: O(log k) per call.  

**Space Complexity**: O(k)  
- Min-heap stores k elements.

**Explanation**:
- Min-heap keeps k largest elements; smallest is at the top.  
- Pop smallest when size exceeds k to maintain k elements.  
- Top is always the kth largest.

**Test Cases**:
1. **Typical Case**: `k=3, nums=[4,5,8,2], add(3,5,10,9,4)` → Output: `[4,5,5,8,8]`  
2. **Single Element**: `k=1, nums=[1], add(2)` → Output: `[2]`  
3. **Empty Initial**: `k=1, nums=[], add(1)` → Output: `[1]`  
4. **Large k**: `k=3, nums=[1,1], add(1)` → Output: `[1]`  
5. **Negative Numbers**: `k=2, nums=[-1,-2], add(-3)` → Output: `[-2]`  

---

## 2. LeetCode 295: Find Median from Data Stream (Hard)

**Link**: [LeetCode 295](https://leetcode.com/problems/find-median-from-data-stream/)

**Description**:  
Design a class to find the median of a stream of integers. The `MedianFinder` class supports `addNum` to add a number and `findMedian` to return the median.

**Constraints**:
- `-10^5 <= num <= 10^5`
- At least one number before calling `findMedian`.
- At most 5 * 10^4 calls to `addNum` and `findMedian`.

**Example**:
- Input: `["MedianFinder","addNum","addNum","findMedian","addNum","findMedian"]`, `[[],[1],[2],[1.5],[3],[2]]`  
  Output: `[null,null,null,1.5,null,2]`  
  Explanation: Median of [1,2] is 1.5; median of [1,2,3] is 2.

**Coding Pattern**: Two Heaps  
- Use a max-heap for the lower half and a min-heap for the upper half.  
- Keep heaps balanced (size difference ≤ 1).  
- Median is average of tops or top of larger heap.

**Optimized Solution**:
```cpp
#include <queue>
using namespace std;

class MedianFinder {
private:
    priority_queue<int> max_heap; // Lower half
    priority_queue<int, vector<int>, greater<int>> min_heap; // Upper half
public:
    MedianFinder() {}
    
    void addNum(int num) {
        if (max_heap.empty() || num < max_heap.top()) {
            max_heap.push(num);
        } else {
            min_heap.push(num);
        }
        // Balance heaps
        if (max_heap.size() > min_heap.size() + 1) {
            min_heap.push(max_heap.top());
            max_heap.pop();
        } else if (min_heap.size() > max_heap.size()) {
            max_heap.push(min_heap.top());
            min_heap.pop();
        }
    }
    
    double findMedian() {
        if (max_heap.size() == min_heap.size()) {
            return (max_heap.top() + min_heap.top()) / 2.0;
        }
        return max_heap.top();
    }
};
```

**Time Complexity**:  
- `addNum`: O(log n) for heap operations.  
- `findMedian`: O(1).  

**Space Complexity**: O(n)  
- Two heaps store all elements.

**Explanation**:
- Max-heap stores lower half; min-heap stores upper half.  
- Balance ensures median is easily computed from tops.  
- Handles both odd and even number of elements.

**Test Cases**:
1. **Typical Case**: `addNum(1,2,3), findMedian` → Output: `[1.5,2]`  
2. **Single Number**: `addNum(1), findMedian` → Output: `[1]`  
3. **Even Numbers**: `addNum(1,2), findMedian` → Output: `[1.5]`  
4. **Negative Numbers**: `addNum(-1,-2), findMedian` → Output: `[-1.5]`  
5. **Large Stream**: `addNum(1,2,3,4), findMedian` → Output: `[2.5]`  

---

## 3. LeetCode 215: Kth Largest Element in an Array (Medium)

**Link**: [LeetCode 215](https://leetcode.com/problems/kth-largest-element-in-an-array/)

**Description**:  
Given an integer array `nums` and an integer `k`, return the kth largest element in the array.

**Constraints**:
- `1 <= k <= nums.length <= 10^5`
- `-10^4 <= nums[i] <= 10^4`

**Example**:
- Input: `nums = [3,2,1,5,6,4], k = 2`  
  Output: `5`  
  Explanation: 5 is the second largest element.

**Coding Pattern**: Min-Heap for Kth Largest  
- Use a min-heap to keep the k largest elements.  
- Pop smallest when size exceeds k.  
- Top is the kth largest.

**Optimized Solution**:
```cpp
#include <queue>
#include <vector>
using namespace std;

class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        priority_queue<int, vector<int>, greater<int>> pq; // Min-heap
        for (int num : nums) {
            pq.push(num);
            if (pq.size() > k) {
                pq.pop();
            }
        }
        return pq.top();
    }
};
```

**Time Complexity**: O(n log k)  
- Each push/pop is O(log k); n elements processed.

**Space Complexity**: O(k)  
- Min-heap stores k elements.

**Explanation**:
- Min-heap ensures k largest elements are maintained.  
- Pop smallest when size exceeds k.  
- Top is kth largest after processing all elements.

**Test Cases**:
1. **Typical Case**: `nums = [3,2,1,5,6,4], k = 2` → Output: `5`  
2. **Single Element**: `nums = [1], k = 1` → Output: `1`  
3. **All Same**: `nums = [1,1,1], k = 2` → Output: `1`  
4. **Negative Numbers**: `nums = [-1,-2,-3], k = 1` → Output: `-1`  
5. **k = n**: `nums = [1,2,3], k = 3` → Output: `1`  

---

## 4. LeetCode 347: Top K Frequent Elements (Medium)

**Link**: [LeetCode 347](https://leetcode.com/problems/top-k-frequent-elements/)

**Description**:  
Given an integer array `nums` and an integer `k`, return the k most frequent elements in any order.

**Constraints**:
- `1 <= nums.length <= 10^5`
- `k` is in the range `[1, number of unique elements in nums]`
- `-10^4 <= nums[i] <= 10^4`

**Example**:
- Input: `nums = [1,1,1,2,2,3], k = 2`  
  Output: `[1,2]`  
  Explanation: 1 appears 3 times, 2 appears 2 times.

**Coding Pattern**: Min-Heap with Frequency Map  
- Use a hash map to count frequencies.  
- Use a min-heap to keep k most frequent elements.  
- Extract k elements from the heap.

**Optimized Solution**:
```cpp
#include <queue>
#include <vector>
#include <unordered_map>
using namespace std;

class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int, int> freq;
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq; // Min-heap
        vector<int> result;
        
        // Count frequencies
        for (int num : nums) {
            freq[num]++;
        }
        
        // Keep k elements in min-heap
        for (const auto& p : freq) {
            pq.push({p.second, p.first});
            if (pq.size() > k) {
                pq.pop();
            }
        }
        
        // Extract results
        while (!pq.empty()) {
            result.push_back(pq.top().second);
            pq.pop();
        }
        
        return result;
    }
};
```

**Time Complexity**: O(n log k)  
- Frequency counting: O(n).  
- Heap operations: O(n log k) for n elements.

**Space Complexity**: O(n)  
- Hash map stores n elements; heap stores k elements.

**Explanation**:
- Hash map counts frequencies of each element.  
- Min-heap keeps k most frequent elements.  
- Extract elements from heap for result.

**Test Cases**:
1. **Typical Case**: `nums = [1,1,1,2,2,3], k = 2` → Output: `[1,2]`  
2. **Single Element**: `nums = [1], k = 1` → Output: `[1]`  
3. **All Same**: `nums = [1,1,1], k = 1` → Output: `[1]`  
4. **k = Unique Elements**: `nums = [1,2,3], k = 3` → Output: `[1,2,3]`  
5. **Negative Numbers**: `nums = [-1,-1,-2], k = 2` → Output: `[-1,-2]`  

---

## Test Case Implementation
Below is a program to test all four solutions with the provided test cases.

```cpp
#include <iostream>
#include <queue>
#include <vector>
#include <unordered_map>
using namespace std;

// LeetCode 703: Kth Largest Element in a Stream
class KthLargest {
private:
    priority_queue<int, vector<int>, greater<int>> pq;
    int k;
public:
    KthLargest(int k, vector<int>& nums) : k(k) {
        for (int num : nums) {
            pq.push(num);
            if (pq.size() > k) {
                pq.pop();
            }
        }
    }
    int add(int val) {
        pq.push(val);
        if (pq.size() > k) {
            pq.pop();
        }
        return pq.top();
    }
};

// LeetCode 295: Find Median from Data Stream
class MedianFinder {
private:
    priority_queue<int> max_heap;
    priority_queue<int, vector<int>, greater<int>> min_heap;
public:
    void addNum(int num) {
        if (max_heap.empty() || num < max_heap.top()) {
            max_heap.push(num);
        } else {
            min_heap.push(num);
        }
        if (max_heap.size() > min_heap.size() + 1) {
            min_heap.push(max_heap.top());
            max_heap.pop();
        } else if (min_heap.size() > max_heap.size()) {
            max_heap.push(min_heap.top());
            min_heap.pop();
        }
    }
    double findMedian() {
        if (max_heap.size() == min_heap.size()) {
            return (max_heap.top() + min_heap.top()) / 2.0;
        }
        return max_heap.top();
    }
};

// LeetCode 215: Kth Largest Element in an Array
int findKthLargest(vector<int>& nums, int k) {
    priority_queue<int, vector<int>, greater<int>> pq;
    for (int num : nums) {
        pq.push(num);
        if (pq.size() > k) {
            pq.pop();
        }
    }
    return pq.top();
}

// LeetCode 347: Top K Frequent Elements
vector<int> topKFrequent(vector<int>& nums, int k) {
    unordered_map<int, int> freq;
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq;
    vector<int> result;
    for (int num : nums) {
        freq[num]++;
    }
    for (const auto& p : freq) {
        pq.push({p.second, p.first});
        if (pq.size() > k) {
            pq.pop();
        }
    }
    while (!pq.empty()) {
        result.push_back(pq.top().second);
        pq.pop();
    }
    return result;
}

// Helper to print vector
void printVector(const vector<int>& v) {
    cout << "[";
    for (size_t i = 0; i < v.size(); ++i) {
        cout << v[i];
        if (i < v.size() - 1) cout << ",";
    }
    cout << "]" << endl;
}

int main() {
    // Test LeetCode 703
    cout << "LeetCode 703: Kth Largest Element in a Stream\n";
    vector<int> nums703 = {4, 5, 8, 2};
    KthLargest kl(3, nums703);
    cout << "Test 1: " << kl.add(3) << "," << kl.add(5) << "," << kl.add(10) << "," << kl.add(9) << "," << kl.add(4) << endl; // 4,5,5,8,8

    // Test LeetCode 295
    cout << "\nLeetCode 295: Find Median from Data Stream\n";
    MedianFinder mf;
    mf.addNum(1); mf.addNum(2);
    cout << "Test 1: " << mf.findMedian() << ",";
    mf.addNum(3);
    cout << mf.findMedian() << endl; // 1.5,2

    // Test LeetCode 215
    cout << "\nLeetCode 215: Kth Largest Element in an Array\n";
    vector<int> nums215 = {3, 2, 1, 5, 6, 4};
    cout << "Test 1: " << findKthLargest(nums215, 2) << endl; // 5

    // Test LeetCode 347
    cout << "\nLeetCode 347: Top K Frequent Elements\n";
    vector<int> nums347 = {1, 1, 1, 2, 2, 3};
    cout << "Test 1: "; printVector(topKFrequent(nums347, 2)); // [1,2]

    return 0;
}
```

**Output**:
```
LeetCode 703: Kth Largest Element in a Stream
Test 1: 4,5,5,8,8

LeetCode 295: Find Median from Data Stream
Test 1: 1.5,2

LeetCode 215: Kth Largest Element in an Array
Test 1: 5

LeetCode 347: Top K Frequent Elements
Test 1: [1,2]
```

## Key Takeaways
- **Kth Largest**: LeetCode 703 and 215 use min-heap to efficiently track k largest elements.  
- **Median Finding**: LeetCode 295 uses two heaps for balanced median computation.  
- **Frequency Problems**: LeetCode 347 combines hash map and min-heap for top k elements.  
- **Edge Cases**: Handle empty inputs, single elements, and equal frequencies.  
- **Optimization**: Use min-heap for kth largest/frequent to minimize space and time.

These solutions reinforce priority queue manipulation skills, preparing students for interview scenarios with advanced heap applications.