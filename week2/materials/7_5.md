# Deep Dive: Advanced String Algorithms

This deep dive explores KMP, Rabin-Karp, and their applications in complex interview problems, with connections to array techniques.

## Complex Topics and Illustrations

### KMP Algorithm
Uses LPS array to optimize substring search.

Example (KMP for All Occurrences):
```cpp
#include <iostream>
#include <vector>
#include <string>
std::vector<int> computeLPS(std::string pattern) {
    int m = pattern.length();
    std::vector<int> lps(m, 0);
    int len = 0, i = 1;
    while (i < m) {
        if (pattern[i] == pattern[len]) {
            lps[i++] = ++len;
        } else if (len != 0) {
            len = lps[len - 1];
        } else {
            lps[i++] = 0;
        }
    }
    return lps;
}
std::vector<int> findAllOccurrences(std::string text, std::string pattern) {
    std::vector<int> result;
    int n = text.length(), m = pattern.length();
    std::vector<int> lps = computeLPS(pattern);
    int i = 0, j = 0;
    while (i < n) {
        if (text[i] == pattern[j]) {
            i++;
            j++;
        }
        if (j == m) {
            result.push_back(i - j);
            j = lps[j - 1];
        }
        if (i < n && text[i] != pattern[j]) {
            if (j != 0) j = lps[j - 1];
            else i++;
        }
    }
    return result;
}
int main() {
    std::string text = "AABAACAADAABAAABAA", pattern = "AABA";
    auto res = findAllOccurrences(text, pattern);
    for (int x : res) std::cout << x << " "; // Output: 0 9 13
    std::cout << std::endl;
    return 0;
}
```

### Rabin-Karp Algorithm
Uses rolling hash for efficient substring search.

Example (Rabin-Karp Search):
```cpp
#include <iostream>
#include <string>
#define d 256
int RabinKarp(std::string text, std::string pattern, int q) {
    int n = text.length(), m = pattern.length(), p = 0, t = 0, h = 1;
    for (int i = 0; i < m - 1; i++) h = (h * d) % q;
    for (int i = 0; i < m; i++) {
        p = (d * p + pattern[i]) % q;
        t = (d * t + text[i]) % q;
    }
    for (int i = 0; i <= n - m; i++) {
        if (p == t) {
            bool match = true;
            for (int j = 0; j < m; j++) {
                if (text[i + j] != pattern[j]) {
                    match = false;
                    break;
                }
            }
            if (match) return i;
        }
        if (i < n - m) {
            t = (d * (t - text[i] * h) + text[i + m]) % q;
            if (t < 0) t += q;
        }
    }
    return -1;
}
int main() {
    std::string text = "GEEKSFORGEEKS", pattern = "GEEK";
    std::cout << RabinKarp(text, pattern, 101) << std::endl; // Output: 0
    return 0;
}
```

### Interview Questions and Detailed Answers

1. **Question:** KMP pattern search. (Intention: Efficient substring matching.)  
   **Answer:** Uses LPS array for O(n+m) time.
   ```cpp
   int KMPSearch(std::string text, std::string pattern) {
       int n = text.length(), m = pattern.length();
       std::vector<int> lps(m, 0);
       int len = 0, i = 1;
       while (i < m) {
           if (pattern[i] == pattern[len]) lps[i++] = ++len;
           else if (len != 0) len = lps[len - 1];
           else lps[i++] = 0;
       }
       i = 0; int j = 0;
       while (i < n) {
           if (text[i] == pattern[j]) { i++; j++; }
           if (j == m) return i - j;
           if (i < n && text[i] != pattern[j]) {
               if (j != 0) j = lps[j - 1];
               else i++;
           }
       }
       return -1;
   }
   ```

2. **Question:** Rabin-Karp substring search. (Intention: Rolling hash.)  
   **Answer:** Uses hash to reduce comparison time, O(n+m) average.

3. **Question:** Longest palindromic substring. (Intention: Palindrome detection.)  
   **Answer:** Expand-around-center or Manacherâ€™s for O(n) solution.

4. **Question:** Why use KMP over naive search? (Intention: Optimization.)  
   **Answer:** Reduces redundant comparisons, O(n+m) vs. O(nm).

5. **Question:** Handle edge cases in KMP. (Intention: Robustness.)  
   **Answer:** Check empty strings, pattern longer than text.

6. **Question:** Distinct subsequences. (Intention: Dynamic programming.)  
   **Answer:** Use DP to count subsequences efficiently.

Pitfall: Incorrect LPS computation or hash collisions in Rabin-Karp.