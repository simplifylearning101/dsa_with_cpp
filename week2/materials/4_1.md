# Agenda: Array Optimization and Interview Problems

## Outcome Expected:
By the end of this hour, students will be proficient in optimizing array-based solutions, combining two-pointer, sliding window, prefix sum, and Kadane’s techniques to solve complex interview problems efficiently. Students will tackle real-world coding challenges, focusing on time and space optimization.

## Topics Covered
1. Optimizing Array Solutions (Time and Space Trade-offs).  
2. Combining Multiple Techniques (Two-Pointer, Sliding Window, Prefix Sum).  
3. Handling Edge Cases in Array Problems.  
4. Common Interview Problems (e.g., Trapping Rain Water, Longest Valid Parentheses).  
5. Debugging and Optimization Strategies.

## Detailed Explanation of Topics Covered

### 1. Optimizing Array Solutions
Optimization involves reducing time complexity (e.g., O(n²) to O(n)) or space complexity (e.g., O(n) to O(1)). Techniques like two-pointer and prefix sum are key.

Example (Trapping Rain Water - Two-Pointer):
```cpp
#include <iostream>
#include <vector>
int trapRainWater(int height[], int n) {
    if (n <= 2) return 0;
    int left = 0, right = n - 1, leftMax = 0, rightMax = 0, water = 0;
    while (left < right) {
        if (height[left] < height[right]) {
            if (height[left] >= leftMax) leftMax = height[left];
            else water += leftMax - height[left];
            left++;
        } else {
            if (height[right] >= rightMax) rightMax = height[right];
            else water += rightMax - height[right];
            right--;
        }
    }
    return water;
}
int main() {
    int height[] = {0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1};
    std::cout << trapRainWater(height, 12) << std::endl; // Output: 6
    return 0;
}
```

### 2. Combining Multiple Techniques
Complex problems often require combining techniques (e.g., two-pointer with prefix sum).

Example (Subarray with Given Sum - Sliding Window + Prefix Sum):
```cpp
#include <iostream>
#include <unordered_map>
std::vector<int> subarraySum(int arr[], int n, int k) {
    std::unordered_map<int, int> map;
    map[0] = -1; // Handle case where entire subarray sums to k
    int sum = 0;
    for (int i = 0; i < n; i++) {
        sum += arr[i];
        if (map.find(sum - k) != map.end()) {
            return {map[sum - k] + 1, i};
        }
        map[sum] = i;
    }
    return {};
}
int main() {
    int arr[] = {15, 2, 4, 8, 9, 5, 10, 23};
    auto res = subarraySum(arr, 8, 23);
    for (int x : res) std::cout << x << " "; // Output: 1 2
    std::cout << std::endl;
    return 0;
}
```

### 3. Handling Edge Cases
Common edge cases: empty arrays, single elements, negative numbers, or invalid inputs.

Example (Check Edge Cases in Kadane’s):
```cpp
#include <iostream>
#include <climits>
int maxSubArray(int arr[], int n) {
    if (n == 0) return 0;
    int maxSum = INT_MIN, currSum = 0;
    for (int i = 0; i < n; i++) {
        currSum = std::max(arr[i], currSum + arr[i]);
        maxSum = std::max(maxSum, currSum);
    }
    return maxSum;
}
int main() {
    int arr[] = {-1};
    std::cout << maxSubArray(arr, 1) << std::endl; // Output: -1
    return 0;
}
```

### 4. Common Interview Problems
- **Trapping Rain Water:** Compute water trapped between bars.
- **Longest Valid Parentheses:** Find longest valid substring of parentheses.
- **Container With Most Water:** Maximize area between two lines.

Example (Longest Valid Parentheses - Stack + Two-Pointer):
```cpp
#include <iostream>
#include <stack>
int longestValidParentheses(std::string s) {
    std::stack<int> stack;
    stack.push(-1);
    int maxLen = 0;
    for (int i = 0; i < s.size(); i++) {
        if (s[i] == '(') stack.push(i);
        else {
            stack.pop();
            if (stack.empty()) stack.push(i);
            else maxLen = std::max(maxLen, i - stack.top());
        }
    }
    return maxLen;
}
int main() {
    std::cout << longestValidParentheses("(()())") << std::endl; // Output: 6
    return 0;
}
```

### 5. Debugging and Optimization Strategies
- **Debugging:** Print intermediate states (e.g., pointer positions, sums).
- **Optimization:** Prefer in-place solutions, minimize auxiliary space.
- **Edge Cases:** Test with empty arrays, all negatives, or single elements.

**Cheatsheet:**
| Problem Type | Technique | Time Complexity | Space Complexity |
|--------------|-----------|-----------------|------------------|
| Trapping Rain Water | Two-Pointer | O(n) | O(1) |
| Subarray Sum | Prefix Sum + Hash Map | O(n) | O(n) |
| Longest Valid Parentheses | Stack | O(n) | O(n) |

## Points to Remember
- Combine techniques (e.g., two-pointer with prefix sum) for complex problems.
- Always check edge cases (empty arrays, negative numbers).
- Optimize for O(1) space where possible (e.g., two-pointer over extra arrays).
- Debugging tip: Trace pointer movements or sums.
- Common interview problems: Trapping Rain Water, Longest Valid Parentheses.
- Time complexity: Aim for O(n) or O(n log n).
- Space complexity: Prefer O(1) for in-place solutions.
- Use `std::vector` for dynamic arrays (Week 1) when needed.