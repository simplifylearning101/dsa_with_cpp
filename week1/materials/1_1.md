# Hour 1: Introduction to C++ STL and Vectors

**Agenda**: Introduce students to the C++ Standard Template Library (STL) and focus on vectors as the first container. Teach through real-world analogies and fully commented programs to ensure clarity. Prepare students for coding interviews by emphasizing practical usage and common operations.

**Outcome Expected**:  
By the end of this hour, students will:  
- Understand what the STL is and its components (Containers, Algorithms, Iterators, Functors).  
- Be proficient in using vectors for dynamic array operations (add, remove, access, iterate).  
- Be able to write simple C++ programs using vectors with proper syntax and error handling.  
- Be ready to solve basic array-based problems on platforms like LeetCode.

## Topics Covered
1. **What is the C++ STL?**  
   - Overview of STL and its components.  
   - Real-world analogy: STL as a toolbox for building programs efficiently.  
2. **Vectors: Dynamic Arrays**  
   - Declaration, initialization, and basic operations (push_back, pop_back, size, capacity).  
   - Accessing elements: at(), operator[], front(), back().  
3. **Iterators for Vectors**  
   - Using iterators to traverse and manipulate vectors.  
   - Types of iterators (begin, end, reverse iterators).  

## Detailed Explanation of Topics Covered

### 1. What is the C++ STL?
The **Standard Template Library (STL)** is a set of C++ template classes that provide common data structures and algorithms. Think of it as a kitchen with pre-made tools (containers like vectors, algorithms like sort) that save you from building everything from scratch. The STL has four main components:  
- **Containers**: Store data (e.g., vectors, lists, maps).  
- **Algorithms**: Perform operations (e.g., sort, find).  
- **Iterators**: Navigate containers (like pointers).  
- **Functors**: Function objects for customization.  

For interviews, understanding the STL is crucial because it simplifies coding tasks and is widely used in efficient solutions.

**Example Program**: Basic STL usage with a vector.

```cpp
#include <iostream>
#include <vector> // Include vector library
using namespace std;

int main() {
    // Declare a vector of integers
    vector<int> myList;

    // Add elements to the vector (like adding items to a shopping list)
    myList.push_back(10); // Add 10
    myList.push_back(20); // Add 20
    myList.push_back(30); // Add 30

    // Print size of vector (how many items in the list)
    cout << "Size of vector: " << myList.size() << endl; // Output: 3

    // Access first element
    cout << "First element: " << myList[0] << endl; // Output: 10

    return 0;
}
```

**Explanation**:  
- `#include <vector>`: Imports the vector library.  
- `vector<int> myList`: Creates an empty vector (like an empty shopping list).  
- `push_back`: Adds elements to the end (like adding items to the list).  
- `size()`: Returns the number of elements.  
- `myList[0]`: Accesses elements using index (like picking an item from the list).

### 2. Vectors: Dynamic Arrays
A **vector** is a dynamic array that can grow or shrink as needed, unlike fixed-size C-style arrays. Imagine a shopping list that automatically expands when you add more items. Vectors are stored contiguously in memory, making them efficient for random access but slower for insertions/deletions in the middle.

**Key Operations**:  
- **Declaration**: `vector<int> vec;` (empty vector of integers).  
- **Initialization**: `vector<int> vec = {1, 2, 3};` or `vector<int> vec(5, 0);` (5 zeros).  
- **push_back**: Add element to the end (O(1) amortized).  
- **pop_back**: Remove last element (O(1)).  
- **size**: Number of elements (O(1)).  
- **capacity**: Memory allocated (may be larger than size).  
- **resize**: Change size, adding/removing elements.  
- **reserve**: Pre-allocate memory to avoid reallocations.  
- **Access**: `at(i)` (bounds-checked), `operator[i]` (faster but unsafe), `front()`, `back()`.  

**Example Program**: Vector operations with error handling.

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    // Initialize vector with 3 elements
    vector<int> scores = {85, 90, 95};

    // Add a new score
    scores.push_back(88); // O(1) amortized
    cout << "After push_back, size: " << scores.size() << endl; // Output: 4

    // Access elements safely with at()
    try {
        cout << "Score at index 2: " << scores.at(2) << endl; // Output: 95
        // cout << scores.at(10); // This would throw out_of_range exception
    } catch (const out_of_range& e) {
        cout << "Error: " << e.what() << endl;
    }

    // Remove last score
    scores.pop_back(); // O(1)
    cout << "After pop_back, size: " << scores.size() << endl; // Output: 3

    // Print first and last elements
    cout << "First score: " << scores.front() << endl; // Output: 85
    cout << "Last score: " << scores.back() << endl; // Output: 90

    // Reserve space to avoid reallocations
    scores.reserve(100); // Pre-allocate for 100 elements
    cout << "Capacity: " << scores.capacity() << endl; // Output: >=100

    return 0;
}
```

**Explanation**:  
- `scores.push_back(88)`: Adds 88 to the end.  
- `at(2)`: Safe access with bounds checking.  
- `pop_back()`: Removes the last element.  
- `front()` and `back()`: Access first/last elements.  
- `reserve(100)`: Pre-allocates memory to optimize performance.

### 3. Iterators for Vectors
**Iterators** act like pointers to traverse a vector’s elements. Think of them as a cursor moving through a book’s pages. Iterators allow you to process elements sequentially without using indices.

**Key Iterator Types**:  
- `begin()`: Points to the first element.  
- `end()`: Points to one past the last element (not dereferenceable).  
- `rbegin()`, `rend()`: For reverse iteration.  

**Example Program**: Using iterators to traverse a vector.

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    // Initialize vector
    vector<int> numbers = {1, 2, 3, 4, 5};

    // Use iterator to print elements
    cout << "Forward traversal: ";
    for (vector<int>::iterator it = numbers.begin(); it != numbers.end(); ++it) {
        cout << *it << " "; // Dereference iterator to get value
    }
    cout << endl; // Output: 1 2 3 4 5

    // Use reverse iterator
    cout << "Reverse traversal: ";
    for (vector<int>::reverse_iterator rit = numbers.rbegin(); rit != numbers.rend(); ++rit) {
        cout << *rit << " "; // Dereference reverse iterator
    }
    cout << endl; // Output: 5 4 3 2 1

    // Modify elements using iterator
    for (vector<int>::iterator it = numbers.begin(); it != numbers.end(); ++it) {
        *it += 10; // Add 10 to each element
    }

    // Print modified vector
    cout << "Modified vector: ";
    for (int num : numbers) { // Range-based for loop (modern C++)
        cout << num << " ";
    }
    cout << endl; // Output: 11 12 13 14 15

    return 0;
}
```

**Explanation**:  
- `vector<int>::iterator`: Type for vector iterator.  
- `begin()` and `end()`: Define the range for forward traversal.  
- `rbegin()` and `rend()`: For reverse traversal.  
- `*it`: Dereferences iterator to access/modify the element.  
- Range-based for loop: Modern, simpler way to iterate (introduced for clarity).

## Points to Remember (Interview Preparation)
1. **STL Benefits**: Saves time in interviews by providing efficient, tested implementations.  
2. **Vector vs. Array**: Vectors are dynamic, arrays are fixed-size. Use vectors unless size is known and fixed.  
3. **Time Complexities**:  
   - `push_back`, `pop_back`: O(1) amortized.  
   - `at()`, `[]`, `front()`, `back()`: O(1).  
   - `resize`, `reserve`: O(n) in worst case.  
4. **Safety**: Use `at()` for bounds checking in production code; `[]` is faster but unsafe.  
5. **Iterators**: Essential for STL algorithms (covered later). Understand `begin()`, `end()`, and iterator invalidation (e.g., after `push_back` if reallocation occurs).  
6. **Capacity vs. Size**: `size()` is current elements, `capacity()` is allocated memory. Use `reserve()` to optimize performance.  
7. **Interview Questions**: Be ready to explain when to use vectors (random access, contiguous memory) and their limitations (slow middle insertions).  
8. **Common Errors**: Avoid accessing out-of-bounds indices, dereferencing `end()`, or using invalidated iterators.