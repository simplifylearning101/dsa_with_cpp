# Agenda: Two-Pointer and Sliding Window Techniques for Strings

## Outcome Expected:
By the end of this hour, students will be proficient in applying two-pointer and sliding window techniques to string problems, solving common interview questions like substring matching, anagram detection, and palindrome variants. Students will understand how to adapt array-based techniques (Week 2) to strings and optimize solutions for time and space complexity.

## Topics Covered
1. Two-Pointer Techniques for Strings (Opposite Ends, Same Direction).  
2. Sliding Window for Strings (Fixed and Variable Windows).  
3. String-Specific Optimizations (e.g., Character Frequency).  
4. Common String Interview Patterns (Anagrams, Substrings, Palindromes).  
5. Edge Cases and Optimization Strategies.

## Detailed Explanation of Topics Covered

### 1. Two-Pointer Techniques for Strings
Two-pointer techniques, introduced in Week 2 for arrays, are highly effective for strings. They include:
- **Opposite Ends**: Used for problems like palindrome checks or reversing substrings.
- **Same Direction**: Used for problems like finding duplicate characters.

Example (Reverse Words in a String):
```cpp
#include <iostream>
#include <string>
std::string reverseWords(std::string s) {
    int n = s.length(), start = 0;
    for (int i = 0; i <= n; i++) {
        if (i == n || s[i] == ' ') {
            int left = start, right = i - 1;
            while (left < right) std::swap(s[left++], s[right--]);
            start = i + 1;
        }
    }
    return s;
}
int main() {
    std::string s = "hello world";
    std::cout << reverseWords(s) << std::endl; // Output: olleh dlrow
    return 0;
}
```

### 2. Sliding Window for Strings
Sliding window techniques, fixed or variable, are used for substring problems (e.g., longest substring with k distinct characters).

Example (Longest Substring with At Most K Distinct Characters):
```cpp
#include <iostream>
#include <string>
#include <unordered_map>
int lengthOfLongestSubstringKDistinct(std::string s, int k) {
    std::unordered_map<char, int> map;
    int left = 0, maxLen = 0;
    for (int right = 0; right < s.size(); right++) {
        map[s[right]]++;
        while (map.size() > k) {
            map[s[left]]--;
            if (map[s[left]] == 0) map.erase(s[left]);
            left++;
        }
        maxLen = std::max(maxLen, right - left + 1);
    }
    return maxLen;
}
int main() {
    std::string s = "eceba";
    std::cout << lengthOfLongestSubstringKDistinct(s, 2) << std::endl; // Output: 3
    return 0;
}
```

### 3. String-Specific Optimizations
- **Character Frequency**: Use arrays (size 26 for lowercase letters) or hash maps for counting.
- **In-Place Operations**: Modify strings directly to save space.

Example (Check Anagram with Frequency Array):
```cpp
#include <iostream>
#include <string>
bool isAnagram(std::string s, std::string t) {
    if (s.length() != t.length()) return false;
    int count[26] = {0};
    for (int i = 0; i < s.length(); i++) {
        count[s[i] - 'a']++;
        count[t[i] - 'a']--;
    }
    for (int x : count) if (x != 0) return false;
    return true;
}
int main() {
    std::string s = "anagram", t = "nagaram";
    std::cout << (isAnagram(s, t) ? "Yes" : "No") << std::endl; // Output: Yes
    return 0;
}
```

### 4. Common String Interview Patterns
- **Anagrams**: Compare character frequencies or sorted strings.
- **Substrings**: Find substrings with constraints (e.g., k distinct characters).
- **Palindromes**: Check or find palindromic substrings.
- **String Reversal**: Reverse entire string or substrings.

### 5. Edge Cases and Optimization Strategies
- **Edge Cases**: Empty strings, single characters, non-alphanumeric characters.
- **Optimizations**: Use O(1) space with frequency arrays for fixed character sets; prefer two-pointer over extra space.

**Cheatsheet:**
| Technique | Use Case | Time Complexity | Space Complexity |
|-----------|----------|-----------------|------------------|
| Two-Pointer | Palindrome, Reverse | O(n) | O(1) |
| Sliding Window | Substring with constraints | O(n) | O(k) (k=distinct chars) |
| Frequency Array | Anagrams | O(n) | O(1) (fixed charset) |

## Points to Remember
- Strings can use array techniques (two-pointer, sliding window) due to their array-like structure.
- Sliding window is key for substring problems with constraints (e.g., k distinct characters).
- Frequency arrays are O(1) space for fixed character sets (e.g., lowercase letters).
- Time complexity: O(n) for most string operations; O(n log n) if sorting.
- Space complexity: Aim for O(1) with in-place or frequency arrays.
- Common errors: Out-of-bounds access, incorrect window adjustments.
- Interview tip: Clarify case sensitivity, spaces, and character sets.
- Use `std::string` for dynamic operations (Week 3, Hour 1).