# Hour 11 Quiz: Unordered Maps and Multimaps in STL

Below are 30 questions to test understanding of STL `unordered_map` and `unordered_multimap` and concepts from Hours 1â€“10. The questions are designed for interview preparation, covering key operations and concepts.

## Quiz Questions

1. **What is the primary characteristic of STL `unordered_map`?**  
   a) Stores sorted key-value pairs  
   b) Stores unique key-value pairs with hashing  
   c) Allows duplicate keys  
   d) LIFO structure  
   **Answer**: b) Stores unique key-value pairs with hashing  
   **Explanation**: Uses hash table for O(1) average operations.

2. **Which header is required for `unordered_map`?**  
   a) `<map>`  
   b) `<unordered_map>`  
   c) `<set>`  
   d) `<vector>`  
   **Answer**: b) `<unordered_map>`  
   **Explanation**: Imports `unordered_map` and `unordered_multimap`.

3. **What is the average time complexity of `unordered_map::insert`?**  
   a) O(1)  
   b) O(log n)  
   c) O(n)  
   d) O(n log n)  
   **Answer**: a) O(1)  
   **Explanation**: Hash table operations are O(1) average.

4. **How do you declare an `unordered_map` of strings to integers?**  
   a) `unordered_map<string, int> um;`  
   b) `map<string, int> um;`  
   c) `unordered_multimap<string, int> um;`  
   d) `unordered_map<int, string> um;`  
   **Answer**: a) `unordered_map<string, int> um;`  
   **Explanation**: Declares an unordered map.

5. **What does `um.find(key)` return if key is not in the `unordered_map`?**  
   a) 0  
   b) `um.end()`  
   c) Throws exception  
   d) Null  
   **Answer**: b) `um.end()`  
   **Explanation**: Returns end iterator if not found.

6. **What is the underlying structure of `unordered_map`?**  
   a) Red-black tree  
   b) Hash table  
   c) Array  
   d) Linked list  
   **Answer**: b) Hash table  
   **Explanation**: Enables O(1) average operations.

7. **What does `um.erase(key)` do in an `unordered_map`?**  
   a) Removes one pair  
   b) Removes all pairs with key  
   c) Returns value  
   d) Clears the map  
   **Answer**: a) Removes one pair  
   **Explanation**: `unordered_map` has unique keys.

8. **What is a common use case for `unordered_map`?**  
   a) Storing sorted data  
   b) Fast key-value lookups  
   c) FIFO processing  
   d) Random access  
   **Answer**: b) Fast key-value lookups  
   **Explanation**: Ideal for O(1) lookups.

9. **What is the difference between `unordered_map` and `map`?**  
   a) `unordered_map` is sorted; `map` is not  
   b) `unordered_map` is O(1) average; `map` is O(log n)  
   c) Both are sorted  
   d) Both allow duplicate keys  
   **Answer**: b) `unordered_map` is O(1) average; `map` is O(log n)  
   **Explanation**: Hash table vs. red-black tree.

10. **What is the output of `unordered_map<string, int> um; um["a"] = 1; um["a"] = 2; cout << um.size();`?**  
    a) 1  
    b) 2  
    c) Undefined  
    d) Error  
    **Answer**: a) 1  
    **Explanation**: Duplicate keys update values.

11. **Which operation is NOT supported by `unordered_multimap`?**  
    a) `insert`  
    b) `erase`  
    c) `operator[]`  
    d) `count`  
    **Answer**: c) `operator[]`  
    **Explanation**: Not supported due to duplicate keys.

12. **What does `umm.count(key)` return in an `unordered_multimap`?**  
    a) 0 or 1  
    b) Number of occurrences  
    c) Iterator  
    d) Size  
    **Answer**: b) Number of occurrences  
    **Explanation**: Counts duplicate keys.

13. **Can you access `unordered_map` values by index?**  
    a) Yes  
    b) No  
    c) Only with iterators  
    d) Only in `unordered_multimap`  
    **Answer**: b) No  
    **Explanation**: No random access.

14. **What is the primary characteristic of STL `unordered_multimap`?**  
    a) Stores unique key-value pairs  
    b) Stores key-value pairs with duplicate keys using hashing  
    c) Sorted key-value pairs  
    d) FIFO structure  
    **Answer**: b) Stores key-value pairs with duplicate keys using hashing  
    **Explanation**: Allows duplicate keys with O(1) operations.

15. **What is the output of `unordered_multimap<string, int> umm; umm.insert({"a", 1}); cout << umm.size();`?**  
    a) 0  
    b) 1  
    c) Undefined  
    d) Error  
    **Answer**: b) 1  
    **Explanation**: One pair inserted.

16. **What happens if you insert a duplicate key into an `unordered_map`?**  
    a) Overwrites value  
    b) Ignored  
    c) Throws exception  
    d) Adds duplicate  
    **Answer**: a) Overwrites value  
    **Explanation**: `unordered_map` ensures unique keys.

17. **What is the underlying structure of `unordered_multimap`?**  
    a) Red-black tree  
    b) Hash table  
    c) Array  
    d) Linked list  
    **Answer**: b) Hash table  
    **Explanation**: Supports O(1) average operations.

18. **What does `umm.equal_range(key)` return in `unordered_multimap`?**  
    a) Single iterator  
    b) Pair of iterators  
    c) Value  
    d) Error  
    **Answer**: b) Pair of iterators  
    **Explanation**: Returns range for key.

19. **How do you iterate over an `unordered_map`?**  
    a) Index-based loop  
    b) Range-based for loop  
    c) No iteration possible  
    d) Only with `find`  
    **Answer**: b) Range-based for loop  
    **Explanation**: Supports iteration.

20. **What is the output of `unordered_multimap<string, int> umm; umm.insert({"a", 1}); umm.insert({"a", 2}); cout << umm.count("a");`?**  
    a) 0  
    b) 1  
    c) 2  
    d) Error  
    **Answer**: c) 2  
    **Explanation**: Counts duplicate keys.

21. **What is `unordered_map` best suited for?**  
    a) Sorted data  
    b) Fast key-value lookups  
    c) FIFO operations  
    d) Duplicate keys  
    **Answer**: b) Fast key-value lookups  
    **Explanation**: O(1) average lookups.

22. **What is the worst-case time complexity of `unordered_map::find`?**  
    a) O(1)  
    b) O(log n)  
    c) O(n)  
    d) O(n log n)  
    **Answer**: c) O(n)  
    **Explanation**: Due to hash collisions.

23. **Can you modify a value in an `unordered_map` using `find`?**  
    a) Yes  
    b) Yes, via iterator  
    c) No  
    d) Only in `unordered_multimap`  
    **Answer**: b) Yes, via iterator  
    **Explanation**: Modify `it->second`.

24. **What does `um.empty()` return in an `unordered_map`?**  
    a) Size  
    b) Boolean  
    c) Iterator  
    d) Error  
    **Answer**: b) Boolean  
    **Explanation**: Returns `true` if empty.

25. **What is the average time complexity of `unordered_multimap::count`?**  
    a) O(1)  
    b) O(log n)  
    c) O(n)  
    d) O(n log n)  
    **Answer**: a) O(1)  
    **Explanation**: Hash-based counting.

26. **How do you initialize an `unordered_map` with {("a", 1), ("b", 2)}?**  
    a) `unordered_map<string, int> um = {{"a", 1}, {"b", 2}};`  
    b) `unordered_map<string, int> um; um["a"] = 1; um["b"] = 2;`  
    c) Both a and b  
    d) `unordered_map<string, int> um({"a", 1}, {"b", 2});`  
    **Answer**: c) Both a and b  
    **Explanation**: Both methods work.

27. **What is the output of `unordered_map<string, int> um; um["a"] = 1; cout << um["a"];`?**  
    a) 0  
    b) 1  
    c) Undefined  
    d) Error  
    **Answer**: b) 1  
    **Explanation**: Accesses value.

28. **When should you use `unordered_multimap` over `multimap`?**  
    a) For sorted data  
    b) For faster average-case operations  
    c) For FIFO operations  
    d) For unique keys  
    **Answer**: b) For faster average-case operations  
    **Explanation**: O(1) vs. O(log n).

29. **What does `#include <unordered_map>` do?**  
    a) Includes all containers  
    b) Provides unordered_map and unordered_multimap  
    c) Enables algorithms  
    d) Defines vector  
    **Answer**: b) Provides unordered_map and unordered_multimap  
    **Explanation**: Imports STL unordered containers.

30. **What is a limitation of `unordered_multimap`?**  
    a) Slow lookups  
    b) No operator[]  
    c) Sorted order  
    d) No iteration  
    **Answer**: b) No operator[]  
    **Explanation**: Due to duplicate keys.