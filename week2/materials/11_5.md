# Project Deep Dive: Inventory Management System

This deep dive explores the logic and implementation of the inventory management system.

## Key Components and Logic

### Item Addition
**Logic**: Search for existing item using string comparison (two-pointer or find), update quantity if found.
```cpp
void addItem(std::vector<std::pair<std::string, int>>& inventory, std::string name, int qty) {
    for (auto& item : inventory) {
        if (item.first == name) {
            item.second += qty;
            return;
        }
    }
    inventory.push_back({name, qty});
}
```
**Complexity**: O(n) time (linear search), O(1) space.

### Item Search with KMP
**Logic**: Concatenate all item names, use KMP to find pattern in concatenated string.
```cpp
int KMPSearch(std::string text, std::string pattern) {
    int n = text.length(), m = pattern.length();
    std::vector<int> lps = computeLPS(pattern);
    int i = 0, j = 0;
    while (i < n) {
        if (text[i] == pattern[j]) { i++; j++; }
        if (j == m) return i - j;
        if (i < n && text[i] != pattern[j]) {
            if (j != 0) j = lps[j - 1];
            else i++;
        }
    }
    return -1;
}
```
**Logic**: LPS array skips redundant comparisons.

### Grouping by Category
**Logic**: Use hash map with first letter as key.
```cpp
std::unordered_map<char, std::vector<std::string>> groupByCategory(const std::vector<std::pair<std::string, int>>& inventory) {
    std::unordered_map<char, std::vector<std::string>> groups;
    for (const auto& item : inventory) {
        if (!item.first.empty()) groups[item.first[0]].push_back(item.first);
    }
    return groups;
}
```
**Logic**: Simple categorization; can extend to anagram grouping.

### Compression
**Logic**: Concatenate names and quantities, then compress consecutive characters.
```cpp
std::string compressInventory(const std::vector<std::pair<std::string, int>>& inventory) {
    std::string result;
    for (const auto& item : inventory) {
        result += item.first + std::to_string(item.second);
    }
    int n = result.length(), write = 0, count = 1, start = 0;
    std::string compressed = result;
    for (int i = 1; i <= n; i++) {
        if (i < n && result[i] == result[i - 1]) {
            count++;
        } else {
            compressed[write++] = result[start];
            if (count > 1) {
                std::string num = std::to_string(count);
                for (char c : num) compressed[write++] = c;
            }
            start = i;
            count = 1;
        }
    }
    return compressed.substr(0, write);
}
```
**Logic**: In-place counting for compression.

## Interview Insights
- **KMP**: Efficient for large texts, O(n+m).
- **Grouping**: Frequency for O(1) space in fixed charset.
- **Compression**: In-place to save space.
- **Pitfalls**: File errors, empty inventories, invalid data.