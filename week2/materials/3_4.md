# Quiz: Advanced Array Problems and Two-Pointer Applications

30 questions: 20 on advanced array problems/two-pointer applications, 5 on two-pointer basics (Week 2, Hour 2), 5 on arrays/C++ fundamentals (Weeks 0-2).

1. What is the sliding window technique?  
2. Difference between fixed and variable sliding windows?  
3. Write code for maximum sum of k consecutive elements.  
4. What is Kadane’s algorithm used for?  
5. Write code for Kadane’s algorithm.  
6. How does prefix sum help with range queries?  
7. Write code for prefix sum range query.  
8. True/False: Sliding window always uses O(1) space.  
9. What is the time complexity of Kadane’s algorithm?  
10. Write code for smallest subarray with sum >= k.  
11. How to count subarrays with sum equal to k?  
12. True/False: Prefix sum requires O(n) space.  
13. Write code for longest substring with k distinct characters.  
14. Common pitfall in sliding window implementations?  
15. How to handle negative numbers in Kadane’s algorithm?  
16. Write code to rotate an array by k positions.  
17. What is the maximum product subarray problem?  
18. Write code for maximum product subarray.  
19. True/False: Sliding window can solve product-based problems.  
20. Example of an advanced array problem in interviews.  
21. (Two-Pointer) What are two types of two-pointer techniques?  
22. (Two-Pointer) Write code to remove duplicates from a sorted array.  
23. (Two-Pointer) Time complexity of pair sum in sorted array?  
24. (Two-Pointer) How to move zeros to the end of an array?  
25. (Two-Pointer) Common error in two-pointer logic?  
26. (Arrays) How to initialize an array with zeros?  
27. (Arrays) What is array decay?  
28. (C++ Fundamentals) Role of const in arrays?  
29. (STL) How to use std::vector for dynamic arrays?  
30. (STL) How to sort an array using STL?

## Solutions for the Quiz

1. Uses two pointers to maintain a dynamic window for subarray/substring problems.  
2. Fixed: Constant window size; Variable: Window size adjusts based on condition.  
3. 
   ```cpp
   int maxSumK(int arr[], int n, int k) {
       int sum = 0;
       for (int i = 0; i < k; i++) sum += arr[i];
       int maxSum = sum;
       for (int i = k; i < n; i++) {
           sum += arr[i] - arr[i - k];
           maxSum = std::max(maxSum, sum);
       }
       return maxSum;
   }
   ```
4. Finds maximum subarray sum in O(n) time.  
5. 
   ```cpp
   int maxSubArray(int arr[], int n) {
       int maxSum = arr[0], currSum = arr[0];
       for (int i = 1; i < n; i++) {
           currSum = std::max(arr[i], currSum + arr[i]);
           maxSum = std::max(maxSum, currSum);
       }
       return maxSum;
   }
   ```
6. Precomputes cumulative sums for O(1) range queries.  
7. 
   ```cpp
   int rangeSum(int arr[], int n, int left, int right) {
       std::vector<int> prefix(n + 1, 0);
       for (int i = 0; i < n; i++) prefix[i + 1] = prefix[i] + arr[i];
       return prefix[right + 1] - prefix[left];
   }
   ```
8. False, may use O(n) for hash maps in some cases.  
9. O(n).  
10. 
   ```cpp
   int smallestSubarray(int arr[], int n, int k) {
       int sum = 0, minLen = n + 1, left = 0;
       for (int right = 0; right < n; right++) {
           sum += arr[right];
           while (sum >= k && left <= right) {
               minLen = std::min(minLen, right - left + 1);
               sum -= arr[left++];
           }
       }
       return minLen > n ? -1 : minLen;
   }
   ```
11. Use prefix sum with hash map to count sums.  
12. True.  
13. 
   ```cpp
   int lengthOfLongestSubstringKDistinct(std::string s, int k) {
       std::unordered_map<char, int> map;
       int left = 0, maxLen = 0;
       for (int right = 0; right < s.size(); right++) {
           map[s[right]]++;
           while (map.size() > k) {
               map[s[left]]--;
               if (map[s[left]] == 0) map.erase(s[left]);
               left++;
           }
           maxLen = std::max(maxLen, right - left + 1);
       }
       return maxLen;
   }
   ```
14. Incorrect window adjustments or out-of-bounds access.  
15. Kadane’s handles negatives by resetting currSum when negative.  
16. 
   ```cpp
   void rotate(int arr[], int n, int k) {
       k %= n;
       std::reverse(arr, arr + n);
       std::reverse(arr, arr + k);
       std::reverse(arr + k, arr + n);
   }
   ```
17. Find contiguous subarray with maximum product.  
18. 
   ```cpp
   int maxProduct(int arr[], int n) {
       int maxProd = arr[0], currMax = arr[0], currMin = arr[0];
       for (int i = 1; i < n; i++) {
           int temp = currMax;
           currMax = std::max({arr[i], currMax * arr[i], currMin * arr[i]});
           currMin = std::min({arr[i], temp * arr[i], currMin * arr[i]});
           maxProd = std::max(maxProd, currMax);
       }
       return maxProd;
   }
   ```
19. True, e.g., subarrays with product < k.  
20. Maximum Subarray, Subarray Sum Equals K.  
21. Opposite ends, same direction.  
22. 
   ```cpp
   int removeDuplicates(int arr[], int n) {
       if (n <= 1) return n;
       int i = 0;
       for (int j = 1; j < n; j++) {
           if (arr[j] != arr[i]) arr[++i] = arr[j];
       }
       return i + 1;
   }
   ```
23. O(n) after O(n log n) sort.  
24. 
   ```cpp
   void moveZeroes(int arr[], int n) {
       int nonZeroPos = 0;
       for (int i = 0; i < n; i++) {
           if (arr[i] != 0) arr[nonZeroPos++] = arr[i];
       }
       while (nonZeroPos < n) arr[nonZeroPos++] = 0;
   }
   ```
25. Incorrect pointer updates or bounds checking.  
26. 
   ```cpp
   int arr[5] = {};
   ```
27. Array becomes pointer in functions, losing size.  
28. Prevents array modification, e.g., `const int arr[]`.  
29. 
   ```cpp
   std::vector<int> v;
   ```
30. 
   ```cpp
   std::sort(arr, arr + n);
   ```