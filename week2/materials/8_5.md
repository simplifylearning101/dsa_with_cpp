# Deep Dive: String Optimization and Common Interview Problems

This deep dive explores optimization techniques for strings and tackles complex interview problems.

## Complex Topics and Illustrations

### In-Place String Compression
Compress repeated characters without extra space.

Example:
```cpp
#include <iostream>
#include <string>
int compress(std::string& chars) {
    int n = chars.length(), write = 0, count = 1, start = 0;
    for (int i = 1; i <= n; i++) {
        if (i < n && chars[i] == chars[i - 1]) {
            count++;
        } else {
            chars[write++] = chars[start];
            if (count > 1) {
                std::string num = std::to_string(count);
                for (char c : num) chars[write++] = c;
            }
            start = i;
            count = 1;
        }
    }
    return write;
}
int main() {
    std::string s = "aabbccc";
    int len = compress(s);
    for (int i = 0; i < len; i++) std::cout << s[i]; // Output: a2b2c3
    std::cout << std::endl;
    return 0;
}
```

### Edit Distance with Dynamic Programming
Compute minimum operations (insert, delete, replace) to transform strings.

Example:
```cpp
#include <iostream>
#include <string>
#include <vector>
int minDistance(std::string word1, std::string word2) {
    int m = word1.length(), n = word2.length();
    std::vector<std::vector<int>> dp(m + 1, std::vector<int>(n + 1, 0));
    for (int i = 0; i <= m; i++) dp[i][0] = i;
    for (int j = 0; j <= n; j++) dp[0][j] = j;
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (word1[i - 1] == word2[j - 1]) dp[i][j] = dp[i - 1][j - 1];
            else dp[i][j] = std::min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;
        }
    }
    return dp[m][n];
}
int main() {
    std::string word1 = "horse", word2 = "ros";
    std::cout << minDistance(word1, word2) << std::endl; // Output: 3
    return 0;
}
```

### Interview Questions and Detailed Answers

1. **Question:** String compression in-place. (Intention: Space optimization.)  
   **Answer:** Track counts and write compressed string directly.
   ```cpp
   int compress(std::string& chars) {
       int n = chars.length(), write = 0, count = 1, start = 0;
       for (int i = 1; i <= n; i++) {
           if (i < n && chars[i] == chars[i - 1]) {
               count++;
           } else {
               chars[write++] = chars[start];
               if (count > 1) {
                   std::string num = std::to_string(count);
                   for (char c : num) chars[write++] = c;
               }
               start = i;
               count = 1;
           }
       }
       return write;
   }
   ```

2. **Question:** Edit distance. (Intention: Dynamic programming.)  
   **Answer:** Use DP table to track minimum operations.

3. **Question:** Regular expression matching. (Intention: Pattern matching.)  
   **Answer:** Use DP to handle '.' and '*'.

4. **Question:** Why use in-place operations? (Intention: Optimization.)  
   **Answer:** Reduces space complexity to O(1).

5. **Question:** Handle edge cases in string compression. (Intention: Robustness.)  
   **Answer:** Check empty strings, single characters.

6. **Question:** Longest valid parentheses. (Intention: Stack usage.)  
   **Answer:** Use stack to track valid pairs.

Pitfall: Incorrect DP initialization or mishandling multiple spaces in string reversal.