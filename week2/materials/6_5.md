# Deep Dive: Two-Pointer and Sliding Window for Strings

This deep dive explores advanced two-pointer and sliding window applications for strings, focusing on interview problems.

## Complex Topics and Illustrations

### Variable Sliding Window
Used for substring problems with constraints (e.g., k distinct characters).

Example (Longest Substring with At Most K Distinct Characters):
```cpp
#include <iostream>
#include <string>
#include <unordered_map>
int lengthOfLongestSubstringKDistinct(std::string s, int k) {
    std::unordered_map<char, int> map;
    int left = 0, maxLen = 0;
    for (int right = 0; right < s.size(); right++) {
        map[s[right]]++;
        while (map.size() > k) {
            map[s[left]]--;
            if (map[s[left]] == 0) map.erase(s[left]);
            left++;
        }
        maxLen = std::max(maxLen, right - left + 1);
    }
    return maxLen;
}
int main() {
    std::string s = "eceba";
    std::cout << lengthOfLongestSubstringKDistinct(s, 2) << std::endl; // Output: 3
    return 0;
}
```

### Sliding Window with Frequency Counting
Used for anagram or substring matching problems.

Example (Find All Anagrams in a String):
```cpp
#include <iostream>
#include <vector>
#include <string>
std::vector<int> findAnagrams(std::string s, std::string p) {
    std::vector<int> result;
    if (p.size() > s.size()) return result;
    int count[26] = {0}, window[26] = {0};
    for (char c : p) count[c - 'a']++;
    for (int i = 0; i < p.size(); i++) window[s[i] - 'a']++;
    if (std::equal(count, count + 26, window)) result.push_back(0);
    for (int i = p.size(); i < s.size(); i++) {
        window[s[i] - 'a']++;
        window[s[i - p.size()] - 'a']--;
        if (std::equal(count, count + 26, window)) result.push_back(i - p.size() + 1);
    }
    return result;
}
int main() {
    std::string s = "cbaebabacd", p = "abc";
    auto res = findAnagrams(s, p);
    for (int x : res) std::cout << x << " "; // Output: 0 6
    std::cout << std::endl;
    return 0;
}
```

### Interview Questions and Detailed Answers

1. **Question:** Longest substring with k distinct characters. (Intention: Sliding window.)  
   **Answer:** Use variable window with hash map to track character counts.
   ```cpp
   int lengthOfLongestSubstringKDistinct(std::string s, int k) {
       std::unordered_map<char, int> map;
       int left = 0, maxLen = 0;
       for (int right = 0; right < s.size(); right++) {
           map[s[right]]++;
           while (map.size() > k) {
               map[s[left]]--;
               if (map[s[left]] == 0) map.erase(s[left]);
               left++;
           }
           maxLen = std::max(maxLen, right - left + 1);
       }
       return maxLen;
   }
   ```

2. **Question:** Find all anagrams in a string. (Intention: Frequency counting.)  
   **Answer:** Use sliding window with frequency array for O(n) solution.

3. **Question:** Minimum window substring. (Intention: Complex sliding window.)  
   **Answer:** Track required characters and minimize window.

4. **Question:** Why use frequency arrays for strings? (Intention: Optimization.)  
   **Answer:** O(1) space for fixed character sets (e.g., lowercase letters).

5. **Question:** Handle edge cases in sliding window for strings. (Intention: Robustness.)  
   **Answer:** Check empty strings, invalid k, or no valid window.

6. **Question:** Longest repeating character replacement. (Intention: Window constraints.)  
   **Answer:** Use sliding window to maximize length with k replacements.

Pitfall: Ensure proper window contraction and edge case handling (e.g., empty strings).