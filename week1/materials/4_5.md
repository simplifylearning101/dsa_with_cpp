# Deep Dive into C++ STL Stacks

This document is an advanced exploration of STL `stack` for students aiming to master stack-based algorithms for coding interviews. It covers internals, advanced applications, and interview questions with detailed answers, building on Hours 1–3 (vectors, arrays/deques, strings).

## Agenda
- Deep dive into stack internals, operations, and optimizations.
- Illustrate complex scenarios with commented programs.
- Prepare for interviews with challenging questions and answers.

## Outcome Expected
Students will:
- Understand stack internals (container adapter, underlying deque).
- Master advanced stack applications (e.g., monotonic stacks, expression parsing).
- Optimize performance and handle edge cases.
- Answer complex stack-related interview questions confidently.

## Topics Covered
1. **Stack Internals**  
   - Container adapter design, underlying container (deque).  
   - LIFO enforcement and performance characteristics.  
   - Real-world analogy: Stack as a pile of books.  
2. **Advanced Applications**  
   - Monotonic stacks for next greater/smaller elements.  
   - Expression evaluation and parentheses matching.  
   - Real-world analogy: Undo stack in a text editor.  
3. **Optimization and Pitfalls**  
   - Choosing the right underlying container.  
   - Handling empty stack errors.  
   - Edge cases (e.g., single element, large inputs).  

## Detailed Explanation

### 1. Stack Internals
STL `stack` is a container adapter that wraps an underlying container (default: `deque`) to enforce LIFO behavior. It restricts access to `push`, `pop`, and `top`, ensuring simplicity and safety. Think of a stack as a pile of books where you can only add or remove the top book.

- **Container Adapter**: Wraps `deque`, `vector`, or `list`.  
- **Performance**: O(1) for `push`, `pop`, `top` with `deque` or `vector`.  
- **Limitations**: No iterators, no random access.

**Example Program**: Stack with custom container.

```cpp
#include <iostream>
#include <stack>
#include <vector>
using namespace std;

int main() {
    // Stack with vector as underlying container
    stack<int, vector<int>> s;
    
    // Push elements
    s.push(1); s.push(2); s.push(3);
    
    // Print size and top
    cout << "Size: " << s.size() << endl; // Output: 3
    cout << "Top: " << s.top() << endl; // Output: 3
    
    // Pop and check
    s.pop();
    cout << "After pop, top: " << s.top() << endl; // Output: 2
    
    return 0;
}
```

**Explanation**:  
- `stack<int, vector<int>>`: Uses vector instead of default deque.  
- Operations remain O(1) amortized.  
- Vector may reallocate, but stack interface hides complexity.

### 2. Advanced Applications
Stacks are powerful for problems like parentheses matching, expression evaluation, and monotonic stack problems (e.g., next greater element). They excel in scenarios requiring LIFO order, such as undo operations in a text editor.

**Example Program**: Monotonic stack for next greater element.

```cpp
#include <iostream>
#include <stack>
#include <vector>
using namespace std;

vector<int> nextGreaterElement(const vector<int>& arr) {
    vector<int> result(arr.size(), -1);
    stack<int> s; // Store indices
    
    // Iterate through array
    for (int i = 0; i < arr.size(); ++i) {
        // Pop elements with smaller values
        while (!s.empty() && arr[i] > arr[s.top()]) {
            result[s.top()] = arr[i];
            s.pop();
        }
        s.push(i); // Push current index
    }
    
    return result;
}

int main() {
    vector<int> arr = {4, 5, 2, 25};
    vector<int> result = nextGreaterElement(arr);
    
    // Print results
    for (int x : result) {
        cout << x << " "; // Output: 5 25 25 -1
    }
    cout << endl;
    
    return 0;
}
```

**Explanation**:  
- Stack stores indices of elements in monotonic order.  
- Pop when a larger element is found, updating the result.  
- Remaining elements have no greater element (`-1`).

### 3. Optimization and Pitfalls
- **Optimization**: Use `deque` (default) for balanced performance; `vector` for memory efficiency; `list` for rare cases.  
- **Pitfalls**: Always check `empty()` before `top` or `pop`; no direct access to non-top elements.

**Example Program**: Safe stack operations.

```cpp
#include <iostream>
#include <stack>
using namespace std;

void safePop(stack<int>& s) {
    if (s.empty()) {
        cout << "Stack is empty, cannot pop" << endl;
        return;
    }
    cout << "Popped: " << s.top() << endl;
    s.pop();
}

int main() {
    stack<int> s;
    s.push(1); s.push(2);
    
    safePop(s); // Output: Popped: 2
    safePop(s); // Output: Popped: 1
    safePop(s); // Output: Stack is empty, cannot pop
    
    return 0;
}
```

**Explanation**:  
- `safePop`: Checks `empty()` to avoid undefined behavior.  
- Ensures robust code for production and interviews.

## Interview Questions and Answers
Below are 15 advanced interview questions on stacks.

1. **Question**: What is a stack’s primary characteristic?  
   **Answer**: LIFO (Last-In-First-Out).  
   **Interviewer’s Intention**: Tests basic understanding.

2. **Question**: Why use `deque` as the default container for `stack`?**  
   **Answer**: Provides O(1) push/pop at both ends with efficient memory usage.  
   **Interviewer’s Intention**: Checks container knowledge.

3. **Question**: What is the time complexity of `stack::push`?**  
   **Answer**: O(1) amortized (with deque or vector).  
   **Interviewer’s Intention**: Tests operation cost awareness.

4. **Question**: Write a program to check if parentheses are balanced.  
   **Answer**:  
```cpp
#include <iostream>
#include <stack>
#include <string>
using namespace std;

bool isValid(const string& s) {
    stack<char> parentheses;
    for (char c : s) {
        if (c == '(' || c == '{' || c == '[') {
            parentheses.push(c);
        } else if (c == ')' || c == '}' || c == ']') {
            if (parentheses.empty()) return false;
            char top = parentheses.top();
            if ((c == ')' && top != '(') || 
                (c == '}' && top != '{') || 
                (c == ']' && top != '[')) return false;
            parentheses.pop();
        }
    }
    return parentheses.empty();
}

int main() {
    string s = "({[]})";
    cout << (isValid(s) ? "Valid" : "Invalid") << endl; // Output: Valid
    return 0;
}
```
   **Interviewer’s Intention**: Tests stack application.

5. **Question**: How do you handle empty stack errors?**  
   **Answer**: Check `empty()` before `top` or `pop`.  
   **Interviewer’s Intention**: Ensures error handling.

6. **Question**: What is a monotonic stack?**  
   **Answer**: A stack maintaining elements in increasing or decreasing order, used for next greater/smaller problems.  
   **Interviewer’s Intention**: Tests advanced concepts.

7. **Question**: Write a program to evaluate a postfix expression.  
   **Answer**:  
```cpp
#include <iostream>
#include <stack>
#include <string>
using namespace std;

int evaluatePostfix(const string& expr) {
    stack<int> s;
    for (char c : expr) {
        if (isdigit(c)) s.push(c - '0');
        else if (c == '+' || c == '*') {
            int b = s.top(); s.pop();
            int a = s.top(); s.pop();
            if (c == '+') s.push(a + b);
            else s.push(a * b);
        }
    }
    return s.top();
}

int main() {
    string expr = "2 3 +";
    cout << evaluatePostfix(expr) << endl; // Output: 5
    return 0;
}
```
   **Interviewer’s Intention**: Tests stack for parsing.

8. **Question**: Why can’t you iterate a stack?**  
   **Answer**: Stack restricts to LIFO access; no iterators are provided.  
   **Interviewer’s Intention**: Tests container limitations.

9. **Question**: When should you use a stack over a deque?**  
   **Answer**: Use stack for strict LIFO operations; deque for flexible access.  
   **Interviewer’s Intention**: Tests container selection.

10. **Question**: Write a program to find next greater element.  
    **Answer**: (See monotonic stack example above.)  
    **Interviewer’s Intention**: Tests advanced stack usage.

11. **Question**: What is the space complexity of a stack?**  
    **Answer**: O(n), where n is number of elements.  
    **Interviewer’s Intention**: Tests complexity awareness.

12. **Question**: Write a program to implement a stack with min() function.  
    **Answer**:  
```cpp
#include <iostream>
#include <stack>
using namespace std;

class MinStack {
private:
    stack<int> values, mins;
public:
    void push(int x) {
        values.push(x);
        if (mins.empty() || x <= mins.top()) mins.push(x);
    }
    void pop() {
        if (!values.empty()) {
            if (values.top() == mins.top()) mins.pop();
            values.pop();
        }
    }
    int min() {
        return mins.empty() ? -1 : mins.top();
    }
};

int main() {
    MinStack s;
    s.push(3); s.push(5); s.push(2);
    cout << "Min: " << s.min() << endl; // Output: 2
    return 0;
}
```
    **Interviewer’s Intention**: Tests extended functionality.

13. **Question**: Why use a stack for undo operations?**  
    **Answer**: LIFO order matches undoing the last action.  
    **Interviewer’s Intention**: Tests real-world application.

14. **Question**: How do you reverse a stack?**  
    **Answer**: Use another stack or recursion to reorder elements.  
    **Interviewer’s Intention**: Tests manipulation skills.

15. **Question**: Write a program to remove duplicates using a stack.  
    **Answer**: (See homework solution 10.)  
    **Interviewer’s Intention**: Tests stack and string integration.

## Practice Recommendations
- Solve LeetCode problems like **Valid Parentheses** and **Min Stack**.  
- Experiment with monotonic stacks for array problems.  
- Practice safe stack operations with `empty()` checks.