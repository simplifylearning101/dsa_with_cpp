# Hour 4 Homework Solutions: Stack Practice Problems

Below are solutions to the 12 homework problems, each with fully commented C++ code to help students understand STL `stack` implementation. The solutions are beginner-friendly and emphasize interview-relevant techniques.

1. **Problem**: Create a stack, push 5 integers, and print its size.  
```cpp
#include <iostream>
#include <stack>
using namespace std;

int main() {
    stack<int> s;
    
    // Push 5 integers
    for (int i = 1; i <= 5; ++i) {
        s.push(i);
    }
    
    // Print size
    cout << "Size: " << s.size() << endl; // Output: 5
    
    return 0;
}
```

2. **Problem**: Pop elements and print in reverse order.  
```cpp
#include <iostream>
#include <stack>
using namespace std;

int main() {
    stack<int> s;
    s.push(1); s.push(2); s.push(3);
    
    // Pop and print
    while (!s.empty()) {
        cout << s.top() << " "; // Output: 3 2 1
        s.pop();
    }
    cout << endl;
    
    return 0;
}
```

3. **Problem**: Check if a stack is empty after pushing and popping.  
```cpp
#include <iostream>
#include <stack>
using namespace std;

int main() {
    stack<int> s;
    s.push(1);
    s.pop();
    
    // Check empty
    cout << "Empty: " << (s.empty() ? "Yes" : "No") << endl; // Output: Yes
    
    return 0;
}
```

4. **Problem**: Reverse a stack using another stack.  
```cpp
#include <iostream>
#include <stack>
using namespace std;

void reverseStack(stack<int>& s) {
    stack<int> temp;
    // Move all elements to temp
    while (!s.empty()) {
        temp.push(s.top());
        s.pop();
    }
    s = temp; // Copy back
}

int main() {
    stack<int> s;
    s.push(1); s.push(2); s.push(3);
    reverseStack(s);
    
    // Print reversed stack
    while (!s.empty()) {
        cout << s.top() << " "; // Output: 3 2 1
        s.pop();
    }
    cout << endl;
    
    return 0;
}
```

5. **Problem**: Evaluate a simple postfix expression.  
```cpp
#include <iostream>
#include <stack>
#include <string>
using namespace std;

int evaluatePostfix(const string& expr) {
    stack<int> s;
    for (char c : expr) {
        if (isdigit(c)) {
            s.push(c - '0');
        } else if (c == '+' || c == '*') {
            int b = s.top(); s.pop();
            int a = s.top(); s.pop();
            if (c == '+') s.push(a + b);
            else s.push(a * b);
        }
    }
    return s.top();
}

int main() {
    string expr = "2 3 +"; // 2 + 3 = 5
    cout << "Result: " << evaluatePostfix(expr) << endl; // Output: 5
    return 0;
}
```

6. **Problem**: Check if parentheses are balanced.  
```cpp
#include <iostream>
#include <stack>
#include <string>
using namespace std;

bool isBalanced(const string& s) {
    stack<char> parentheses;
    for (char c : s) {
        if (c == '(' || c == '{' || c == '[') {
            parentheses.push(c);
        } else if (c == ')' || c == '}' || c == ']') {
            if (parentheses.empty()) return false;
            char top = parentheses.top();
            if ((c == ')' && top != '(') || 
                (c == '}' && top != '{') || 
                (c == ']' && top != '[')) return false;
            parentheses.pop();
        }
    }
    return parentheses.empty();
}

int main() {
    string s = "({[]})";
    cout << (isBalanced(s) ? "Yes" : "No") << endl; // Output: Yes
    return 0;
}
```

7. **Problem**: Find next greater element in an array.  
```cpp
#include <iostream>
#include <stack>
#include <vector>
using namespace std;

vector<int> nextGreaterElement(const vector<int>& arr) {
    vector<int> result(arr.size(), -1);
    stack<int> s; // Store indices
    for (int i = 0; i < arr.size(); ++i) {
        while (!s.empty() && arr[i] > arr[s.top()]) {
            result[s.top()] = arr[i];
            s.pop();
        }
        s.push(i);
    }
    return result;
}

int main() {
    vector<int> arr = {4, 5, 2, 25};
    vector<int> result = nextGreaterElement(arr);
    for (int x : result) cout << x << " "; // Output: 5 25 25 -1
    cout << endl;
    return 0;
}
```

8. **Problem**: Implement a stack with max() function.  
```cpp
#include <iostream>
#include <stack>
using namespace std;

class MaxStack {
private:
    stack<int> values;
    stack<int> max_values; // Tracks maximum
public:
    void push(int x) {
        values.push(x);
        if (max_values.empty() || x >= max_values.top()) {
            max_values.push(x);
        }
    }
    void pop() {
        if (!values.empty()) {
            if (values.top() == max_values.top()) {
                max_values.pop();
            }
            values.pop();
        }
    }
    int max() {
        return max_values.empty() ? -1 : max_values.top();
    }
};

int main() {
    MaxStack s;
    s.push(3); s.push(5); s.push(2);
    cout << "Max: " << s.max() << endl; // Output: 5
    s.pop();
    cout << "Max after pop: " << s.max() << endl; // Output: 5
    return 0;
}
```

9. **Problem**: Reverse a string using a stack.  
```cpp
#include <iostream>
#include <stack>
#include <string>
using namespace std;

string reverseString(const string& s) {
    stack<char> chars;
    for (char c : s) chars.push(c);
    string result;
    while (!chars.empty()) {
        result += chars.top();
        chars.pop();
    }
    return result;
}

int main() {
    string s = "hello";
    cout << "Reversed: " << reverseString(s) << endl; // Output: olleh
    return 0;
}
```

10. **Problem**: Remove adjacent duplicate elements from a string.  
```cpp
#include <iostream>
#include <stack>
#include <string>
using namespace std;

string removeDuplicates(const string& s) {
    stack<char> chars;
    for (char c : s) {
        if (!chars.empty() && chars.top() == c) {
            chars.pop();
        } else {
            chars.push(c);
        }
    }
    string result;
    while (!chars.empty()) {
        result = chars.top() + result; // Build in reverse
        chars.pop();
    }
    return result;
}

int main() {
    string s = "abbaca";
    cout << "Result: " << removeDuplicates(s) << endl; // Output: ca
    return 0;
}
```

11. **Problem**: Implement a stack using two vectors.  
```cpp
#include <iostream>
#include <vector>
using namespace std;

class MyStack {
private:
    vector<int> v1, v2; // Two vectors for stack
public:
    void push(int x) {
        v1.push_back(x);
    }
    void pop() {
        if (!v1.empty()) v1.pop_back();
    }
    int top() {
        return v1.empty() ? -1 : v1.back();
    }
    bool empty() {
        return v1.empty();
    }
};

int main() {
    MyStack s;
    s.push(1); s.push(2); s.push(3);
    cout << "Top: " << s.top() << endl; // Output: 3
    s.pop();
    cout << "Top after pop: " << s.top() << endl; // Output: 2
    return 0;
}
```

12. **Problem**: Find length of longest valid parentheses substring.  
```cpp
#include <iostream>
#include <stack>
#include <string>
using namespace std;

int longestValidParentheses(const string& s) {
    stack<int> indices;
    indices.push(-1); // Base index
    int max_len = 0;
    
    for (int i = 0; i < s.size(); ++i) {
        if (s[i] == '(') {
            indices.push(i);
        } else {
            indices.pop();
            if (indices.empty()) {
                indices.push(i); // New base
            } else {
                max_len = max(max_len, i - indices.top());
            }
        }
    }
    return max_len;
}

int main() {
    string s = "(()";
    cout << "Longest valid length: " << longestValidParentheses(s) << endl; // Output: 2
    return 0;
}
```