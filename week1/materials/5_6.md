# Hour 5 LeetCode Problem: Sliding Window Maximum

This document illustrates **LeetCode 239: Sliding Window Maximum**, a hard problem that leverages STL `deque` (a queue-like structure) for efficient sliding window processing. It includes the problem description, coding pattern, solution, complexity analysis, and test cases.

## Problem Statement: LeetCode 239 - Sliding Window Maximum
**Link**: [LeetCode 239](https://leetcode.com/problems/sliding-window-maximum/)

**Description**:  
Given an array `nums` and an integer `k`, return the maximum values in each sliding window of size `k`.

**Constraints**:
- `1 <= nums.length <= 10^5`
- `-10^4 <= nums[i] <= 10^4`
- `1 <= k <= nums.length`

**Example**:
- Input: `nums = [1,3,-1,-3,5,3,6,7], k = 3`  
  Output: `[3,3,5,5,6,7]`  
  Explanation: Maximums for windows: [1,3,-1] → 3, [3,-1,-3] → 3, etc.

**Real-World Analogy**: Imagine a queue of customers in a store, where you track the tallest person in a group of k customers as the group moves forward.

## Coding Pattern: Deque for Sliding Window
- Use a deque to store indices of elements in decreasing order.  
- Remove indices outside the current window from the front.  
- Remove smaller elements from the back to maintain monotonic order.  
- The front of the deque is the maximum for each window.

## Solution
**Algorithm**:
1. Initialize a deque to store indices of potential maximums.
2. For each index i:
   - Remove indices outside the window (i - k).
   - Remove indices of smaller elements from the back.
   - Add current index to the back.
   - If window size is reached (i >= k-1), add front element’s value to result.
3. Return the result array.

**Code**:
```cpp
#include <vector>
#include <deque>
using namespace std;

class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        deque<int> dq; // Stores indices of potential max elements
        vector<int> result;
        
        // Process each element
        for (int i = 0; i < nums.size(); ++i) {
            // Remove indices outside window
            while (!dq.empty() && dq.front() <= i - k) {
                dq.pop_front();
            }
            // Remove smaller elements from back
            while (!dq.empty() && nums[dq.back()] < nums[i]) {
                dq.pop_back();
            }
            // Add current index
            dq.push_back(i);
            // Add max to result if window is complete
            if (i >= k - 1) {
                result.push_back(nums[dq.front()]);
            }
        }
        
        return result;
    }
};
```

**Time Complexity**: O(n)  
- Each element is pushed and popped at most once (O(1) operations).

**Space Complexity**: O(k)  
- Deque stores at most k indices; result array is O(n-k+1).

**Explanation**:
- Deque maintains indices of elements in decreasing order.  
- Front of deque is the maximum for the current window.  
- Remove out-of-window indices and smaller elements to keep deque monotonic.

## Test Cases
1. **Typical Case**: `nums = [1,3,-1,-3,5,3,6,7], k = 3` → Output: `[3,3,5,5,6,7]`  
2. **Single Element**: `nums = [1], k = 1` → Output: `[1]`  
3. **k = Array Size**: `nums = [1,2,3], k = 3` → Output: `[3]`  
4. **All Same**: `nums = [1,1,1], k = 2` → Output: `[1,1]`  
5. **Decreasing**: `nums = [5,4,3], k = 2` → Output: `[5,4]`  

**Test Case Implementation**:
```cpp
#include <iostream>
#include <vector>
#include <deque>
using namespace std;

vector<int> maxSlidingWindow(const vector<int>& nums, int k) {
    deque<int> dq;
    vector<int> result;
    for (int i = 0; i < nums.size(); ++i) {
        while (!dq.empty() && dq.front() <= i - k) {
            dq.pop_front();
        }
        while (!dq.empty() && nums[dq.back()] < nums[i]) {
            dq.pop_back();
        }
        dq.push_back(i);
        if (i >= k - 1) {
            result.push_back(nums[dq.front()]);
        }
    }
    return result;
}

void printVector(const vector<int>& v) {
    cout << "[";
    for (size_t i = 0; i < v.size(); ++i) {
        cout << v[i];
        if (i < v.size() - 1) cout << ",";
    }
    cout << "]" << endl;
}

int main() {
    // Test cases
    vector<int> nums1 = {1, 3, -1, -3, 5, 3, 6, 7};
    cout << "Test 1: "; printVector(maxSlidingWindow(nums1, 3)); // [3,3,5,5,6,7]
    vector<int> nums2 = {1};
    cout << "Test 2: "; printVector(maxSlidingWindow(nums2, 1)); // [1]
    vector<int> nums3 = {1, 2, 3};
    cout << "Test 3: "; printVector(maxSlidingWindow(nums3, 3)); // [3]
    vector<int> nums4 = {1, 1, 1};
    cout << "Test 4: "; printVector(maxSlidingWindow(nums4, 2)); // [1,1]
    vector<int> nums5 = {5, 4, 3};
    cout << "Test 5: "; printVector(maxSlidingWindow(nums5, 2)); // [5,4]
    
    return 0;
}
```

**Output**:
```
Test 1: [3,3,5,5,6,7]
Test 2: [1]
Test 3: [3]
Test 4: [1,1]
Test 5: [5,4]
```

## Optimization Mindset
- **Efficiency**: Deque ensures O(n) by processing each element once.  
- **Key Insight**: Monotonic deque reduces comparisons by maintaining order.  
- **Edge Cases**: Handle single elements, k equal to array size, and all identical elements.