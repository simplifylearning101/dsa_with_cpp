# Quiz: String Optimization and Common Interview Problems

30 questions: 20 on string optimization and common problems, 5 on advanced string algorithms (Week 3, Hour 3), 5 on two-pointer/sliding window (Week 3, Hour 2).

1. What is in-place string compression?  
2. How to optimize space in string problems?  
3. Write code for string compression.  
4. What is the edit distance problem?  
5. Write code for edit distance.  
6. How does regular expression matching work?  
7. Write code for regular expression matching.  
8. What is the longest valid parentheses problem?  
9. Write code for longest valid parentheses.  
10. How to optimize group anagrams?  
11. Write code for group anagrams.  
12. True/False: In-place string operations always use O(1) space.  
13. What is the first unique character problem?  
14. Write code for first unique character.  
15. How does wildcard pattern matching differ from regex?  
16. Write code for wildcard pattern matching.  
17. True/False: Edit distance uses O(m*n) time.  
18. Write code to reverse words in a string.  
19. What is the benefit of frequency arrays in string problems?  
20. Write code for longest substring with k distinct characters.  
21. (Advanced String) What is the KMP algorithm used for?  
22. (Advanced String) Write code for KMP pattern search.  
23. (Advanced String) What is Rabin-Karpâ€™s advantage?  
24. (Advanced String) Write code for Rabin-Karp.  
25. (Advanced String) What is the longest palindromic substring?  
26. (Two-Pointer/Sliding Window) How does sliding window optimize substring problems?  
27. (Two-Pointer/Sliding Window) Write code for minimum window substring.  
28. (Two-Pointer/Sliding Window) What is longest repeating character replacement?  
29. (Two-Pointer/Sliding Window) Write code for valid palindrome ignoring non-alphanumeric.  
30. (Two-Pointer/Sliding Window) How to find all anagrams in a string?

## Solutions for the Quiz

1. Compress repeated characters in-place (e.g., "aabb" to "a2b2").  
2. Use fixed-size arrays or in-place operations.  
3. 
   ```cpp
   int compress(std::string& chars) {
       int n = chars.length(), write = 0, count = 1, start = 0;
       for (int i = 1; i <= n; i++) {
           if (i < n && chars[i] == chars[i - 1]) {
               count++;
           } else {
               chars[write++] = chars[start];
               if (count > 1) {
                   std::string num = std::to_string(count);
                   for (char c : num) chars[write++] = c;
               }
               start = i;
               count = 1;
           }
       }
       return write;
   }
   ```
4. Compute minimum operations to transform one string to another.  
5. 
   ```cpp
   int minDistance(std::string word1, std::string word2) {
       int m = word1.length(), n = word2.length();
       std::vector<std::vector<int>> dp(m + 1, std::vector<int>(n + 1, 0));
       for (int i = 0; i <= m; i++) dp[i][0] = i;
       for (int j = 0; j <= n; j++) dp[0][j] = j;
       for (int i = 1; i <= m; i++) {
           for (int j = 1; j <= n; j++) {
               if (word1[i - 1] == word2[j - 1]) dp[i][j] = dp[i - 1][j - 1];
               else dp[i][j] = std::min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;
           }
       }
       return dp[m][n];
   }
   ```
6. Uses DP to match string with pattern ('.' and '*').  
7. 
   ```cpp
   bool isMatch(std::string s, std::string p) {
       int m = s.length(), n = p.length();
       std::vector<std::vector<bool>> dp(m + 1, std::vector<bool>(n + 1, false));
       dp[0][0] = true;
       for (int j = 1; j <= n; j++) {
           if (p[j - 1] == '*') dp[0][j] = dp[0][j - 2];
       }
       for (int i = 1; i <= m; i++) {
           for (int j = 1; j <= n; j++) {
               if (p[j - 1] == '*') {
                   dp[i][j] = dp[i][j - 2] || (dp[i - 1][j] && (s[i - 1] == p[j - 2] || p[j - 2] == '.'));
               } else if (p[j - 1] == '.' || s[i - 1] == p[j - 1]) {
                   dp[i][j] = dp[i - 1][j - 1];
               }
           }
       }
       return dp[m][n];
   }
   ```
8. Find longest substring of valid parentheses.  
9. 
   ```cpp
   int longestValidParentheses(std::string s) {
       std::stack<int> stack;
       stack.push(-1);
       int maxLen = 0;
       for (int i = 0; i < s.length(); i++) {
           if (s[i] == '(') {
               stack.push(i);
           } else {
               stack.pop();
               if (stack.empty()) {
                   stack.push(i);
               } else {
                   maxLen = std::max(maxLen, i - stack.top());
               }
           }
       }
       return maxLen;
   }
   ```
10. Use frequency array instead of sorting for O(n) time.  
11. 
   ```cpp
   std::vector<std::vector<std::string>> groupAnagrams(std::vector<std::string>& strs) {
       std::unordered_map<std::string, std::vector<std::string>> map;
       for (std::string s : strs) {
           std::vector<int> count(26, 0);
           for (char c : s) count[c - 'a']++;
           std::string key;
           for (int x : count) key += std::to_string(x) + "#";
           map[key].push_back(s);
       }
       std::vector<std::vector<std::string>> result;
       for (auto& pair : map) result.push_back(pair.second);
       return result;
   }
   ```
12. True, excluding temporary variables like counters.  
13. Find index of first character with frequency 1.  
14. 
   ```cpp
   int firstUniqChar(std::string s) {
       int count[26] = {0};
       for (char c : s) count[c - 'a']++;
       for (int i = 0; i < s.length(); i++) {
           if (count[s[i] - 'a'] == 1) return i;
       }
       return -1;
   }
   ```
15. Uses '?' for single character, '*' for zero or more.  
16. 
   ```cpp
   bool isMatch(std::string s, std::string p) {
       int m = s.length(), n = p.length();
       std::vector<std::vector<bool>> dp(m + 1, std::vector<bool>(n + 1, false));
       dp[0][0] = true;
       for (int j = 1; j <= n; j++) {
           if (p[j - 1] == '*') dp[0][j] = dp[0][j - 1];
       }
       for (int i = 1; i <= m; i++) {
           for (int j = 1; j <= n; j++) {
               if (p[j - 1] == '*') {
                   dp[i][j] = dp[i][j - 1] || dp[i - 1][j];
               } else if (p[j - 1] == '?' || s[i - 1] == p[j - 1]) {
                   dp[i][j] = dp[i - 1][j - 1];
               }
           }
       }
       return dp[m][n];
   }
   ```
17. True.  
18. 
   ```cpp
   std::string reverseWords(std::string s) {
       int n = s.length(), start = 0, write = 0;
       std::string result;
       for (int i = 0; i <= n; i++) {
           if (i == n || s[i] == ' ') {
               if (start < i) {
                   if (!result.empty()) result = s.substr(start, i - start) + " " + result;
                   else result = s.substr(start, i - start);
               }
               start = i + 1;
           }
       }
       return result;
   }
   ```
19. O(1) space for fixed character sets.  
20. 
   ```cpp
   int lengthOfLongestSubstringKDistinct(std::string s, int k) {
       std::unordered_map<char, int> map;
       int left = 0, maxLen = 0;
       for (int right = 0; right < s.size(); right++) {
           map[s[right]]++;
           while (map.size() > k) {
               map[s[left]]--;
               if (map[s[left]] == 0) map.erase(s[left]);
               left++;
           }
           maxLen = std::max(maxLen, right - left + 1);
       }
       return maxLen;
   }
   ```
21. Efficient substring search with O(n+m) time.  
22. 
   ```cpp
   int KMPSearch(std::string text, std::string pattern) {
       int n = text.length(), m = pattern.length();
       std::vector<int> lps(m, 0);
       int len = 0, i = 1;
       while (i < m) {
           if (pattern[i] == pattern[len]) lps[i++] = ++len;
           else if (len != 0) len = lps[len - 1];
           else lps[i++] = 0;
       }
       i = 0; int j = 0;
       while (i < n) {
           if (text[i] == pattern[j]) { i++; j++; }
           if (j == m) return i - j;
           if (i < n && text[i] != pattern[j]) {
               if (j != 0) j = lps[j - 1];
               else i++;
           }
       }
       return -1;
   }
   ```
23. Rolling hash for average-case O(n+m).  
24. 
   ```cpp
   int RabinKarp(std::string text, std::string pattern, int q) {
       int n = text.length(), m = pattern.length(), p = 0, t = 0, h = 1, d = 256;
       for (int i = 0; i < m - 1; i++) h = (h * d) % q;
       for (int i = 0; i < m; i++) {
           p = (d * p + pattern[i]) % q;
           t = (d * t + text[i]) % q;
       }
       for (int i = 0; i <= n - m; i++) {
           if (p == t) {
               bool match = true;
               for (int j = 0; j < m; j++) {
                   if (text[i + j] != pattern[j]) { match = false; break; }
               }
               if (match) return i;
           }
           if (i < n - m) {
               t = (d * (t - text[i] * h) + text[i + m]) % q;
               if (t < 0) t += q;
           }
       }
       return -1;
   }
   ```
25. Find longest substring that is a palindrome.  
26. Maintains dynamic window to reduce comparisons.  
27. 
   ```cpp
   std::string minWindow(std::string s, std::string t) {
       std::unordered_map<char, int> tMap, sMap;
       for (char c : t) tMap[c]++;
       int required = tMap.size(), formed = 0, left = 0, minLen = s.size() + 1, minLeft = 0;
       for (int right = 0; right < s.size(); right++) {
           sMap[s[right]]++;
           if (tMap.count(s[right]) && sMap[s[right]] == tMap[s[right]]) formed++;
           while (formed == required && left <= right) {
               if (right - left + 1 < minLen) {
                   minLen = right - left + 1;
                   minLeft = left;
               }
               sMap[s[left]]--;
               if (tMap.count(s[left]) && sMap[s[left]] < tMap[s[left]]) formed--;
               left++;
           }
       }
       return minLen > s.size() ? "" : s.substr(minLeft, minLen);
   }
   ```
28. Find longest substring with k replacements to same character.  
29. 
   ```cpp
   bool isValidPalindrome(std::string s) {
       int left = 0, right = s.length() - 1;
       while (left < right) {
           while (left < right && !isalnum(s[left])) left++;
           while (left < right && !isalnum(s[right])) right--;
           if (tolower(s[left++]) != tolower(s[right--])) return false;
       }
       return true;
   }
   ```
30. Use sliding window with frequency array.