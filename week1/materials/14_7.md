# Hour 14 Additional LeetCode Problems: STL Iterators Solutions

This document provides solutions for two LeetCode problems recommended in `14_2.md`: **LeetCode 283: Move Zeroes** and **LeetCode 448: Find All Numbers Disappeared in an Array**. Each solution includes a problem description, coding pattern, optimized solution with commented C++ code using STL iterators, complexity analysis, and test cases.

## Agenda
- Provide optimized solutions using STL iterators and algorithms.  
- Explain coding patterns (e.g., partitioning, filtering).  
- Analyze complexities and test cases.

## Outcome Expected
Students will:  
- Master iterator-based array manipulation.  
- Apply iterator adaptors with algorithms.  
- Handle edge cases for interviews.

---

## 1. LeetCode 283: Move Zeroes (Easy)

**Link**: [LeetCode 283](https://leetcode.com/problems/move-zeroes/)

**Description**:  
Given an integer array `nums`, move all `0`’s to the end while maintaining the relative order of non-zero elements, in-place.

**Constraints**:
- `1 <= nums.length <= 10^4`
- `-2^31 <= nums[i] <= 2^31 - 1`

**Example**:
- Input: `nums = [0,1,0,3,12]`  
  Output: `[1,3,12,0,0]`  
  Explanation: Non-zero elements stay in order, zeros moved to end.

**Coding Pattern**: Iterator with remove_if
- Use `remove_if` to shift non-zero elements forward.  
- Fill remaining positions with zeros using iterators.

**Optimized Solution**:
```cpp
#include <vector>
#include <algorithm>
using namespace std;

class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        auto new_end = remove_if(nums.begin(), nums.end(), [](int x) { return x == 0; });
        fill(new_end, nums.end(), 0);
    }
};
```

**Time Complexity**: O(n)  
- `remove_if`: O(n); `fill`: O(n).

**Space Complexity**: O(1)  
- In-place modification.

**Explanation**:  
- `remove_if` shifts non-zero elements to front.  
- `fill` sets remaining positions to 0.

**Test Cases**:
1. **Typical Case**: `nums = [0,1,0,3,12]` → Output: `[1,3,12,0,0]`  
2. **No Zeros**: `nums = [1,2,3]` → Output: `[1,2,3]`  
3. **All Zeros**: `nums = [0,0,0]` → Output: `[0,0,0]`  
4. **Single Element**: `nums = [1]` → Output: `[1]`  
5. **Leading Zeros**: `nums = [0,0,1]` → Output: `[1,0,0]`  

---

## 2. LeetCode 448: Find All Numbers Disappeared in an Array (Easy)

**Link**: [LeetCode 448](https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/)

**Description**:  
Given an array `nums` of `n` integers where `nums[i]` is in the range `[1, n]`, return an array of all integers in `[1, n]` that do not appear in `nums`.

**Constraints**:
- `n == nums.length`
- `1 <= n <= 10^5`
- `1 <= nums[i] <= n`

**Example**:
- Input: `nums = [4,3,2,7,8,2,3,1]`  
  Output: `[5,6]`  
  Explanation: Missing numbers in `[1,8]`.

**Coding Pattern**: Unordered Set with back_inserter
- Use `unordered_set` to store numbers.  
- Use iterators to collect missing numbers from `[1, n]`.

**Optimized Solution**:
```cpp
#include <vector>
#include <unordered_set>
#include <algorithm>
#include <iterator>
using namespace std;

class Solution {
public:
    vector<int> findDisappearedNumbers(vector<int>& nums) {
        unordered_set<int> s(nums.begin(), nums.end());
        vector<int> result;
        for (int i = 1; i <= nums.size(); ++i) {
            if (s.find(i) == s.end()) {
                result.push_back(i);
            }
        }
        return result;
    }
};
```

**Time Complexity**: O(n)  
- Building `unordered_set`: O(n).  
- Iterating `[1, n]`: O(n) with O(1) lookups.

**Space Complexity**: O(n)  
- `unordered_set` and output array.

**Explanation**:  
- `unordered_set` stores present numbers.  
- Iterate `[1, n]` to find missing numbers.

**Test Cases**:
1. **Typical Case**: `nums = [4,3,2,7,8,2,3,1]` → Output: `[5,6]`  
2. **All Present**: `nums = [1,2,3]` → Output: `[]`  
3. **Single Element**: `nums = [1]` → Output: `[]`  
4. **Duplicates**: `nums = [1,1]` → Output: `[2]`  
5. **Missing All**: `nums = [2,2]` → Output: `[1]`  

---

## Test Case Implementation
Below is a program to test both solutions.

```cpp
#include <iostream>
#include <vector>
#include <unordered_set>
#include <algorithm>
#include <iterator>
using namespace std;

// LeetCode 283: Move Zeroes
void moveZeroes(vector<int>& nums) {
    auto new_end = remove_if(nums.begin(), nums.end(), [](int x) { return x == 0; });
    fill(new_end, nums.end(), 0);
}

// LeetCode 448: Find All Numbers Disappeared in an Array
vector<int> findDisappearedNumbers(vector<int>& nums) {
    unordered_set<int> s(nums.begin(), nums.end());
    vector<int> result;
    for (int i = 1; i <= nums.size(); ++i) {
        if (s.find(i) == s.end()) {
            result.push_back(i);
        }
    }
    return result;
}

void printVector(const vector<int>& v) {
    cout << "[";
    for (int i = 0; i < v.size(); ++i) {
        cout << v[i];
        if (i < v.size() - 1) cout << ",";
    }
    cout << "]";
}

int main() {
    // Test LeetCode 283
    cout << "LeetCode 283: Move Zeroes\n";
    vector<int> nums1 = {0, 1, 0, 3, 12};
    moveZeroes(nums1);
    cout << "Test 1: "; printVector(nums1);  // [1,3,12,0,0]
    cout << endl;
    
    // Test LeetCode 448
    cout << "\nLeetCode 448: Find All Numbers Disappeared in an Array\n";
    vector<int> nums2 = {4, 3, 2, 7, 8, 2, 3, 1};
    vector<int> result = findDisappearedNumbers(nums2);
    cout << "Test 1: "; printVector(result);  // [5,6]
    cout << endl;
    
    return 0;
}
```

**Output**:
```
LeetCode 283: Move Zeroes
Test 1: [1,3,12,0,0]

LeetCode 448: Find All Numbers Disappeared in an Array
Test 1: [5,6]
```

## Key Takeaways
- **Move Zeroes**: `remove_if` with iterators simplifies in-place partitioning.  
- **Disappeared Numbers**: Iterators with `unordered_set` streamline lookup and filtering.