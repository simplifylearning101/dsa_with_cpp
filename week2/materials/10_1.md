# Project Agenda: Text Processing Tool

## Outcome Expected:
By completing this project, students will apply array and string algorithms (from Weeks 2 and 3) to build a practical text processing tool. Students will demonstrate mastery of KMP pattern matching, anagram grouping, palindromic substring detection, and in-place string compression, while handling file I/O and edge cases.

## Project Tasks
1. **Pattern Matching**: Find all occurrences of a given pattern in the text using KMP or Rabin-Karp.
2. **Anagram Grouping**: Group a list of words from the text that are anagrams.
3. **Longest Palindromic Substring**: Identify the longest palindrome in the text.
4. **String Compression**: Compress the output string of matched patterns.
5. **File I/O**: Read input from a file and write results to another file.

## Detailed Explanation

### 1. Pattern Matching (Week 3, Hour 3)
- Use KMP algorithm for efficient substring search (O(n+m)).
- Input: Text from file, user-provided pattern.
- Output: List of starting indices where the pattern appears.

**Logic**:
- Compute the Longest Prefix Suffix (LPS) array for the pattern.
- Use LPS to skip redundant comparisons during search.

### 2. Anagram Grouping (Week 2, Hour 4)
- Group words from the input file that are anagrams.
- Use frequency counting to create a key for each word.

**Logic**:
- For each word, create a frequency array (26 for lowercase letters).
- Use the frequency array as a key in a hash map to group anagrams.

### 3. Longest Palindromic Substring (Week 3, Hour 3)
- Find the longest substring in the text that is a palindrome.
- Use expand-around-center technique for O(n^2) time.

**Logic**:
- For each index, expand around it (odd length) and between indices (even length).
- Track the longest palindrome found.

### 4. String Compression (Week 3, Hour 4)
- Compress repeated characters in the output (e.g., "aaabb" to "a3b2").
- Perform in-place compression to optimize space.

**Logic**:
- Track consecutive character counts and write compressed result in-place.

### 5. File I/O
- Read text and words from `input.txt`.
- Write results (pattern matches, anagram groups, palindrome, compressed output) to `output.txt`.

## Points to Remember
- **Edge Cases**: Handle empty files, no pattern matches, or single-character inputs.
- **Complexity**: Aim for O(n+m) for pattern matching, O(n*k) for anagram grouping, O(n^2) for palindrome, O(n) for compression.
- **Interview Tips**: Explain trade-offs (e.g., KMP vs. Rabin-Karp, space vs. time).
- **Common Errors**: Incorrect LPS computation, mishandling file I/O, or ignoring case sensitivity.
- Use `std::string` for strings and `std::vector` for dynamic arrays.