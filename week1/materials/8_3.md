# Hour 8 Homework Solutions: Map Practice Problems

Below are solutions to the 12 homework problems, each with fully commented C++ code to help students understand STL `map` and `unordered_map` implementation. The solutions are beginner-friendly and emphasize interview-relevant techniques.

1. **Problem**: Create a map, insert 5 key-value pairs, and print its size.  
```cpp
#include <iostream>
#include <map>
#include <string>
using namespace std;

int main() {
    map<string, int> m;
    
    // Insert 5 key-value pairs
    m["a"] = 1; m["b"] = 2; m["c"] = 3; m["a"] = 4; m["d"] = 5;
    
    // Print size
    cout << "Size: " << m.size() << endl; // Output: 4
    
    return 0;
}
```

2. **Problem**: Print keys and values of a map in sorted order.  
```cpp
#include <iostream>
#include <map>
#include <string>
using namespace std;

int main() {
    map<string, int> m;
    m["c"] = 3; m["a"] = 1; m["b"] = 2;
    
    // Print in sorted order
    cout << "Map: ";
    for (const auto& pair : m) {
        cout << pair.first << ":" << pair.second << " "; // Output: a:1 b:2 c:3
    }
    cout << endl;
    
    return 0;
}
```

3. **Problem**: Check if a key exists in a map using `find`.  
```cpp
#include <iostream>
#include <map>
#include <string>
using namespace std;

int main() {
    map<string, int> m;
    m["a"] = 1; m["b"] = 2;
    
    // Find key
    string key = "b";
    auto it = m.find(key);
    cout << "Find " << key << ": " << (it != m.end() ? "Found, value: " + to_string(it->second) : "Not found") << endl; // Output: Found, value: 2
    
    return 0;
}
```

4. **Problem**: Create an unordered map and insert 5 key-value pairs.  
```cpp
#include <iostream>
#include <unordered_map>
#include <string>
using namespace std;

int main() {
    unordered_map<string, int> um;
    
    // Insert 5 key-value pairs
    um["a"] = 1; um["b"] = 2; um["c"] = 3; um["a"] = 4; um["d"] = 5;
    
    // Print size
    cout << "Size: " << um.size() << endl; // Output: 4
    
    return 0;
}
```

5. **Problem**: Simulate a word frequency counter using a map.  
```cpp
#include <iostream>
#include <map>
#include <string>
#include <vector>
using namespace std;

void printWordFrequency(const vector<string>& words) {
    map<string, int> freq;
    for (const string& word : words) {
        freq[word]++;
    }
    for (const auto& pair : freq) {
        cout << pair.first << ":" << pair.second << " "; // Output: apple:2 banana:1
    }
    cout << endl;
}

int main() {
    vector<string> words = {"apple", "banana", "apple"};
    printWordFrequency(words);
    return 0;
}
```

6. **Problem**: Find the sum of two numbers in an array that equals a target.  
```cpp
#include <iostream>
#include <unordered_map>
#include <vector>
using namespace std;

vector<int> twoSum(const vector<int>& nums, int target) {
    unordered_map<int, int> num_map; // number -> index
    for (int i = 0; i < nums.size(); ++i) {
        int complement = target - nums[i];
        if (num_map.count(complement)) {
            return {num_map[complement], i};
        }
        num_map[nums[i]] = i;
    }
    return {};
}

int main() {
    vector<int> nums = {2, 7, 11, 15};
    int target = 9;
    vector<int> result = twoSum(nums, target);
    cout << "[" << result[0] << "," << result[1] << "]" << endl; // Output: [0,1]
    return 0;
}
```

7. **Problem**: Detect if an array has two numbers within k indices with difference t.  
```cpp
#include <iostream>
#include <unordered_map>
#include <vector>
using namespace std;

bool containsNearbyAlmostDuplicate(const vector<int>& nums, int k, int t) {
    unordered_map<long, long> buckets;
    long w = (long)t + 1; // Bucket size
    for (int i = 0; i < nums.size(); ++i) {
        long num = nums[i];
        long bucket = num / w;
        if (buckets.count(bucket)) return true;
        if (buckets.count(bucket - 1) && abs(num - buckets[bucket - 1]) < w) return true;
        if (buckets.count(bucket + 1) && abs(num - buckets[bucket + 1]) < w) return true;
        buckets[bucket] = num;
        if (i >= k) {
            buckets.erase((long)nums[i - k] / w);
        }
    }
    return false;
}

int main() {
    vector<int> nums = {1, 5, 3};
    int k = 2, t = 2;
    cout << "Contains nearby almost duplicate: " << (containsNearbyAlmostDuplicate(nums, k, t) ? "True" : "False") << endl; // Output: True
    return 0;
}
```

8. **Problem**: Check if two strings are isomorphic.  
```cpp
#include <iostream>
#include <unordered_map>
#include <string>
using namespace std;

bool isIsomorphic(const string& s, const string& t) {
    unordered_map<char, char> s_to_t;
    unordered_map<char, char> t_to_s;
    for (int i = 0; i < s.size(); ++i) {
        if (!s_to_t.count(s[i]) && !t_to_s.count(t[i])) {
            s_to_t[s[i]] = t[i];
            t_to_s[t[i]] = s[i];
        } else if (s_to_t[s[i]] != t[i] || t_to_s[t[i]] != s[i]) {
            return false;
        }
    }
    return true;
}

int main() {
    string s = "egg", t = "add";
    cout << "Is isomorphic: " << (isIsomorphic(s, t) ? "True" : "False") << endl; // Output: True
    return 0;
}
```

9. **Problem**: Simulate a phone book with name-to-number mappings.  
```cpp
#include <iostream>
#include <unordered_map>
#include <string>
using namespace std;

void printPhoneBook(const unordered_map<string, string>& phone_book) {
    cout << "Phone book: ";
    for (const auto& pair : phone_book) {
        cout << pair.first << ":" << pair.second << " ";
    }
    cout << endl;
}

int main() {
    unordered_map<string, string> phone_book;
    phone_book["Alice"] = "1234567890";
    phone_book["Bob"] = "9876543210";
    printPhoneBook(phone_book); // Output: e.g., Alice:1234567890 Bob:9876543210
    return 0;
}
```

10. **Problem**: Find the most frequent element in an array.  
```cpp
#include <iostream>
#include <unordered_map>
#include <vector>
using namespace std;

int mostFrequent(const vector<int>& nums) {
    unordered_map<int, int> freq;
    int max_count = 0, result = nums[0];
    for (int num : nums) {
        freq[num]++;
        if (freq[num] > max_count) {
            max_count = freq[num];
            result = num;
        }
    }
    return result;
}

int main() {
    vector<int> nums = {1, 2, 2, 3};
    cout << "Most frequent: " << mostFrequent(nums) << endl; // Output: 2
    return 0;
}
```

11. **Problem**: Check if a string follows a pattern.  
```cpp
#include <iostream>
#include <unordered_map>
#include <string>
using namespace std;

bool wordPattern(const string& pattern, const string& s) {
    vector<string> words;
    string word;
    for (char c : s) {
        if (c == ' ') {
            words.push_back(word);
            word = "";
        } else {
            word += c;
        }
    }
    words.push_back(word);
    
    if (pattern.size() != words.size()) return false;
    
    unordered_map<char, string> p_to_w;
    unordered_map<string, char> w_to_p;
    for (int i = 0; i < pattern.size(); ++i) {
        if (!p_to_w.count(pattern[i]) && !w_to_p.count(words[i])) {
            p_to_w[pattern[i]] = words[i];
            w_to_p[words[i]] = pattern[i];
        } else if (p_to_w[pattern[i]] != words[i] || w_to_p[words[i]] != pattern[i]) {
            return false;
        }
    }
    return true;
}

int main() {
    string pattern = "abba", s = "dog cat cat dog";
    cout << "Follows pattern: " << (wordPattern(pattern, s) ? "True" : "False") << endl; // Output: True
    return 0;
}
```

12. **Problem**: Find subarray sum equals k.  
```cpp
#include <iostream>
#include <unordered_map>
#include <vector>
using namespace std;

int subarraySum(const vector<int>& nums, int k) {
    unordered_map<int, int> sum_freq;
    sum_freq[0] = 1; // Handle case where subarray starts from index 0
    int sum = 0, count = 0;
    for (int num : nums) {
        sum += num;
        if (sum_freq.count(sum - k)) {
            count += sum_freq[sum - k];
        }
        sum_freq[sum]++;
    }
    return count;
}

int main() {
    vector<int> nums = {1, 1, 1};
    int k = 2;
    cout << "Subarray sum equals " << k << ": " << subarraySum(nums, k) << endl; // Output: 2
    return 0;
}
```