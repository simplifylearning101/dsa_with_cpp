# Hour 4 LeetCode Problem: Valid Parentheses

This document illustrates **LeetCode 20: Valid Parentheses**, an easy problem that leverages STL `stack` for parentheses matching. It includes the problem description, coding pattern, solution, complexity analysis, and test cases.

## Problem Statement: LeetCode 20 - Valid Parentheses
**Link**: [LeetCode 20](https://leetcode.com/problems/valid-parentheses/)

**Description**:  
Given a string `s` containing only '(', ')', '{', '}', '[', ']', determine if the string is valid. A string is valid if:
- Open brackets are closed by the same type of brackets.
- Open brackets are closed in the correct order.

**Constraints**:
- `1 <= s.length <= 10^4`
- `s` consists of parentheses only '()[]{}'.

**Example**:
- Input: `s = "({[]})"`  
  Output: `true`  
  Explanation: All brackets are properly matched.

**Real-World Analogy**: Imagine stacking books (opening brackets) and removing them in reverse order (closing brackets) to ensure they match.

## Coding Pattern: Stack for Matching
- Use a stack to store opening brackets.
- For each closing bracket, check if it matches the top opening bracket.
- Ensure the stack is empty at the end for validity.

## Solution
**Algorithm**:
1. Initialize an empty stack for opening brackets.
2. For each character:
   - If it’s an opening bracket, push it onto the stack.
   - If it’s a closing bracket, check if it matches the stack’s top; pop if matched, else return false.
3. Return true if the stack is empty.

**Code**:
```cpp
#include <string>
#include <stack>
using namespace std;

class Solution {
public:
    bool isValid(string s) {
        stack<char> parentheses;
        
        // Process each character
        for (char c : s) {
            if (c == '(' || c == '{' || c == '[') {
                parentheses.push(c); // Push opening bracket
            } else {
                // Check if stack is empty or mismatch
                if (parentheses.empty()) return false;
                char top = parentheses.top();
                if ((c == ')' && top != '(') || 
                    (c == '}' && top != '{') || 
                    (c == ']' && top != '[')) return false;
                parentheses.pop(); // Matched, remove top
            }
        }
        
        // Valid if stack is empty
        return parentheses.empty();
    }
};
```

**Time Complexity**: O(n)  
- Single pass through the string, with O(1) stack operations.

**Space Complexity**: O(n)  
- Stack may store up to n/2 opening brackets.

**Explanation**:
- Stack stores opening brackets in order.
- Closing brackets must match the most recent opening bracket.
- Empty stack at the end indicates all brackets were matched.

## Test Cases
1. **Typical Case**: `s = "({[]})"` → Output: `true`  
2. **Unmatched Closing**: `s = "())"` → Output: `false`  
3. **Unmatched Opening**: `s = "(()"` → Output: `false`  
4. **Empty String**: `s = ""` → Output: `true`  
5. **Single Pair**: `s = "()"` → Output: `true`  
6. **Mixed Brackets**: `s = "{[]}"` → Output: `true`  

**Test Case Implementation**:
```cpp
#include <iostream>
#include <stack>
#include <string>
using namespace std;

bool isValid(string s) {
    stack<char> parentheses;
    for (char c : s) {
        if (c == '(' || c == '{' || c == '[') {
            parentheses.push(c);
        } else {
            if (parentheses.empty()) return false;
            char top = parentheses.top();
            if ((c == ')' && top != '(') || 
                (c == '}' && top != '{') || 
                (c == ']' && top != '[')) return false;
            parentheses.pop();
        }
    }
    return parentheses.empty();
}

int main() {
    // Test cases
    cout << "Test 1: " << (isValid("({[]})") ? "true" : "false") << endl; // true
    cout << "Test 2: " << (isValid("())") ? "true" : "false") << endl; // false
    cout << "Test 3: " << (isValid("(()") ? "true" : "false") << endl; // false
    cout << "Test 4: " << (isValid("") ? "true" : "false") << endl; // true
    cout << "Test 5: " << (isValid("()") ? "true" : "false") << endl; // true
    cout << "Test 6: " << (isValid("{[]}") ? "true" : "false") << endl; // true
    
    return 0;
}
```

**Output**:
```
Test 1: true
Test 2: false
Test 3: false
Test 4: true
Test 5: true
Test 6: true
```

## Optimization Mindset
- **Efficiency**: Stack operations are O(1), making the solution optimal.  
- **Key Insight**: Use stack to track order of opening brackets.  
- **Edge Cases**: Handle empty strings, unmatched brackets, and invalid sequences.