# Deep Dive into C++ STL Maps

This document is an advanced exploration of STL `map` and `unordered_map` for students aiming to master map-based algorithms for coding interviews. It covers internals, advanced applications, and interview questions with detailed answers, building on Hours 1–7 (vectors, arrays/deques, strings, stacks, queues, priority queues, sets).

## Agenda
- Deep dive into map and unordered map internals, operations, and optimizations.
- Illustrate complex scenarios with commented programs.
- Prepare for interviews with challenging questions and answers.

## Outcome Expected
Students will:
- Understand `map` (red-black tree) and `unordered_map` (hash table) internals.  
- Master advanced applications (e.g., frequency counting, two-sum, pattern matching).  
- Optimize performance and handle edge cases.  
- Answer complex map-related interview questions confidently.

## Topics Covered
1. **Map Internals**  
   - Red-black tree structure and balancing.  
   - Performance characteristics (O(log n)).  
   - Real-world analogy: Map as a sorted inventory system.  
2. **Unordered Map Internals**  
   - Hash table structure and collision handling.  
   - Performance characteristics (O(1) average).  
   - Real-world analogy: Unordered map as a quick lookup database.  
3. **Advanced Applications**  
   - Frequency counting and two-sum problems.  
   - Pattern matching and sliding window problems.  
4. **Optimization and Pitfalls**  
   - Choosing `map` vs. `unordered_map`.  
   - Handling hash collisions and large datasets.  

## Detailed Explanation

### 1. Map Internals
STL `map` is implemented as a red-black tree, a self-balancing binary search tree that ensures O(log n) operations for insertion, deletion, and search. Think of it as a sorted inventory system where items (keys) are sorted, and each item has a quantity (value).

- **Structure**: Nodes with parent-child links, balanced for O(log n).  
- **Performance**: O(log n) for `insert`, `erase`, `find`.  
- **Limitations**: No random access; sorted keys required.

**Example Program**: Map with custom comparator.

```cpp
#include <iostream>
#include <map>
#include <string>
using namespace std;

struct Compare {
    bool operator()(const string& a, const string& b) const {
        return a.length() < b.length(); // Sort by string length
    }
};

int main() {
    map<string, int, Compare> m;
    
    // Insert key-value pairs
    m["cat"] = 3; m["elephant"] = 8; m["dog"] = 3;
    
    // Print in order of key length
    cout << "Map: ";
    for (const auto& pair : m) {
        cout << pair.first << ":" << pair.second << " "; // Output: cat:3 dog:3 elephant:8
    }
    cout << endl;
    
    return 0;
}
```

**Explanation**:  
- Custom comparator sorts keys by string length.  
- Red-black tree maintains order based on comparator.

### 2. Unordered Map Internals
STL `unordered_map` uses a hash table, mapping keys to buckets via a hash function. Think of it as a quick lookup database where keys map to values instantly, but order is not preserved.

- **Structure**: Buckets with linked lists for collision resolution.  
- **Performance**: O(1) average for `insert`, `erase`, `find`; O(n) worst case for collisions.  
- **Limitations**: No sorting; potential hash collision issues.

**Example Program**: Unordered map with custom hash.

```cpp
#include <iostream>
#include <unordered_map>
#include <string>
using namespace std;

struct CustomHash {
    size_t operator()(const string& s) const {
        return s.length(); // Simple hash based on length
    }
};

int main() {
    unordered_map<string, int, CustomHash> um;
    um["cat"] = 3; um["dog"] = 3; um["bird"] = 4;
    
    // Print elements (order not guaranteed)
    cout << "Unordered map: ";
    for (const auto& pair : um) {
        cout << pair.first << ":" << pair.second << " "; // Output: e.g., cat:3 dog:3 bird:4
    }
    cout << endl;
    
    // Check membership
    cout << "Is cat present? " << (um.count("cat") ? "Yes" : "No") << endl; // Output: Yes
    
    return 0;
}
```

**Explanation**:  
- Custom hash function uses string length (simplified for demonstration).  
- O(1) average time for operations, but poor hash functions cause collisions.

### 3. Advanced Applications
Maps are ideal for problems involving key-value mappings, such as frequency counting, two-sum, or pattern matching.

**Example Program**: Two-sum problem.

```cpp
#include <iostream>
#include <unordered_map>
#include <vector>
using namespace std;

vector<int> twoSum(const vector<int>& nums, int target) {
    unordered_map<int, int> num_map;
    for (int i = 0; i < nums.size(); ++i) {
        int complement = target - nums[i];
        if (num_map.count(complement)) {
            return {num_map[complement], i};
        }
        num_map[nums[i]] = i;
    }
    return {};
}

int main() {
    vector<int> nums = {2, 7, 11, 15};
    int target = 9;
    vector<int> result = twoSum(nums, target);
    cout << "[" << result[0] << "," << result[1] << "]" << endl; // Output: [0,1]
    return 0;
}
```

**Explanation**:  
- `unordered_map` stores number-to-index mappings.  
- Check for complement (target - num) in O(1) average time.  
- Returns indices of two numbers summing to target.

### 4. Optimization and Pitfalls
- **Optimization**: Use `unordered_map` for faster lookups when order isn’t needed.  
- **Pitfalls**: Avoid `operator[]` for read-only access (it inserts); check `find` results against `end()`.

**Example Program**: Safe map operations.

```cpp
#include <iostream>
#include <map>
#include <string>
using namespace std;

int main() {
    map<string, int> m;
    m["apple"] = 5; m["banana"] = 3;
    
    // Safe find
    string key = "orange";
    auto it = m.find(key);
    cout << key << ": " << (it != m.end() ? to_string(it->second) : "Not found") << endl; // Output: Not found
    
    // Safe access
    if (m.count("apple")) {
        cout << "Apple value: " << m["apple"] << endl; // Output: 5
    }
    
    return 0;
}
```

**Explanation**:  
- Use `find` instead of `operator[]` to avoid unintended insertions.  
- Check `count` before accessing to ensure key exists.

## Interview Questions and Answers
Below are 15 advanced interview questions on maps.

1. **Question**: What is the primary difference between `map` and `unordered_map`?  
   **Answer**: `map` is sorted (O(log n), red-black tree); `unordered_map` is unordered (O(1) average, hash table).  
   **Interviewer’s Intention**: Tests container understanding.

2. **Question**: Why use a red-black tree for `map`?**  
   **Answer**: Ensures O(log n) operations and sorted keys.  
   **Interviewer’s Intention**: Checks internal structure knowledge.

3. **Question**: What is the time complexity of `unordered_map::find`?**  
   **Answer**: O(1) average, O(n) worst case for collisions.  
   **Interviewer’s Intention**: Tests performance awareness.

4. **Question**: Write a program to solve two-sum.  
   **Answer**: (See above example.)  
   **Interviewer’s Intention**: Tests map application.

5. **Question**: How do you handle duplicate keys in a map?**  
   **Answer**: Duplicate keys overwrite existing values.  
   **Interviewer’s Intention**: Tests uniqueness property.

6. **Question**: What is a hash collision in `unordered_map`?**  
   **Answer**: When multiple keys map to the same bucket, degrading performance.  
   **Interviewer’s Intention**: Tests hash table knowledge.

7. **Question**: Write a program to count word frequencies.  
   **Answer**: (See homework solution 5.)  
   **Interviewer’s Intention**: Tests frequency counting.

8. **Question**: Why can’t you index into a map?**  
   **Answer**: No random access; keys are stored in a tree or hash table.  
   **Interviewer’s Intention**: Tests container limitations.

9. **Question**: When should you use `map` over `vector`?**  
   **Answer**: Use `map` for key-value mappings; `vector` for indexed access.  
   **Interviewer’s Intention**: Tests container selection.

10. **Question**: Write a program to simulate a phone book.  
    **Answer**: (See homework solution 9.)  
    **Interviewer’s Intention**: Tests practical application.

11. **Question**: What is the space complexity of `map`?**  
    **Answer**: O(n) for n key-value pairs.  
    **Interviewer’s Intention**: Tests complexity awareness.

12. **Question**: Write a program to check if strings are isomorphic.  
    **Answer**: (See homework solution 8.)  
    **Interviewer’s Intention**: Tests pattern matching.

13. **Question**: Why use `unordered_map` for two-sum problems?**  
    **Answer**: O(1) average lookups make it efficient.  
    **Interviewer’s Intention**: Tests optimization knowledge.

14. **Question**: How do you create a map with a custom comparator?**  
    **Answer**: Define a comparator struct (see custom comparator example).  
    **Interviewer’s Intention**: Tests advanced usage.

15. **Question**: Write a program to find subarray sum equals k.  
    **Answer**: (See homework solution 12.)  
    **Interviewer’s Intention**: Tests cumulative sum techniques.

## Practice Recommendations
- Solve LeetCode problems like **Two Sum** and **Subarray Sum Equals K**.  
- Experiment with custom comparators and hash functions.  
- Practice safe map operations with `find` and `count` checks.