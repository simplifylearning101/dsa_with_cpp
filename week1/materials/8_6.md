# Hour 8 LeetCode Problem: Two Sum

This document illustrates **LeetCode 1: Two Sum**, an easy problem that leverages STL `unordered_map` for efficient pair-finding. It includes the problem description, coding pattern, solution, complexity analysis, and test cases.

## Problem Statement: LeetCode 1 - Two Sum
**Link**: [LeetCode 1](https://leetcode.com/problems/two-sum/)

**Description**:  
Given an array of integers `nums` and an integer `target`, return indices of two numbers such that they add up to `target`. You may assume that each input has exactly one solution, and you may not use the same element twice.

**Constraints**:
- `2 <= nums.length <= 10^4`
- `-10^9 <= nums[i] <= 10^9`
- `-10^9 <= target <= 10^9`
- Only one valid answer exists.

**Example**:
- Input: `nums = [2,7,11,15], target = 9`  
  Output: `[0,1]`  
  Explanation: `nums[0] + nums[1] = 2 + 7 = 9`.

**Real-World Analogy**: Imagine finding two items in a store whose prices sum to a budget.

## Coding Pattern: Unordered Map for Pair Finding
- Use `unordered_map` to store number-to-index mappings.  
- For each number, check if its complement (target - number) exists in the map.  
- If found, return the indices; otherwise, add the number and its index to the map.

## Solution
**Algorithm**:
1. Initialize an empty `unordered_map` to store number-to-index pairs.
2. Iterate through the array, computing complement = target - nums[i].
3. If complement exists in the map, return its index and current index.
4. Otherwise, add nums[i] and its index to the map.
5. Return empty vector if no solution (not needed per constraints).

**Code**:
```cpp
#include <unordered_map>
#include <vector>
using namespace std;

class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> num_map; // number -> index
        for (int i = 0; i < nums.size(); ++i) {
            int complement = target - nums[i];
            if (num_map.count(complement)) {
                return {num_map[complement], i};
            }
            num_map[nums[i]] = i;
        }
        return {}; // Not reached due to problem constraints
    }
};
```

**Time Complexity**: O(n)  
- Each insertion and lookup in `unordered_map` is O(1) average; n elements processed.

**Space Complexity**: O(n)  
- Stores up to n number-to-index pairs.

**Explanation**:  
- `unordered_map` provides O(1) average lookups for complements.  
- Store index to return position rather than value.  
- Single pass ensures efficiency.

## Test Cases
1. **Typical Case**: `nums = [2,7,11,15], target = 9` → Output: `[0,1]`  
2. **Negative Numbers**: `nums = [-3,4,3,90], target = 0` → Output: `[0,2]`  
3. **Small Array**: `nums = [3,3], target = 6` → Output: `[0,1]`  
4. **Large Numbers**: `nums = [1000000000,2], target = 1000000002` → Output: `[0,1]`  
5. **Different Order**: `nums = [3,2,4], target = 6` → Output: `[1,2]`  

**Test Case Implementation**:
```cpp
#include <iostream>
#include <unordered_map>
#include <vector>
using namespace std;

vector<int> twoSum(vector<int>& nums, int target) {
    unordered_map<int, int> num_map;
    for (int i = 0; i < nums.size(); ++i) {
        int complement = target - nums[i];
        if (num_map.count(complement)) {
            return {num_map[complement], i};
        }
        num_map[nums[i]] = i;
    }
    return {};
}

// Helper to print vector
void printVector(const vector<int>& v) {
    cout << "[" << v[0] << "," << v[1] << "]" << endl;
}

int main() {
    // Test cases
    vector<int> nums1 = {2, 7, 11, 15};
    int target1 = 9;
    cout << "Test 1: "; printVector(twoSum(nums1, target1)); // [0,1]
    
    vector<int> nums2 = {-3, 4, 3, 90};
    int target2 = 0;
    cout << "Test 2: "; printVector(twoSum(nums2, target2)); // [0,2]
    
    vector<int> nums3 = {3, 3};
    int target3 = 6;
    cout << "Test 3: "; printVector(twoSum(nums3, target3)); // [0,1]
    
    vector<int> nums4 = {1000000000, 2};
    int target4 = 1000000002;
    cout << "Test 4: "; printVector(twoSum(nums4, target4)); // [0,1]
    
    vector<int> nums5 = {3, 2, 4};
    int target5 = 6;
    cout << "Test 5: "; printVector(twoSum(nums5, target5)); // [1,2]
    
    return 0;
}
```

**Output**:
```
Test 1: [0,1]
Test 2: [0,2]
Test 3: [0,1]
Test 4: [0,1]
Test 5: [1,2]
```

## Optimization Mindset
- **Efficiency**: `unordered_map` ensures O(1) average lookups.  
- **Key Insight**: Single pass with complement check avoids nested loops.  
- **Edge Cases**: Handle negative numbers, large numbers, and small arrays.