# Hour 1 Additional LeetCode Problems: Vector-Based Solutions

This document provides detailed solutions for four LeetCode problems recommended to reinforce C++ STL vector usage: **LeetCode 27: Remove Element**, **LeetCode 80: Remove Duplicates from Sorted Array II**, **LeetCode 283: Move Zeroes**, and **LeetCode 189: Rotate Array**. Each problem includes a description, coding pattern, optimized solution with comprehensive comments, time and space complexity analysis, and test cases covering typical and edge cases. These solutions build on the foundational vector knowledge from Hour 1 and the Two Pointers pattern introduced in `1_6.md`, preparing students for coding interviews.

## Agenda
- Provide optimized solutions for four LeetCode problems using STL vectors.
- Explain the coding pattern (primarily Two Pointers) and optimization techniques.
- Analyze time and space complexities.
- Include test cases to ensure robustness across various scenarios.

## Outcome Expected
By studying these solutions, students will:
- Master in-place vector manipulations using the Two Pointers pattern.
- Understand how to optimize solutions to meet O(1) space constraints.
- Be able to handle edge cases and analyze complexities for interview problems.
- Gain confidence in solving array-based LeetCode problems with vectors.

---

## 1. LeetCode 27: Remove Element (Easy)

**Link**: [LeetCode 27](https://leetcode.com/problems/remove-element/)

**Description**:  
Given an integer array `nums` and an integer `val`, remove all occurrences of `val` in-place and return the new length of the array. The relative order of elements may be changed. Use O(1) extra space.

**Constraints**:
- `0 <= nums.length <= 100`
- `0 <= nums[i] <= 50`
- `0 <= val <= 100`

**Example**:
- Input: `nums = [3,2,2,3], val = 3`  
  Output: `2`, `nums = [2,2,_,_]`  
  Explanation: Return `2`, with the first two elements being non-`val` values.

**Coding Pattern**: Two Pointers  
- Use a `write` pointer to place non-`val` elements and a `read` pointer to scan the array.
- Since order doesn’t matter, swap `val` elements to the end or overwrite with non-`val` elements.

**Optimized Solution**:
```cpp
#include <vector>
using namespace std;

class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        // Initialize write pointer for next non-val element
        int write = 0;

        // Iterate through array with read pointer
        for (int read = 0; read < nums.size(); ++read) {
            // If current element is not val, place it at write position
            if (nums[read] != val) {
                nums[write] = nums[read];
                write++;
            }
        }

        // Return new length (number of non-val elements)
        return write;
    }
};
```

**Time Complexity**: O(n)  
- Single pass through the array with `read` pointer.
- Each operation (comparison, assignment) is O(1).
- Total: O(n), where n is the array length.

**Space Complexity**: O(1)  
- Uses only two pointers, no extra data structures.

**Explanation**:
- `write` tracks the position for the next non-`val` element.
- `read` scans the array; if `nums[read] != val`, copy it to `nums[write]` and increment `write`.
- Elements after `write` are ignored, satisfying the in-place requirement.

**Test Cases**:
1. **Typical Case**: `nums = [3,2,2,3], val = 3` → Output: `2`, `nums = [2,2,_,_]`  
2. **No Matches**: `nums = [1,2,3,4], val = 5` → Output: `4`, `nums = [1,2,3,4]`  
3. **All Matches**: `nums = [3,3,3], val = 3` → Output: `0`, `nums = [_,_,_]`  
4. **Empty Array**: `nums = [], val = 1` → Output: `0`, `nums = []`  
5. **Single Element (Match)**: `nums = [3], val = 3` → Output: `0`, `nums = [_]`  
6. **Single Element (No Match)**: `nums = [3], val = 4` → Output: `1`, `nums = [3]`

---

## 2. LeetCode 80: Remove Duplicates from Sorted Array II (Medium)

**Link**: [LeetCode 80](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/)

**Description**:  
Given a sorted integer array `nums`, remove duplicates in-place such that each element appears at most twice. Return the new length of the array. Use O(1) extra space.

**Constraints**:
- `1 <= nums.length <= 3 * 10^4`
- `-10^4 <= nums[i] <= 10^4`
- Array is sorted in non-decreasing order.

**Example**:
- Input: `nums = [1,1,1,2,2,3]`  
  Output: `5`, `nums = [1,1,2,2,3,_]`  
  Explanation: Return `5`, with each element appearing at most twice.

**Coding Pattern**: Two Pointers  
- Use a `write` pointer for the position of the next valid element and a `read` pointer to scan.
- Track the count of each element to allow up to two occurrences.
- Leverage sorted property to compare adjacent elements.

**Optimized Solution**:
```cpp
#include <vector>
using namespace std;

class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        // Handle arrays with <= 2 elements (no duplicates to remove)
        if (nums.size() <= 2) return nums.size();

        // Initialize write pointer for next valid element
        int write = 2;

        // Iterate with read pointer starting from third element
        for (int read = 2; read < nums.size(); ++read) {
            // Include nums[read] if it differs from element two positions before
            if (nums[read] != nums[write - 2]) {
                nums[write] = nums[read];
                write++;
            }
        }

        // Return new length
        return write;
    }
};
```

**Time Complexity**: O(n)  
- Single pass through the array starting from index 2.
- Each operation is O(1).
- Total: O(n).

**Space Complexity**: O(1)  
- Uses only two pointers.

**Explanation**:
- If array size ≤ 2, return size (no duplicates to remove).
- `write` starts at 2 since the first two elements are always valid.
- For each `read`, check if `nums[read] != nums[write-2]` to allow up to two duplicates.
- If valid, place `nums[read]` at `write` and increment `write`.

**Test Cases**:
1. **Typical Case**: `nums = [1,1,1,2,2,3]` → Output: `5`, `nums = [1,1,2,2,3,_]`  
2. **No Duplicates**: `nums = [1,2,3]` → Output: `3`, `nums = [1,2,3]`  
3. **All Same**: `nums = [1,1,1,1]` → Output: `2`, `nums = [1,1,_,_]`  
4. **Two Elements**: `nums = [1,1]` → Output: `2`, `nums = [1,1]`  
5. **Single Element**: `nums = [1]` → Output: `1`, `nums = [1]`  
6. **Long Sequence**: `nums = [0,0,0,0,1,1,1,2]` → Output: `5`, `nums = [0,0,1,1,2,_,_,_]`  

---

## 3. LeetCode 283: Move Zeroes (Easy)

**Link**: [LeetCode 283](https://leetcode.com/problems/move-zeroes/)

**Description**:  
Given an integer array `nums`, move all `0`’s to the end in-place while maintaining the relative order of non-zero elements. Use O(1) extra space.

**Constraints**:
- `1 <= nums.length <= 10^4`
- `-2^31 <= nums[i] <= 2^31 - 1`

**Example**:
- Input: `nums = [0,1,0,3,12]`  
  Output: `nums = [1,3,12,0,0]`  
  Explanation: Non-zero elements are moved to the front, zeros to the end.

**Coding Pattern**: Two Pointers  
- Use a `write` pointer to place non-zero elements and a `read` pointer to scan.
- After placing non-zeros, fill the remaining positions with zeros.

**Optimized Solution**:
```cpp
#include <vector>
using namespace std;

class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        // Initialize write pointer for next non-zero element
        int write = 0;

        // Move all non-zero elements to the front
        for (int read = 0; read < nums.size(); ++read) {
            if (nums[read] != 0) {
                nums[write] = nums[read];
                write++;
            }
        }

        // Fill remaining positions with zeros
        while (write < nums.size()) {
            nums[write] = 0;
            write++;
        }
    }
};
```

**Time Complexity**: O(n)  
- First loop: Single pass to move non-zeros.
- Second loop: Fills remaining positions (at most n).
- Total: O(n).

**Space Complexity**: O(1)  
- Uses only one pointer.

**Explanation**:
- `write` tracks the position for the next non-zero element.
- `read` scans the array; if `nums[read]` is non-zero, copy it to `nums[write]` and increment `write`.
- After moving non-zeros, fill from `write` to the end with zeros.

**Test Cases**:
1. **Typical Case**: `nums = [0,1,0,3,12]` → Output: `[1,3,12,0,0]`  
2. **No Zeros**: `nums = [1,2,3]` → Output: `[1,2,3]`  
3. **All Zeros**: `nums = [0,0,0]` → Output: `[0,0,0]`  
4. **Single Element (Zero)**: `nums = [0]` → Output: `[0]`  
5. **Single Element (Non-Zero)**: `nums = [1]` → Output: `[1]`  
6. **Mixed**: `nums = [0,0,1,0,2,0]` → Output: `[1,2,0,0,0,0]`

---

## 4. LeetCode 189: Rotate Array (Medium)

**Link**: [LeetCode 189](https://leetcode.com/problems/rotate-array/)

**Description**:  
Given an integer array `nums`, rotate the array to the right by `k` steps in-place, where `k` is non-negative. Use O(1) extra space.

**Constraints**:
- `1 <= nums.length <= 10^5`
- `-2^31 <= nums[i] <= 2^31 - 1`
- `0 <= k <= 10^5`

**Example**:
- Input: `nums = [1,2,3,4,5,6,7], k = 3`  
  Output: `nums = [5,6,7,1,2,3,4]`  
  Explanation: Rotate right by 3 steps.

**Coding Pattern**: Reversal Algorithm  
- Normalize `k` to avoid unnecessary rotations (`k = k % n`).
- Reverse the entire array, then reverse the first `k` elements, then reverse the remaining `n-k` elements.
- This achieves rotation in-place with O(1) space.

**Optimized Solution**:
```cpp
#include <vector>
using namespace std;

class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        // Normalize k to avoid unnecessary rotations
        k = k % nums.size();
        if (k == 0) return; // No rotation needed

        // Helper function to reverse a range [start, end]
        auto reverse = [&](int start, int end) {
            while (start < end) {
                swap(nums[start], nums[end]);
                start++;
                end--;
            }
        };

        // Reverse entire array
        reverse(0, nums.size() - 1);
        // Reverse first k elements
        reverse(0, k - 1);
        // Reverse remaining elements
        reverse(k, nums.size() - 1);
    }
};
```

**Time Complexity**: O(n)  
- Three reversals: entire array (O(n)), first `k` elements (O(k)), remaining `n-k` elements (O(n-k)).
- Total: O(n).

**Space Complexity**: O(1)  
- Uses only a few variables for indices and swapping.

**Explanation**:
- Normalizing `k` (`k % n`) handles cases where `k > n`.
- Reversing the entire array flips the order (e.g., `[1,2,3,4,5,6,7]` → `[7,6,5,4,3,2,1]`).
- Reversing the first `k` elements and the rest corrects the rotation (e.g., for `k=3`: `[7,6,5,4,3,2,1]` → `[5,6,7,4,3,2,1]` → `[5,6,7,1,2,3,4]`).

**Test Cases**:
1. **Typical Case**: `nums = [1,2,3,4,5,6,7], k = 3` → Output: `[5,6,7,1,2,3,4]`  
2. **k = 0**: `nums = [1,2,3], k = 0` → Output: `[1,2,3]`  
3. **k > n**: `nums = [1,2,3], k = 4` → Output: `[3,1,2]`  
4. **Single Element**: `nums = [1], k = 1` → Output: `[1]`  
5. **All Same**: `nums = [1,1,1], k = 2` → Output: `[1,1,1]`  
6. **Large k**: `nums = [1,2,3,4], k = 10` → Output: `[3,4,1,2]`  

---

## Test Case Implementation
Below is a program to test all four solutions with the provided test cases.

```cpp
#include <iostream>
#include <vector>
using namespace std;

// LeetCode 27: Remove Element
int removeElement(vector<int>& nums, int val) {
    int write = 0;
    for (int read = 0; read < nums.size(); ++read) {
        if (nums[read] != val) {
            nums[write] = nums[read];
            write++;
        }
    }
    return write;
}

// LeetCode 80: Remove Duplicates from Sorted Array II
int removeDuplicatesII(vector<int>& nums) {
    if (nums.size() <= 2) return nums.size();
    int write = 2;
    for (int read = 2; read < nums.size(); ++read) {
        if (nums[read] != nums[write - 2]) {
            nums[write] = nums[read];
            write++;
        }
    }
    return write;
}

// LeetCode 283: Move Zeroes
void moveZeroes(vector<int>& nums) {
    int write = 0;
    for (int read = 0; read < nums.size(); ++read) {
        if (nums[read] != 0) {
            nums[write] = nums[read];
            write++;
        }
    }
    while (write < nums.size()) {
        nums[write] = 0;
        write++;
    }
}

// LeetCode 189: Rotate Array
void rotate(vector<int>& nums, int k) {
    k = k % nums.size();
    if (k == 0) return;
    auto reverse = [&](int start, int end) {
        while (start < end) {
            swap(nums[start], nums[end]);
            start++;
            end--;
        }
    };
    reverse(0, nums.size() - 1);
    reverse(0, k - 1);
    reverse(k, nums.size() - 1);
}

// Helper function to print array up to length k
void printArray(const vector<int>& nums, int k) {
    cout << "[";
    for (int i = 0; i < k; ++i) {
        cout << nums[i];
        if (i < k - 1) cout << ",";
    }
    cout << "]" << endl;
}

int main() {
    // Test LeetCode 27
    cout << "LeetCode 27: Remove Element\n";
    vector<int> nums1 = {3,2,2,3};
    int val1 = 3;
    int k1 = removeElement(nums1, val1);
    cout << "Test 1: "; printArray(nums1, k1); // [2,2]
    vector<int> nums2 = {1,2,3,4};
    int val2 = 5;
    int k2 = removeElement(nums2, val2);
    cout << "Test 2: "; printArray(nums2, k2); // [1,2,3,4]

    // Test LeetCode 80
    cout << "\nLeetCode 80: Remove Duplicates II\n";
    vector<int> nums3 = {1,1,1,2,2,3};
    int k3 = removeDuplicatesII(nums3);
    cout << "Test 1: "; printArray(nums3, k3); // [1,1,2,2,3]
    vector<int> nums4 = {1,2,3};
    int k4 = removeDuplicatesII(nums4);
    cout << "Test 2: "; printArray(nums4, k4); // [1,2,3]

    // Test LeetCode 283
    cout << "\nLeetCode 283: Move Zeroes\n";
    vector<int> nums5 = {0,1,0,3,12};
    moveZeroes(nums5);
    cout << "Test 1: "; printArray(nums5, nums5.size()); // [1,3,12,0,0]
    vector<int> nums6 = {1,2,3};
    moveZeroes(nums6);
    cout << "Test 2: "; printArray(nums6, nums6.size()); // [1,2,3]

    // Test LeetCode 189
    cout << "\nLeetCode 189: Rotate Array\n";
    vector<int> nums7 = {1,2,3,4,5,6,7};
    int k7 = 3;
    rotate(nums7, k7);
    cout << "Test 1: "; printArray(nums7, nums7.size()); // [5,6,7,1,2,3,4]
    vector<int> nums8 = {1,2,3};
    int k8 = 4;
    rotate(nums8, k8);
    cout << "Test 2: "; printArray(nums8, nums8.size()); // [3,1,2]

    return 0;
}
```

**Output**:
```
LeetCode 27: Remove Element
Test 1: [2,2]
Test 2: [1,2,3,4]

LeetCode 80: Remove Duplicates II
Test 1: [1,1,2,2,3]
Test 2: [1,2,3]

LeetCode 283: Move Zeroes
Test 1: [1,3,12,0,0]
Test 2: [1,2,3]

LeetCode 189: Rotate Array
Test 1: [5,6,7,1,2,3,4]
Test 2: [3,1,2]
```

## Key Takeaways
- **Two Pointers Pattern**: Dominant in in-place array problems, used in LeetCode 27, 80, and 283 for efficient manipulation.
- **Reversal Algorithm**: Unique to LeetCode 189, showing how creative in-place solutions can achieve O(1) space.
- **Edge Cases**: Always test empty arrays, single elements, and extreme inputs (e.g., large `k` in LeetCode 189).
- **Vector Usage**: Leverage vector indexing and in-place operations to meet O(1) space requirements.
- **Optimization**: Start with understanding the problem constraints, then design solutions to minimize space and time.

These solutions reinforce vector manipulation skills, prepare students for interview scenarios, and deepen understanding of the Two Pointers pattern and in-place algorithms.