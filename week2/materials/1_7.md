# Solutions for Leetcode Problems

For each problem, explain with examples, then provide brute-force and optimized solutions with pros/cons.

1. **Contains Duplicate**  
   **Explanation:** Traverse array to check repeats. Example: [1,2,3,1] -> 1 repeats.  
   **Brute-Force:** Nested loops compare each pair. Code:
   ```cpp
   bool containsDuplicate(vector<int>& nums) {
       for(int i=0; i<nums.size(); i++) {
           for(int j=i+1; j<nums.size(); j++) {
               if(nums[i] == nums[j]) return true;
           }
       }
       return false;
   }
   ```
   Pros: Simple. Cons: O(n^2) time, O(1) spaceâ€”slow for large n.  
   **Optimized:** Use unordered_set. Code:
   ```cpp
   #include <unordered_set>
   bool containsDuplicate(vector<int>& nums) {
       unordered_set<int> s;
       for(int num : nums) {
           if(s.count(num)) return true;
           s.insert(num);
       }
       return false;
   }
   ```
   Pros: O(n) time, average case. Cons: O(n) space.

2. **Best Time to Buy and Sell Stock**  
   **Explanation:** Find min buy, max sell after. Example: [7,1,5,3,6,4] min=1, max after=6, profit=5.  
   **Brute-Force:** Check all pairs. Code:
   ```cpp
   int maxProfit(vector<int>& prices) {
       int maxP = 0;
       for(int i=0; i<prices.size(); i++) {
           for(int j=i+1; j<prices.size(); j++) {
               maxP = max(maxP, prices[j] - prices[i]);
           }
       }
       return maxP;
   }
   ```
   Pros: Correct. Cons: O(n^2) time.  
   **Optimized:** One pass, track min. Code:
   ```cpp
   int maxProfit(vector<int>& prices) {
       int minPrice = INT_MAX, maxP = 0;
       for(int p : prices) {
           minPrice = min(minPrice, p);
           maxP = max(maxP, p - minPrice);
       }
       return maxP;
   }
   ```
   Pros: O(n) time, O(1) space. Cons: None major.

3. **Maximum Subarray**  
   **Explanation:** Find contiguous max sum. Example: Use Kadane's.  
   **Brute-Force:** All subarrays sum. Code:
   ```cpp
   int maxSubArray(vector<int>& nums) {
       int maxS = INT_MIN;
       for(int i=0; i<nums.size(); i++) {
           int sum = 0;
           for(int j=i; j<nums.size(); j++) {
               sum += nums[j];
               maxS = max(maxS, sum);
           }
       }
       return maxS;
   }
   ```
   Pros: Works. Cons: O(n^2) time.  
   **Optimized:** Kadane's algorithm. Code:
   ```cpp
   int maxSubArray(vector<int>& nums) {
       int maxS = nums[0], curr = nums[0];
       for(int i=1; i<nums.size(); i++) {
           curr = max(nums[i], curr + nums[i]);
           maxS = max(maxS, curr);
       }
       return maxS;
   }
   ```
   Pros: O(n) time, O(1) space. Cons: Handles negatives carefully.

4. **Rotate Array**  
   **Explanation:** Shift elements. Example: k=3 on [1,2,3,4,5,6,7].  
   **Brute-Force:** Shift one by one. Code:
   ```cpp
   void rotate(vector<int>& nums, int k) {
       k %= nums.size();
       for(int i=0; i<k; i++) {
           int last = nums.back();
           for(int j=nums.size()-1; j>0; j--) nums[j] = nums[j-1];
           nums[0] = last;
       }
   }
   ```
   Pros: In-place. Cons: O(n*k) time.  
   **Optimized:** Reverse method. Code:
   ```cpp
   #include <algorithm>
   void rotate(vector<int>& nums, int k) {
       k %= nums.size();
       reverse(nums.begin(), nums.end());
       reverse(nums.begin(), nums.begin()+k);
       reverse(nums.begin()+k, nums.end());
   }
   ```
   Pros: O(n) time, O(1) space. Cons: Trickier to understand.

5. **Remove Duplicates from Sorted Array**  
   **Explanation:** In-place unique. Assumes sorted.  
   **Brute-Force:** Use set. Code:
   ```cpp
   #include <set>
   int removeDuplicates(vector<int>& nums) {
       set<int> s(nums.begin(), nums.end());
       nums.assign(s.begin(), s.end());
       return nums.size();
   }
   ```
   Pros: Simple. Cons: O(n log n) for set, not in-place strictly.  
   **Optimized:** Two pointers. Code:
   ```cpp
   int removeDuplicates(vector<int>& nums) {
       if(nums.empty()) return 0;
       int i = 0;
       for(int j=1; j<nums.size(); j++) {
           if(nums[j] != nums[i]) nums[++i] = nums[j];
       }
       return i+1;
   }
   ```
   Pros: O(n) time, O(1) space, in-place. Cons: Assumes sorted.

6. **Move Zeroes**  
   **Explanation:** Shift non-zeros left.  
   **Brute-Force:** Extra array. Code:
   ```cpp
   void moveZeroes(vector<int>& nums) {
       vector<int> temp;
       for(int num : nums) if(num != 0) temp.push_back(num);
       for(int num : nums) if(num == 0) temp.push_back(0);
       nums = temp;
   }
   ```
   Pros: Easy. Cons: O(n) space.  
   **Optimized:** Two pointers swap. Code:
   ```cpp
   void moveZeroes(vector<int>& nums) {
       int i = 0;
       for(int j=0; j<nums.size(); j++) {
           if(nums[j] != 0) swap(nums[i++], nums[j]);
       }
   }
   ```
   Pros: O(n) time, O(1) space. Cons: None.

7. **Majority Element**  
   **Explanation:** Find >n/2 element.  
   **Brute-Force:** Count each. Code:
   ```cpp
   int majorityElement(vector<int>& nums) {
       for(int num : nums) {
           int count = 0;
           for(int n : nums) if(n == num) count++;
           if(count > nums.size()/2) return num;
       }
       return -1;
   }
   ```
   Pros: Works. Cons: O(n^2) time.  
   **Optimized:** Boyer-Moore Voting. Code:
   ```cpp
   int majorityElement(vector<int>& nums) {
       int count = 0, candidate = 0;
       for(int num : nums) {
           if(count == 0) candidate = num;
           count += (num == candidate) ? 1 : -1;
       }
       return candidate;
   }
   ```
   Pros: O(n) time, O(1) space. Cons: Assumes majority exists.

8. **Plus One**  
   **Explanation:** Increment digit array.  
   **Brute-Force:** Convert to int, add, back to array. (But for large, avoid.)  
   Code: (Simplified, but may overflow)  
   **Optimized:** In-place carry. Code:
   ```cpp
   vector<int> plusOne(vector<int>& digits) {
       for(int i=digits.size()-1; i>=0; i--) {
           if(digits[i] < 9) {
               digits[i]++;
               return digits;
           }
           digits[i] = 0;
       }
       digits.insert(digits.begin(), 1);
       return digits;
   }
   ```
   Pros: O(n) time, handles large. Cons: Modifies input.

9. **Single Number**  
   **Explanation:** Find unique using XOR.  
   **Brute-Force:** Map counts. Code:
   ```cpp
   #include <unordered_map>
   int singleNumber(vector<int>& nums) {
       unordered_map<int, int> m;
       for(int num : nums) m[num]++;
       for(auto& p : m) if(p.second == 1) return p.first;
       return -1;
   }
   ```
   Pros: General. Cons: O(n) space.  
   **Optimized:** XOR all. Code:
   ```cpp
   int singleNumber(vector<int>& nums) {
       int res = 0;
       for(int num : nums) res ^= num;
       return res;
   }
   ```
   Pros: O(n) time, O(1) space. Cons: Specific to pairs.

10. **Intersection of Two Arrays II**  
    **Explanation:** Common elements with multiplicity.  
    **Brute-Force:** Nested loops. Code:
    ```cpp
    vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {
        vector<int> res;
        for(int n1 : nums1) {
            for(auto it=nums2.begin(); it!=nums2.end(); ++it) {
                if(n1 == *it) {
                    res.push_back(n1);
                    nums2.erase(it);
                    break;
                }
            }
        }
        return res;
    }
    ```
    Pros: Works. Cons: O(n*m) time.  
    **Optimized:** Sort and two pointers. Code:
    ```cpp
    #include <algorithm>
    vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {
        sort(nums1.begin(), nums1.end());
        sort(nums2.begin(), nums2.end());
        vector<int> res;
        int i=0, j=0;
        while(i < nums1.size() && j < nums2.size()) {
            if(nums1[i] == nums2[j]) {
                res.push_back(nums1[i]);
                i++; j++;
            } else if(nums1[i] < nums2[j]) i++;
            else j++;
        }
        return res;
    }
    ```
    Pros: O(n log n) time (sort), O(1) extra space. Cons: Sorts input.