# Hour 7 Additional LeetCode Problems: Set Solutions

This document provides detailed solutions for four LeetCode problems recommended in `7_2.md`: **LeetCode 350: Intersection of Two Arrays II**, **LeetCode 217: Contains Duplicate**, **LeetCode 136: Single Number**, and **LeetCode 645: Set Mismatch**. Each solution includes a problem description, coding pattern, optimized solution with commented C++ code using STL `set` or `unordered_set`, time and space complexity analysis, and test cases covering typical and edge cases.

## Agenda
- Provide optimized solutions for four set-based LeetCode problems.
- Explain coding patterns (e.g., intersection, duplicate detection, unique elements).
- Analyze time and space complexities.
- Include test cases to ensure robustness.

## Outcome Expected
Students will:
- Master set usage for intersection, duplicate detection, and unique element problems.  
- Apply set-based techniques for array processing.  
- Handle edge cases and optimize for interviews.  
- Gain confidence in solving set-based LeetCode problems.

---

## 1. LeetCode 350: Intersection of Two Arrays II (Easy)

**Link**: [LeetCode 350](https://leetcode.com/problems/intersection-of-two-arrays-ii/)

**Description**:  
Given two integer arrays `nums1` and `nums2`, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays, and you may return the result in any order.

**Constraints**:
- `1 <= nums1.length, nums2.length <= 10^4`
- `-10^9 <= nums1[i], nums2[i] <= 10^9`

**Example**:
- Input: `nums1 = [1,2,2,1], nums2 = [2,2]`  
  Output: `[2,2]`  
  Explanation: 2 appears twice in both arrays.

**Coding Pattern**: Unordered Set with Frequency  
- Use `unordered_set` or hash map to track frequencies.  
- Iterate through smaller array, checking frequencies.  
- Decrement frequency to handle multiple occurrences.

**Optimized Solution**:
```cpp
#include <unordered_map>
#include <vector>
using namespace std;

class Solution {
public:
    vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {
        unordered_map<int, int> freq;
        vector<int> result;
        
        // Count frequencies in nums1
        for (int num : nums1) {
            freq[num]++;
        }
        
        // Check nums2 against freq
        for (int num : nums2) {
            if (freq[num] > 0) {
                result.push_back(num);
                freq[num]--;
            }
        }
        
        return result;
    }
};
```

**Time Complexity**: O(n + m)  
- Building frequency map: O(n).  
- Processing nums2: O(m).  

**Space Complexity**: O(n)  
- Stores frequency map and result.

**Explanation**:  
- `unordered_map` tracks frequency of elements in `nums1`.  
- For each element in `nums2`, include it in result if frequency > 0, then decrement.  
- Handles multiple occurrences efficiently.

**Test Cases**:
1. **Typical Case**: `nums1 = [1,2,2,1], nums2 = [2,2]` → Output: `[2,2]`  
2. **No Intersection**: `nums1 = [1,2], nums2 = [3,4]` → Output: `[]`  
3. **Single Element**: `nums1 = [1], nums2 = [1]` → Output: `[1]`  
4. **Empty Array**: `nums1 = [], nums2 = [1]` → Output: `[]`  
5. **Multiple Occurrences**: `nums1 = [1,1,1], nums2 = [1,1]` → Output: `[1,1]`  

---

## 2. LeetCode 217: Contains Duplicate (Easy)

**Link**: [LeetCode 217](https://leetcode.com/problems/contains-duplicate/)

**Description**:  
Given an integer array `nums`, return `true` if any value appears at least twice, and `false` if every element is distinct.

**Constraints**:
- `1 <= nums.length <= 10^5`
- `-10^9 <= nums[i] <= 10^9`

**Example**:
- Input: `nums = [1,2,3,1]`  
  Output: `true`  
  Explanation: 1 appears twice.

**Coding Pattern**: Unordered Set for Duplicate Detection  
- Use `unordered_set` to track seen elements.  
- If an element is already in the set, return `true`.  
- If all elements are processed without duplicates, return `false`.

**Optimized Solution**:
```cpp
#include <unordered_set>
#include <vector>
using namespace std;

class Solution {
public:
    bool containsDuplicate(vector<int>& nums) {
        unordered_set<int> us;
        for (int num : nums) {
            if (us.count(num)) {
                return true;
            }
            us.insert(num);
        }
        return false;
    }
};
```

**Time Complexity**: O(n)  
- Each insert and lookup is O(1) average; n elements processed.

**Space Complexity**: O(n)  
- Stores up to n elements in `unordered_set`.

**Explanation**:  
- `unordered_set` provides O(1) average lookups.  
- If `count` returns 1, a duplicate is found.  
- Early exit on first duplicate improves efficiency.

**Test Cases**:
1. **Typical Case**: `nums = [1,2,3,1]` → Output: `true`  
2. **No Duplicates**: `nums = [1,2,3]` → Output: `false`  
3. **Single Element**: `nums = [1]` → Output: `false`  
4. **Empty Array**: `nums = []` → Output: `false`  
5. **Negative Numbers**: `nums = [-1,-1]` → Output: `true`  

---

## 3. LeetCode 136: Single Number (Easy)

**Link**: [LeetCode 136](https://leetcode.com/problems/single-number/)

**Description**:  
Given a non-empty array of integers `nums`, every element appears twice except for one. Find that single one.

**Constraints**:
- `1 <= nums.length <= 3 * 10^4`
- `-3 * 10^4 <= nums[i] <= 3 * 10^4`
- Each element appears twice except one.

**Example**:
- Input: `nums = [2,2,1]`  
  Output: `1`  
  Explanation: 1 appears once; others appear twice.

**Coding Pattern**: Unordered Set for Unique Element  
- Use `unordered_set` to track elements.  
- Insert element if not present; erase if present.  
- The remaining element is the single number.

**Optimized Solution**:
```cpp
#include <unordered_set>
#include <vector>
using namespace std;

class Solution {
public:
    int singleNumber(vector<int>& nums) {
        unordered_set<int> us;
        for (int num : nums) {
            if (us.count(num)) {
                us.erase(num);
            } else {
                us.insert(num);
            }
        }
        return *us.begin();
    }
};
```

**Alternative (Bit Manipulation)**:
```cpp
#include <vector>
using namespace std;

class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int result = 0;
        for (int num : nums) {
            result ^= num;
        }
        return result;
    }
};
```

**Time Complexity**:  
- Set: O(n) for n elements, O(1) average insert/erase.  
- Bit Manipulation: O(n), no extra space.  

**Space Complexity**:  
- Set: O(n) for `unordered_set`.  
- Bit Manipulation: O(1).  

**Explanation**:  
- Set: Elements appearing twice are erased, leaving the single number.  
- Bit Manipulation: XOR cancels pairs, leaving the single number.  
- Bit manipulation is more space-efficient but included for completeness; set-based solution aligns with Hour 7 focus.

**Test Cases**:
1. **Typical Case**: `nums = [2,2,1]` → Output: `1`  
2. **Single Element**: `nums = [1]` → Output: `1`  
3. **Multiple Pairs**: `nums = [4,1,2,1,2]` → Output: `4`  
4. **Negative Numbers**: `nums = [-1,-1,2]` → Output: `2`  
5. **Large Numbers**: `nums = [30000,30000,1]` → Output: `1`  

---

## 4. LeetCode 645: Set Mismatch (Easy)

**Link**: [LeetCode 645](https://leetcode.com/problems/set-mismatch/)

**Description**:  
You have an array `nums` of length `n` containing numbers from 1 to n, where one number is duplicated and one is missing. Return the duplicated and missing numbers.

**Constraints**:
- `2 <= n <= 10^4`
- `1 <= nums[i] <= 10^4`

**Example**:
- Input: `nums = [1,2,2,4]`  
  Output: `[2,3]`  
  Explanation: 2 is duplicated; 3 is missing.

**Coding Pattern**: Unordered Set for Mismatch Detection  
- Use `unordered_set` to track seen numbers.  
- Identify duplicate when inserting.  
- Compare set with expected range [1,n] to find missing number.

**Optimized Solution**:
```cpp
#include <unordered_set>
#include <vector>
using namespace std;

class Solution {
public:
    vector<int> findErrorNums(vector<int>& nums) {
        unordered_set<int> us;
        int duplicate = -1;
        
        // Find duplicate
        for (int num : nums) {
            if (us.count(num)) {
                duplicate = num;
            }
            us.insert(num);
        }
        
        // Find missing
        int n = nums.size();
        int missing = -1;
        for (int i = 1; i <= n; ++i) {
            if (!us.count(i)) {
                missing = i;
                break;
            }
        }
        
        return {duplicate, missing};
    }
};
```

**Time Complexity**: O(n)  
- Building set and finding duplicate: O(n).  
- Finding missing number: O(n).

**Space Complexity**: O(n)  
- Stores up to n elements in `unordered_set`.

**Explanation**:  
- `unordered_set` detects duplicate when `count` returns 1.  
- Iterate from 1 to n to find missing number not in set.  
- Returns both duplicate and missing numbers.

**Test Cases**:
1. **Typical Case**: `nums = [1,2,2,4]` → Output: `[2,3]`  
2. **Small Array**: `nums = [1,1]` → Output: `[1,2]`  
3. **Large Array**: `nums = [1,2,3,3]` → Output: `[3,4]`  
4. **Different Order**: `nums = [2,2,3,4]` → Output: `[2,1]`  
5. **End Missing**: `nums = [1,2,2,3]` → Output: `[2,4]`  

---

## Test Case Implementation
Below is a program to test all four solutions with the provided test cases.

```cpp
#include <iostream>
#include <unordered_set>
#include <unordered_map>
#include <vector>
using namespace std;

// LeetCode 350: Intersection of Two Arrays II
vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {
    unordered_map<int, int> freq;
    vector<int> result;
    for (int num : nums1) {
        freq[num]++;
    }
    for (int num : nums2) {
        if (freq[num] > 0) {
            result.push_back(num);
            freq[num]--;
        }
    }
    return result;
}

// LeetCode 217: Contains Duplicate
bool containsDuplicate(vector<int>& nums) {
    unordered_set<int> us;
    for (int num : nums) {
        if (us.count(num)) {
            return true;
        }
        us.insert(num);
    }
    return false;
}

// LeetCode 136: Single Number
int singleNumber(vector<int>& nums) {
    unordered_set<int> us;
    for (int num : nums) {
        if (us.count(num)) {
            us.erase(num);
        } else {
            us.insert(num);
        }
    }
    return *us.begin();
}

// LeetCode 645: Set Mismatch
vector<int> findErrorNums(vector<int>& nums) {
    unordered_set<int> us;
    int duplicate = -1;
    for (int num : nums) {
        if (us.count(num)) {
            duplicate = num;
        }
        us.insert(num);
    }
    int missing = -1;
    for (int i = 1; i <= nums.size(); ++i) {
        if (!us.count(i)) {
            missing = i;
            break;
        }
    }
    return {duplicate, missing};
}

// Helper to print vector
void printVector(const vector<int>& v) {
    cout << "[";
    for (size_t i = 0; i < v.size(); ++i) {
        cout << v[i];
        if (i < v.size() - 1) cout << ",";
    }
    cout << "]" << endl;
}

int main() {
    // Test LeetCode 350
    cout << "LeetCode 350: Intersection of Two Arrays II\n";
    vector<int> nums1_350 = {1, 2, 2, 1};
    vector<int> nums2_350 = {2, 2};
    cout << "Test 1: "; printVector(intersect(nums1_350, nums2_350)); // [2,2]

    // Test LeetCode 217
    cout << "\nLeetCode 217: Contains Duplicate\n";
    vector<int> nums_217 = {1, 2, 3, 1};
    cout << "Test 1: " << (containsDuplicate(nums_217) ? "true" : "false") << endl; // true

    // Test LeetCode 136
    cout << "\nLeetCode 136: Single Number\n";
    vector<int> nums_136 = {2, 2, 1};
    cout << "Test 1: " << singleNumber(nums_136) << endl; // 1

    // Test LeetCode 645
    cout << "\nLeetCode 645: Set Mismatch\n";
    vector<int> nums_645 = {1, 2, 2, 4};
    cout << "Test 1: "; printVector(findErrorNums(nums_645)); // [2,3]

    return 0;
}
```

**Output**:
```
LeetCode 350: Intersection of Two Arrays II
Test 1: [2,2]

LeetCode 217: Contains Duplicate
Test 1: true

LeetCode 136: Single Number
Test 1: 1

LeetCode 645: Set Mismatch
Test 1: [2,3]
```

## Key Takeaways
- **Intersection**: LeetCode 350 uses frequency counting to handle multiple occurrences.  
- **Duplicate Detection**: LeetCode 217 leverages `unordered_set` for O(1) lookups.  
- **Unique Element**: LeetCode 136 uses set to find single number (bit manipulation is alternative).  
- **Mismatch**: LeetCode 645 combines set with range checking for duplicates and missing numbers.  
- **Optimization**: Prefer `unordered_set` for speed; handle edge cases like empty arrays.  

These solutions reinforce set manipulation skills, preparing students for interview scenarios with set-based algorithms.