# Hour 9 LeetCode Problem: Top K Frequent Elements

This document illustrates **LeetCode 347: Top K Frequent Elements**, a medium problem that leverages STL `multiset` for frequency sorting. It includes the problem description, coding pattern, solution, complexity analysis, and test cases.

## Problem Statement: LeetCode 347 - Top K Frequent Elements
**Link**: [LeetCode 347](https://leetcode.com/problems/top-k-frequent-elements/)

**Description**:  
Given an integer array `nums` and an integer `k`, return the `k` most frequent elements. You may return the answer in any order.

**Constraints**:
- `1 <= nums.length <= 10^5`
- `-10^4 <= nums[i] <= 10^4`
- `k` is in the range `[1, the number of unique elements in the array]`
- It is guaranteed that the answer is unique.

**Example**:
- Input: `nums = [1,1,1,2,2,3], k = 2`  
  Output: `[1,2]`  
  Explanation: `1` appears 3 times, `2` appears 2 times, `3` appears once.

**Real-World Analogy**: Imagine finding the top k most popular products in a store.

## Coding Pattern: Multiset for Frequency Sorting
- Use `unordered_map` to count frequencies.  
- Use `multiset` with a custom comparator to sort by frequency (descending).  
- Extract top k elements from the multiset.

## Solution
**Algorithm**:
1. Count frequencies of each number using `unordered_map`.
2. Insert frequency-number pairs into a `multiset` sorted by frequency (descending).
3. Extract the first k elements’ numbers from the multiset.

**Code**:
```cpp
#include <set>
#include <unordered_map>
#include <vector>
using namespace std;

class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int, int> freq;
        for (int num : nums) {
            freq[num]++;
        }
        multiset<pair<int, int>, greater<pair<int, int>>> ms; // {freq, num}
        for (const auto& pair : freq) {
            ms.insert({pair.second, pair.first});
        }
        vector<int> result;
        auto it = ms.begin();
        for (int i = 0; i < k; ++i) {
            result.push_back(it->second);
            ++it;
        }
        return result;
    }
};
```

**Time Complexity**: O(n log n)  
- Frequency counting: O(n).  
- Inserting into `multiset`: O(n log n).  
- Extracting k elements: O(k log n).

**Space Complexity**: O(n)  
- Stores frequency map and multiset.

**Explanation**:  
- `unordered_map` counts frequencies in O(n).  
- `multiset` sorts pairs by frequency in descending order.  
- Extract k elements by iterating over the sorted multiset.

## Test Cases
1. **Typical Case**: `nums = [1,1,1,2,2,3], k = 2` → Output: `[1,2]`  
2. **Single Element**: `nums = [1], k = 1` → Output: `[1]`  
3. **All Same**: `nums = [1,1,1], k = 1` → Output: `[1]`  
4. **Negative Numbers**: `nums = [-1,-1,2,2,2], k = 2` → Output: `[-1,2]`  
5. **Large K**: `nums = [1,2,3], k = 3` → Output: `[1,2,3]`  

**Test Case Implementation**:
```cpp
#include <iostream>
#include <set>
#include <unordered_map>
#include <vector>
using namespace std;

vector<int> topKFrequent(vector<int>& nums, int k) {
    unordered_map<int, int> freq;
    for (int num : nums) {
        freq[num]++;
    }
    multiset<pair<int, int>, greater<pair<int, int>>> ms;
    for (const auto& pair : freq) {
        ms.insert({pair.second, pair.first});
    }
    vector<int> result;
    auto it = ms.begin();
    for (int i = 0; i < k; ++i) {
        result.push_back(it->second);
        ++it;
    }
    return result;
}

// Helper to print vector
void printVector(const vector<int>& v) {
    cout << "[";
    for (int i = 0; i < v.size(); ++i) {
        cout << v[i] << (i < v.size() - 1 ? "," : "");
    }
    cout << "]" << endl;
}

int main() {
    // Test cases
    vector<int> nums1 = {1, 1, 1, 2, 2, 3};
    int k1 = 2;
    cout << "Test 1: "; printVector(topKFrequent(nums1, k1)); // [1,2]
    
    vector<int> nums2 = {1};
    int k2 = 1;
    cout << "Test 2: "; printVector(topKFrequent(nums2, k2)); // [1]
    
    vector<int> nums3 = {1, 1, 1};
    int k3 = 1;
    cout << "Test 3: "; printVector(topKFrequent(nums3, k3)); // [1]
    
    vector<int> nums4 = {-1, -1, 2, 2, 2};
    int k4 = 2;
    cout << "Test 4: "; printVector(topKFrequent(nums4, k4)); // [-1,2]
    
    vector<int> nums5 = {1, 2, 3};
    int k5 = 3;
    cout << "Test 5: "; printVector(topKFrequent(nums5, k5)); // [1,2,3]
    
    return 0;
}
```

**Output**:
```
Test 1: [1,2]
Test 2: [1]
Test 3: [1]
Test 4: [-1,2]
Test 5: [1,2,3]
```

## Optimization Mindset
- **Efficiency**: `multiset` sorts frequencies automatically.  
- **Key Insight**: Use `greater` comparator for descending order.  
- **Edge Cases**: Handle single elements, all same elements, and negative numbers.