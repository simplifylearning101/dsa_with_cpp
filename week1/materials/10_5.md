# Deep Dive into C++ STL Unordered Sets and Multisets

This document is an advanced exploration of STL `unordered_set` and `unordered_multiset` for students aiming to master these containers for coding interviews. It covers internals, advanced applications, and interview questions with detailed answers, building on Hours 1–9.

## Agenda
- Deep dive into `unordered_set` and `unordered_multiset` internals, operations, and optimizations.
- Illustrate complex scenarios with commented programs.
- Prepare for interviews with challenging questions and answers.

## Outcome Expected
Students will:
- Understand `unordered_set` and `unordered_multiset` internals (hash table).  
- Master advanced applications (e.g., duplicate detection, intersections).  
- Optimize performance and handle edge cases (e.g., hash collisions).  
- Answer complex interview questions confidently.

## Topics Covered
1. **Unordered Set Internals**  
   - Hash table structure and hashing mechanism.  
   - Performance characteristics (O(1) average, O(n) worst case).  
   - Real-world analogy: Unordered set as a guest list with instant lookup.  
2. **Unordered Multiset Internals**  
   - Hash table structure with duplicate support.  
   - Performance characteristics (O(1) average).  
   - Real-world analogy: Unordered multiset as a log of repeated entries.  
3. **Advanced Applications**  
   - Duplicate detection, frequency counting, and intersections.  
   - Handling large datasets with hash-based containers.  
4. **Optimization and Pitfalls**  
   - Choosing `unordered_set` vs. `set`, `unordered_multiset` vs. `multiset`.  
   - Handling hash collisions and custom hash functions.

## Detailed Explanation

### 1. Unordered Set Internals
STL `unordered_set` is implemented as a hash table, storing unique elements with O(1) average-case complexity. Think of it as a guest list where each name is checked instantly.

- **Structure**: Array of buckets, each containing a linked list for collisions.  
- **Performance**: O(1) average for `insert`, `erase`, `find`; O(n) worst case (collisions).  
- **Limitations**: Unordered; requires hashable types.

**Example Program**: Custom hash function for unordered set.

```cpp
#include <iostream>
#include <unordered_set>
#include <string>
using namespace std;

struct CustomHash {
    size_t operator()(const string& s) const {
        size_t hash = 0;
        for (char c : s) {
            hash += c;
        }
        return hash;
    }
};

int main() {
    unordered_set<string, CustomHash> us;
    
    // Insert elements
    us.insert("apple"); us.insert("banana"); us.insert("apple");
    
    // Print size
    cout << "Size: " << us.size() << endl; // Output: 2
    
    // Print elements
    cout << "Unordered set: ";
    for (const string& s : us) {
        cout << s << " "; // Example output: banana apple
    }
    cout << endl;
    
    return 0;
}
```

**Explanation**:  
- Custom hash function sums character values.  
- Hash table ensures O(1) average operations.

### 2. Unordered Multiset Internals
STL `unordered_multiset` uses a hash table, allowing duplicate elements. Think of it as a log of repeated attendance entries.

- **Structure**: Buckets with linked lists, supporting multiple entries per hash.  
- **Performance**: O(1) average for operations.  
- **Limitations**: Unordered; no random access.

**Example Program**: Frequency counting with unordered multiset.

```cpp
#include <iostream>
#include <unordered_set>
#include <vector>
using namespace std;

void printFrequency(const vector<int>& nums) {
    unordered_multiset<int> ums(nums.begin(), nums.end());
    unordered_map<int, int> freq;
    for (const int& x : ums) {
        freq[x]++;
    }
    for (const auto& pair : freq) {
        cout << pair.first << ":" << pair.second << " "; // Output: 1:2 2:1
    }
    cout << endl;
}

int main() {
    vector<int> nums = {1, 2, 1};
    printFrequency(nums);
    return 0;
}
```

**Explanation**:  
- `unordered_multiset` stores duplicates.  
- `count` retrieves frequency efficiently.

### 3. Advanced Applications
Unordered sets and multisets are ideal for problems requiring fast lookups or duplicate handling.

**Example Program**: Check for duplicates.

```cpp
#include <iostream>
#include <unordered_set>
#include <vector>
using namespace std;

bool hasDuplicates(const vector<int>& nums) {
    unordered_set<int> us;
    for (int num : nums) {
        if (us.find(num) != us.end()) {
            return true;
        }
        us.insert(num);
    }
    return false;
}

int main() {
    vector<int> nums = {1, 2, 1};
    cout << (hasDuplicates(nums) ? "Contains duplicates" : "No duplicates") << endl; // Output: Contains duplicates
    return 0;
}
```

**Explanation**:  
- `unordered_set` detects duplicates in O(n) average time.  
- Ideal for interview problems like LeetCode 217.

### 4. Optimization and Pitfalls
- **Optimization**: Use `unordered_set` for fast lookups; `unordered_multiset` for duplicates.  
- **Pitfalls**: Handle hash collisions; ensure types are hashable.

**Example Program**: Safe unordered multiset operations.

```cpp
#include <iostream>
#include <unordered_set>
using namespace std;

int main() {
    unordered_multiset<int> ums;
    ums.insert(10); ums.insert(10);
    
    // Safe access
    int value = 10;
    cout << "Count of " << value << ": " << ums.count(value) << endl; // Output: 2
    
    // Erase one occurrence
    auto it = ums.find(value);
    if (it != ums.end()) {
        ums.erase(it);
        cout << "After erasing one " << value << ", size: " << ums.size() << endl; // Output: 1
    }
    
    return 0;
}
```

**Explanation**:  
- Check `find` result against `end()`.  
- Use `erase(iterator)` for single removal.

## Interview Questions and Answers
Below are 15 advanced interview questions on unordered sets and multisets.

1. **Question**: What is the primary difference between `unordered_set` and `set`?  
   **Answer**: `unordered_set` uses hash table (O(1) average); `set` uses red-black tree (O(log n), sorted).  
   **Interviewer’s Intention**: Tests container understanding.

2. **Question**: Why use a hash table for `unordered_set`?**  
   **Answer**: Enables O(1) average operations for fast lookups.  
   **Interviewer’s Intention**: Checks internal structure knowledge.

3. **Question**: What is the worst-case time complexity of `unordered_set::find`?**  
   **Answer**: O(n) due to hash collisions.  
   **Interviewer’s Intention**: Tests performance awareness.

4. **Question**: Write a program to check for duplicates.  
   **Answer**: (See above example.)  
   **Interviewer’s Intention**: Tests `unordered_set` application.

5. **Question**: How do you handle duplicates in an `unordered_multiset`?**  
   **Answer**: Use `count` or `erase(iterator)` for specific removals.  
   **Interviewer’s Intention**: Tests duplicate handling.

6. **Question**: What is the difference between `unordered_multiset` and `multiset`?**  
   **Answer**: `unordered_multiset` is hash-based (O(1) average); `multiset` is sorted (O(log n)).  
   **Interviewer’s Intention**: Tests container differences.

7. **Question**: Write a program to count frequencies with `unordered_multiset`.  
   **Answer**: (See above frequency example.)  
   **Interviewer’s Intention**: Tests frequency counting.

8. **Question**: Why can’t you assume order in `unordered_set`?**  
   **Answer**: Hash table does not maintain order.  
   **Interviewer’s Intention**: Tests container properties.

9. **Question**: When should you use `unordered_set` over `vector`?**  
   **Answer**: Use `unordered_set` for O(1) lookups; `vector` for indexed access.  
   **Interviewer’s Intention**: Tests container selection.

10. **Question**: Write a program to find the intersection of two arrays.  
    **Answer**: (See homework solution 7.)  
    **Interviewer’s Intention**: Tests intersection handling.

11. **Question**: What is the space complexity of `unordered_set`?**  
    **Answer**: O(n) for n elements.  
    **Interviewer’s Intention**: Tests complexity awareness.

12. **Question**: Write a program to check unique characters in a string.  
    **Answer**: (See homework solution 10.)  
    **Interviewer’s Intention**: Tests string processing.

13. **Question**: How do you create a custom hash function?**  
    **Answer**: Define a struct with `size_t operator()(const T&)` (see custom hash example).  
    **Interviewer’s Intention**: Tests advanced usage.

14. **Question**: What is a potential issue with `unordered_set`?**  
    **Answer**: Hash collisions can degrade performance to O(n).  
    **Interviewer’s Intention**: Tests optimization knowledge.

15. **Question**: Write a program to find the first non-repeating element.  
    **Answer**: (See homework solution 12.)  
    **Interviewer’s Intention**: Tests frequency analysis.

## Practice Recommendations
- Solve LeetCode problems like **Contains Duplicate** and **Intersection of Two Arrays**.  
- Experiment with custom hash functions.  
- Practice safe operations with `find` and `count`.