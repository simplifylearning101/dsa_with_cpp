# Hour 14 LeetCode Problem: Plus One

This document illustrates **LeetCode 66: Plus One**, an easy problem using STL iterators with vectors. It includes the problem description, coding pattern, solution, complexity analysis, and test cases.

## Problem Statement: LeetCode 66 - Plus One
**Link**: [LeetCode 66](https://leetcode.com/problems/plus-one/)

**Description**:  
Given a non-empty array of decimal digits representing a non-negative integer, increment the integer by one. The digits are stored such that the most significant digit is at the head of the array.

**Constraints**:
- `1 <= digits.length <= 100`
- `0 <= digits[i] <= 9`

**Example**:
- Input: `digits = [1,2,3]`  
  Output: `[1,2,4]`  
  Explanation: Represents 123 + 1 = 124.

**Real-World Analogy**: Adding 1 to a multi-digit number on a calculator.

## Coding Pattern: Reverse Iterator
- Use reverse iterators to process digits from least to most significant.  
- Handle carry using iterator traversal.

## Solution
**Algorithm**:
1. Iterate from `rbegin()` to `rend()`.  
2. Add 1 to last digit, propagate carry.  
3. If carry remains, insert 1 at beginning.

**Code**:
```cpp
#include <vector>
using namespace std;

class Solution {
public:
    vector<int> plusOne(vector<int>& digits) {
        for (auto it = digits.rbegin(); it != digits.rend(); ++it) {
            if (*it < 9) {
                *it += 1;
                return digits;
            }
            *it = 0;
        }
        digits.insert(digits.begin(), 1);
        return digits;
    }
};
```

**Time Complexity**: O(n)  
- Single pass through digits.

**Space Complexity**: O(1) excluding output  
- In-place modification, except possible insertion.

**Explanation**:  
- Reverse iterator simplifies carry propagation.  
- `insert` handles case like `[9,9]` → `[1,0,0]`.

## Test Cases
1. **Typical Case**: `digits = [1,2,3]` → Output: `[1,2,4]`  
2. **All Nines**: `digits = [9,9]` → Output: `[1,0,0]`  
3. **Single Digit**: `digits = [0]` → Output: `[1]`  
4. **Single Nine**: `digits = [9]` → Output: `[1,0]`  
5. **Large Number**: `digits = [1,9,9]` → Output: `[2,0,0]`  

**Test Case Implementation**:
```cpp
#include <iostream>
#include <vector>
using namespace std;

vector<int> plusOne(vector<int>& digits) {
    for (auto it = digits.rbegin(); it != digits.rend(); ++it) {
        if (*it < 9) {
            *it += 1;
            return digits;
        }
        *it = 0;
    }
    digits.insert(digits.begin(), 1);
    return digits;
}

void printVector(const vector<int>& v) {
    cout << "[";
    for (int i = 0; i < v.size(); ++i) {
        cout << v[i];
        if (i < v.size() - 1) cout << ",";
    }
    cout << "]";
}

int main() {
    vector<int> digits1 = {1, 2, 3};
    cout << "Test 1: "; printVector(plusOne(digits1));  // [1,2,4]
    cout << endl;
    
    vector<int> digits2 = {9, 9};
    cout << "Test 2: "; printVector(plusOne(digits2));  // [1,0,0]
    cout << endl;
    
    vector<int> digits3 = {0};
    cout << "Test 3: "; printVector(plusOne(digits3));  // [1]
    cout << endl;
    
    vector<int> digits4 = {9};
    cout << "Test 4: "; printVector(plusOne(digits4));  // [1,0]
    cout << endl;
    
    vector<int> digits5 = {1, 9, 9};
    cout << "Test 5: "; printVector(plusOne(digits5));  // [2,0,0]
    cout << endl;
    
    return 0;
}
```

**Output**:
```
Test 1: [1,2,4]
Test 2: [1,0,0]
Test 3: [1]
Test 4: [1,0]
Test 5: [2,0,0]
```

## Optimization Mindset
- **Efficiency**: Reverse iterator avoids manual index management.  
- **Key Insight**: Handle carry propagation efficiently.  
- **Edge Cases**: Single digit, all nines.