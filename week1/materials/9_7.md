# Hour 9 Additional LeetCode Problems: Multiset and Multimap Solutions

This document provides detailed solutions for four LeetCode problems recommended in `9_2.md`: **LeetCode 451: Sort Characters By Frequency**, **LeetCode 692: Top K Frequent Words**, **LeetCode 350: Intersection of Two Arrays II**, and **LeetCode 594: Longest Harmonious Subsequence**. Each solution includes a problem description, coding pattern, optimized solution with commented C++ code using STL `multiset` or `multimap`, time and space complexity analysis, and test cases covering typical and edge cases.

## Agenda
- Provide optimized solutions for four multiset/multimap-based LeetCode problems.
- Explain coding patterns (e.g., frequency sorting, intersection, subsequence).
- Analyze time and space complexities.
- Include test cases to ensure robustness.

## Outcome Expected
Students will:
- Master multiset/multimap usage for frequency sorting, intersections, and subsequences.  
- Apply techniques for array and string processing.  
- Handle edge cases and optimize for interviews.  
- Gain confidence in solving multiset/multimap-based LeetCode problems.

---

## 1. LeetCode 451: Sort Characters By Frequency (Medium)

**Link**: [LeetCode 451](https://leetcode.com/problems/sort-characters-by-frequency/)

**Description**:  
Given a string `s`, sort it in decreasing order based on the frequency of the characters. The frequency of a character is the number of times it appears in the string.

**Constraints**:
- `1 <= s.length <= 5 * 10^5`
- `s` consists of printable ASCII characters.

**Example**:
- Input: `s = "tree"`  
  Output: `"eert"`  
  Explanation: `'e'` appears twice, `'r'` and `'t'` appear once, so `'e'` comes first.

**Coding Pattern**: Multimap for Frequency Sorting  
- Use `unordered_map` to count character frequencies.  
- Use `multimap` with reverse order to sort by frequency.  
- Build result string by repeating characters by their frequency.

**Optimized Solution**:
```cpp
#include <map>
#include <string>
#include <unordered_map>
using namespace std;

class Solution {
public:
    string frequencySort(string s) {
        unordered_map<char, int> freq;
        for (char c : s) {
            freq[c]++;
        }
        multimap<int, char, greater<int>> mm; // {freq, char}
        for (const auto& pair : freq) {
            mm.insert({pair.second, pair.first});
        }
        string result;
        for (const auto& pair : mm) {
            result += string(pair.first, pair.second);
        }
        return result;
    }
};
```

**Time Complexity**: O(n log n)  
- Frequency counting: O(n).  
- Inserting into `multimap`: O(n log n).  
- Building result: O(n).

**Space Complexity**: O(k)  
- Stores k unique characters in maps.

**Explanation**:  
- `unordered_map` counts frequencies.  
- `multimap` sorts by frequency in descending order.  
- Construct result by repeating characters.

**Test Cases**:
1. **Typical Case**: `s = "tree"` → Output: `"eert"`  
2. **Single Character**: `s = "a"` → Output: `"a"`  
3. **All Same**: `s = "aaa"` → Output: `"aaa"`  
4. **Empty String**: `s = ""` → Output: `""`  
5. **Mixed Case**: `s = "Aabb"` → Output: `"bbAa"`  

---

## 2. LeetCode 692: Top K Frequent Words (Medium)

**Link**: [LeetCode 692](https://leetcode.com/problems/top-k-frequent-words/)

**Description**:  
Given a string array `words` and an integer `k`, return the `k` most frequent strings sorted by frequency from highest to lowest. If two words have the same frequency, sort them lexicographically.

**Constraints**:
- `1 <= words.length <= 500`
- `1 <= words[i].length <= 10`
- `words[i]` consists of lowercase English letters.
- `k` is in the range `[1, the number of unique words]`.

**Example**:
- Input: `words = ["i","love","leetcode","i","love","coding"], k = 2`  
  Output: `["i","love"]`  
  Explanation: `"i"` and `"love"` are the two most frequent words, sorted lexicographically.

**Coding Pattern**: Multimap with Custom Comparator  
- Use `unordered_map` to count word frequencies.  
- Use `multimap` to sort by frequency (descending) and lexicographically for ties.  
- Extract top k words.

**Optimized Solution**:
```cpp
#include <map>
#include <string>
#include <unordered_map>
#include <vector>
using namespace std;

class Solution {
public:
    vector<string> topKFrequent(vector<string>& words, int k) {
        unordered_map<string, int> freq;
        for (const string& word : words) {
            freq[word]++;
        }
        multimap<int, string, greater<int>> mm; // {freq, word}
        for (const auto& pair : freq) {
            mm.insert({pair.second, pair.first});
        }
        vector<string> result;
        auto it = mm.begin();
        while (k > 0) {
            auto range = mm.equal_range(it->first);
            vector<string> same_freq;
            for (auto r = range.first; r != range.second; ++r) {
                same_freq.push_back(r->second);
            }
            sort(same_freq.begin(), same_freq.end()); // Lexicographical sort
            for (const string& word : same_freq) {
                if (k == 0) break;
                result.push_back(word);
                k--;
            }
            it = range.second;
            if (it == mm.end()) break;
        }
        return result;
    }
};
```

**Time Complexity**: O(n log n)  
- Frequency counting: O(n).  
- Inserting into `multimap`: O(n log n).  
- Sorting same-frequency words: O(k log k) in worst case.

**Space Complexity**: O(n)  
- Stores frequency map and multimap.

**Explanation**:  
- `unordered_map` counts frequencies.  
- `multimap` sorts by frequency; `equal_range` handles ties.  
- Lexicographical sorting for same-frequency words.

**Test Cases**:
1. **Typical Case**: `words = ["i","love","leetcode","i","love","coding"], k = 2` → Output: `["i","love"]`  
2. **Single Word**: `words = ["a"], k = 1` → Output: `["a"]`  
3. **Same Frequency**: `words = ["a","b"], k = 2` → Output: `["a","b"]`  
4. **All Same**: `words = ["a","a","a"], k = 1` → Output: `["a"]`  
5. **Large K**: `words = ["a","b","c"], k = 3` → Output: `["a","b","c"]`  

---

## 3. LeetCode 350: Intersection of Two Arrays II (Easy)

**Link**: [LeetCode 350](https://leetcode.com/problems/intersection-of-two-arrays-ii/)

**Description**:  
Given two integer arrays `nums1` and `nums2`, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays, and you may return the result in any order.

**Constraints**:
- `1 <= nums1.length, nums2.length <= 1000`
- `0 <= nums1[i], nums2[i] <= 1000`

**Example**:
- Input: `nums1 = [1,2,2,1], nums2 = [2,2]`  
  Output: `[2,2]`  
  Explanation: `2` appears twice in both arrays.

**Coding Pattern**: Multiset for Intersection  
- Convert `nums1` to a `multiset`.  
- For each element in `nums2`, check if it exists in the multiset and include it in the result.  
- Remove matched elements from the multiset.

**Optimized Solution**:
```cpp
#include <set>
#include <vector>
using namespace std;

class Solution {
public:
    vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {
        multiset<int> ms(nums1.begin(), nums1.end());
        vector<int> result;
        for (int num : nums2) {
            auto it = ms.find(num);
            if (it != ms.end()) {
                result.push_back(num);
                ms.erase(it); // Remove one occurrence
            }
        }
        return result;
    }
};
```

**Time Complexity**: O(n log n + m log n)  
- Building multiset: O(n log n).  
- Processing nums2: O(m log n) for `find` and `erase`.

**Space Complexity**: O(n)  
- Stores multiset and result.

**Explanation**:  
- `multiset` tracks elements with duplicates.  
- `find` and `erase` handle intersections efficiently.  
- Preserves frequency of elements.

**Test Cases**:
1. **Typical Case**: `nums1 = [1,2,2,1], nums2 = [2,2]` → Output: `[2,2]`  
2. **No Intersection**: `nums1 = [1,2], nums2 = [3,4]` → Output: `[]`  
3. **Single Element**: `nums1 = [1], nums2 = [1]` → Output: `[1]`  
4. **Duplicates**: `nums1 = [1,1,1], nums2 = [1,1]` → Output: `[1,1]`  
5. **Empty Array**: `nums1 = [], nums2 = [1]` → Output: `[]`  

---

## 4. LeetCode 594: Longest Harmonious Subsequence (Easy)

**Link**: [LeetCode 594](https://leetcode.com/problems/longest-harmonious-subsequence/)

**Description**:  
A harmonious subsequence is one where the difference between its maximum and minimum values is exactly 1. Given an integer array `nums`, return the length of its longest harmonious subsequence.

**Constraints**:
- `1 <= nums.length <= 2 * 10^4`
- `-10^9 <= nums[i] <= 10^9`

**Example**:
- Input: `nums = [1,3,2,2,5,2,3,7]`  
  Output: `5`  
  Explanation: The longest harmonious subsequence is `[2,2,2,3,3]`.

**Coding Pattern**: Multiset for Frequency Analysis  
- Use `unordered_map` to count frequencies.  
- Use `multiset` to iterate unique elements and check for `num + 1`.  
- Compute maximum length of harmonious subsequences.

**Optimized Solution**:
```cpp
#include <set>
#include <unordered_map>
#include <vector>
using namespace std;

class Solution {
public:
    int findLHS(vector<int>& nums) {
        unordered_map<int, int> freq;
        for (int num : nums) {
            freq[num]++;
        }
        multiset<int> ms(nums.begin(), nums.end());
        int max_len = 0;
        for (const auto& num : ms) {
            if (freq.count(num + 1)) {
                max_len = max(max_len, freq[num] + freq[num + 1]);
            }
        }
        return max_len;
    }
};
```

**Time Complexity**: O(n log n)  
- Building frequency map and multiset: O(n log n).  
- Checking pairs: O(n).

**Space Complexity**: O(n)  
- Stores frequency map and multiset.

**Explanation**:  
- `unordered_map` counts frequencies.  
- `multiset` provides unique elements in sorted order.  
- Check for consecutive numbers to form harmonious subsequence.

**Test Cases**:
1. **Typical Case**: `nums = [1,3,2,2,5,2,3,7]` → Output: `5`  
2. **No Harmonious**: `nums = [1,2,4]` → Output: `0`  
3. **Single Number**: `nums = [1,1,1]` → Output: `0`  
4. **All Harmonious**: `nums = [1,1,2,2]` → Output: `4`  
5. **Negative Numbers**: `nums = [-1,0,0,-1]` → Output: `4`  

---

## Test Case Implementation
Below is a program to test all four solutions with the provided test cases.

```cpp
#include <iostream>
#include <map>
#include <set>
#include <string>
#include <unordered_map>
#include <vector>
using namespace std;

// LeetCode 451: Sort Characters By Frequency
string frequencySort(string s) {
    unordered_map<char, int> freq;
    for (char c : s) {
        freq[c]++;
    }
    multimap<int, char, greater<int>> mm;
    for (const auto& pair : freq) {
        mm.insert({pair.second, pair.first});
    }
    string result;
    for (const auto& pair : mm) {
        result += string(pair.first, pair.second);
    }
    return result;
}

// LeetCode 692: Top K Frequent Words
vector<string> topKFrequentWords(vector<string>& words, int k) {
    unordered_map<string, int> freq;
    for (const string& word : words) {
        freq[word]++;
    }
    multimap<int, string, greater<int>> mm;
    for (const auto& pair : freq) {
        mm.insert({pair.second, pair.first});
    }
    vector<string> result;
    auto it = mm.begin();
    while (k > 0) {
        auto range = mm.equal_range(it->first);
        vector<string> same_freq;
        for (auto r = range.first; r != range.second; ++r) {
            same_freq.push_back(r->second);
        }
        sort(same_freq.begin(), same_freq.end());
        for (const string& word : same_freq) {
            if (k == 0) break;
            result.push_back(word);
            k--;
        }
        it = range.second;
        if (it == mm.end()) break;
    }
    return result;
}

// LeetCode 350: Intersection of Two Arrays II
vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {
    multiset<int> ms(nums1.begin(), nums1.end());
    vector<int> result;
    for (int num : nums2) {
        auto it = ms.find(num);
        if (it != ms.end()) {
            result.push_back(num);
            ms.erase(it);
        }
    }
    return result;
}

// LeetCode 594: Longest Harmonious Subsequence
int findLHS(vector<int>& nums) {
    unordered_map<int, int> freq;
    for (int num : nums) {
        freq[num]++;
    }
    multiset<int> ms(nums.begin(), nums.end());
    int max_len = 0;
    for (const auto& num : ms) {
        if (freq.count(num + 1)) {
            max_len = max(max_len, freq[num] + freq[num + 1]);
        }
    }
    return max_len;
}

// Helper to print vector
void printVector(const vector<int>& v) {
    cout << "[";
    for (int i = 0; i < v.size(); ++i) {
        cout << v[i] << (i < v.size() - 1 ? "," : "");
    }
    cout << "]" << endl;
}

void printStringVector(const vector<string>& v) {
    cout << "[";
    for (int i = 0; i < v.size(); ++i) {
        cout << "\"" << v[i] << "\"" << (i < v.size() - 1 ? "," : "");
    }
    cout << "]" << endl;
}

int main() {
    // Test LeetCode 451
    cout << "LeetCode 451: Sort Characters By Frequency\n";
    string s_451 = "tree";
    cout << "Test 1: " << frequencySort(s_451) << endl; // eert

    // Test LeetCode 692
    cout << "\nLeetCode 692: Top K Frequent Words\n";
    vector<string> words_692 = {"i", "love", "leetcode", "i", "love", "coding"};
    int k_692 = 2;
    cout << "Test 1: "; printStringVector(topKFrequentWords(words_692, k_692)); // ["i","love"]

    // Test LeetCode 350
    cout << "\nLeetCode 350: Intersection of Two Arrays II\n";
    vector<int> nums1_350 = {1, 2, 2, 1}, nums2_350 = {2, 2};
    cout << "Test 1: "; printVector(intersect(nums1_350, nums2_350)); // [2,2]

    // Test LeetCode 594
    cout << "\nLeetCode 594: Longest Harmonious Subsequence\n";
    vector<int> nums_594 = {1, 3, 2, 2, 5, 2, 3, 7};
    cout << "Test 1: " << findLHS(nums_594) << endl; // 5

    return 0;
}
```

**Output**:
```
LeetCode 451: Sort Characters By Frequency
Test 1: eert

LeetCode 692: Top K Frequent Words
Test 1: ["i","love"]

LeetCode 350: Intersection of Two Arrays II
Test 1: [2,2]

LeetCode 594: Longest Harmonious Subsequence
Test 1: 5
```

## Key Takeaways
- **Frequency Sorting**: Leet