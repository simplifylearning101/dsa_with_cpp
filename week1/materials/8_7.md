# Hour 8 Additional LeetCode Problems: Map Solutions

This document provides detailed solutions for four LeetCode problems recommended in `8_2.md`: **LeetCode 560: Subarray Sum Equals K**, **LeetCode 219: Contains Duplicate II**, **LeetCode 205: Isomorphic Strings**, and **LeetCode 290: Word Pattern**. Each solution includes a problem description, coding pattern, optimized solution with commented C++ code using STL `unordered_map`, time and space complexity analysis, and test cases covering typical and edge cases.

## Agenda
- Provide optimized solutions for four map-based LeetCode problems.
- Explain coding patterns (e.g., cumulative sum, sliding window, pattern matching).
- Analyze time and space complexities.
- Include test cases to ensure robustness.

## Outcome Expected
Students will:
- Master map usage for cumulative sum, sliding window, and pattern-matching problems.  
- Apply map-based techniques for array and string processing.  
- Handle edge cases and optimize for interviews.  
- Gain confidence in solving map-based LeetCode problems.

---

## 1. LeetCode 560: Subarray Sum Equals K (Medium)

**Link**: [LeetCode 560](https://leetcode.com/problems/subarray-sum-equals-k/)

**Description**:  
Given an array of integers `nums` and an integer `k`, return the total number of continuous subarrays whose sum equals `k`.

**Constraints**:
- `1 <= nums.length <= 2 * 10^4`
- `-1000 <= nums[i] <= 1000`
- `-10^7 <= k <= 10^7`

**Example**:
- Input: `nums = [1,1,1], k = 2`  
  Output: `2`  
  Explanation: Subarrays `[1,1]` (indices 0-1 and 1-2) sum to 2.

**Coding Pattern**: Unordered Map for Cumulative Sum  
- Use `unordered_map` to store cumulative sum frequencies.  
- For each index, compute cumulative sum and check if `sum - k` exists in map.  
- Increment count by frequency of `sum - k`; update map with current sum.

**Optimized Solution**:
```cpp
#include <unordered_map>
#include <vector>
using namespace std;

class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        unordered_map<int, int> sum_freq; // Cumulative sum -> frequency
        sum_freq[0] = 1; // Handle subarray starting from index 0
        int sum = 0, count = 0;
        for (int num : nums) {
            sum += num;
            if (sum_freq.count(sum - k)) {
                count += sum_freq[sum - k];
            }
            sum_freq[sum]++;
        }
        return count;
    }
};
```

**Time Complexity**: O(n)  
- Single pass with O(1) average map operations.

**Space Complexity**: O(n)  
- Stores up to n cumulative sums in `unordered_map`.

**Explanation**:  
- `sum_freq[0] = 1` handles subarrays starting from index 0.  
- For each `sum`, check if `sum - k` exists to count valid subarrays.  
- Update frequency of current `sum`.

**Test Cases**:
1. **Typical Case**: `nums = [1,1,1], k = 2` → Output: `2`  
2. **Negative Numbers**: `nums = [1,-1,0], k = 0` → Output: `2`  
3. **Single Element**: `nums = [1], k = 1` → Output: `1`  
4. **No Subarray**: `nums = [1,2,3], k = 10` → Output: `0`  
5. **All Zeros**: `nums = [0,0], k = 0` → Output: `3`  

---

## 2. LeetCode 219: Contains Duplicate II (Easy)

**Link**: [LeetCode 219](https://leetcode.com/problems/contains-duplicate-ii/)

**Description**:  
Given an integer array `nums` and integers `k` and `t`, return `true` if there are two distinct indices `i` and `j` such that `abs(nums[i] - nums[j]) <= t` and `abs(i - j) <= k`.

**Constraints**:
- `0 <= nums.length <= 2 * 10^4`
- `-2^31 <= nums[i] <= 2^31 - 1`
- `0 <= k <= 10^4`
- `0 <= t <= 2^31 - 1`

**Example**:
- Input: `nums = [1,5,3], k = 2, t = 2`  
  Output: `true`  
  Explanation: `nums[0] = 1` and `nums[2] = 3` satisfy `abs(1-3) <= 2` and `abs(0-2) <= 2`.

**Coding Pattern**: Unordered Map with Sliding Window  
- Use `unordered_map` to store number-to-index mappings in a sliding window of size `k`.  
- For each number, check if a nearby number within `t` exists in the map.  
- Remove elements outside the window.

**Optimized Solution**:
```cpp
#include <unordered_map>
#include <vector>
using namespace std;

class Solution {
public:
    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {
        unordered_map<long, long> buckets;
        long w = (long)t + 1; // Bucket size
        for (int i = 0; i < nums.size(); ++i) {
            long num = nums[i];
            long bucket = num / w;
            if (buckets.count(bucket)) return true;
            if (buckets.count(bucket - 1) && abs(num - buckets[bucket - 1]) < w) return true;
            if (buckets.count(bucket + 1) && abs(num - buckets[bucket + 1]) < w) return true;
            buckets[bucket] = num;
            if (i >= k) {
                buckets.erase((long)nums[i - k] / w);
            }
        }
        return false;
    }
};
```

**Time Complexity**: O(n)  
- Each element processed with O(1) average map operations.

**Space Complexity**: O(k)  
- Stores up to k elements in `unordered_map`.

**Explanation**:  
- Use bucketing to group numbers within `t` of each other.  
- Check current, previous, and next buckets for valid pairs.  
- Remove elements outside window of size `k`.

**Test Cases**:
1. **Typical Case**: `nums = [1,5,3], k = 2, t = 2` → Output: `true`  
2. **No Duplicates**: `nums = [1,2,3], k = 1, t = 0` → Output: `false`  
3. **Empty Array**: `nums = [], k = 1, t = 1` → Output: `false`  
4. **Single Element**: `nums = [1], k = 1, t = 1` → Output: `false`  
5. **Negative Numbers**: `nums = [-1,-3], k = 1, t = 1` → Output: `true`  

---

## 3. LeetCode 205: Isomorphic Strings (Easy)

**Link**: [LeetCode 205](https://leetcode.com/problems/isomorphic-strings/)

**Description**:  
Given two strings `s` and `t`, determine if they are isomorphic. Two strings are isomorphic if the characters in `s` can be replaced to get `t`, maintaining the order of characters. No two characters may map to the same character, but a character may map to itself.

**Constraints**:
- `1 <= s.length <= 5 * 10^4`
- `s` and `t` consist of any valid ASCII characters.

**Example**:
- Input: `s = "egg", t = "add"`  
  Output: `true`  
  Explanation: `e -> a`, `g -> d` is a valid mapping.

**Coding Pattern**: Unordered Map for Character Mapping  
- Use two `unordered_map`s to track bidirectional mappings (s-to-t and t-to-s).  
- For each character pair, ensure consistent mapping.  
- Return `false` if mappings conflict.

**Optimized Solution**:
```cpp
#include <unordered_map>
#include <string>
using namespace std;

class Solution {
public:
    bool isIsomorphic(string s, string t) {
        unordered_map<char, char> s_to_t;
        unordered_map<char, char> t_to_s;
        for (int i = 0; i < s.size(); ++i) {
            if (!s_to_t.count(s[i]) && !t_to_s.count(t[i])) {
                s_to_t[s[i]] = t[i];
                t_to_s[t[i]] = s[i];
            } else if (s_to_t[s[i]] != t[i] || t_to_s[t[i]] != s[i]) {
                return false;
            }
        }
        return true;
    }
};
```

**Time Complexity**: O(n)  
- Single pass with O(1) average map operations.

**Space Complexity**: O(k)  
- Stores mappings for unique characters (k = alphabet size).

**Explanation**:  
- Two maps ensure one-to-one mapping.  
- Check for conflicts in both directions.  
- Handles same-character mappings correctly.

**Test Cases**:
1. **Typical Case**: `s = "egg", t = "add"` → Output: `true`  
2. **Non-Isomorphic**: `s = "foo", t = "bar"` → Output: `false`  
3. **Single Character**: `s = "a", t = "b"` → Output: `true`  
4. **Different Lengths**: `s = "ab", t = "a"` → Output: `false`  
5. **Self Mapping**: `s = "paper", t = "paper"` → Output: `true`  

---

## 4. LeetCode 290: Word Pattern (Easy)

**Link**: [LeetCode 290](https://leetcode.com/problems/word-pattern/)

**Description**:  
Given a pattern and a string `s`, find if `s` follows the same pattern. A pattern is a string of lowercase letters, and `s` contains lowercase words separated by spaces. A word follows the pattern if there is a one-to-one correspondence between pattern letters and words.

**Constraints**:
- `1 <= pattern.length <= 300`
- `s` contains lowercase English words separated by spaces.

**Example**:
- Input: `pattern = "abba", s = "dog cat cat dog"`  
  Output: `true`  
  Explanation: `a -> dog`, `b -> cat` is a valid mapping.

**Coding Pattern**: Unordered Map for Pattern Matching  
- Split `s` into words.  
- Use two `unordered_map`s to track bidirectional mappings (pattern-to-word, word-to-pattern).  
- Ensure consistent one-to-one mapping.

**Optimized Solution**:
```cpp
#include <unordered_map>
#include <string>
#include <vector>
using namespace std;

class Solution {
public:
    bool wordPattern(string pattern, string s) {
        vector<string> words;
        string word;
        for (char c : s) {
            if (c == ' ') {
                words.push_back(word);
                word = "";
            } else {
                word += c;
            }
        }
        words.push_back(word);
        
        if (pattern.size() != words.size()) return false;
        
        unordered_map<char, string> p_to_w;
        unordered_map<string, char> w_to_p;
        for (int i = 0; i < pattern.size(); ++i) {
            if (!p_to_w.count(pattern[i]) && !w_to_p.count(words[i])) {
                p_to_w[pattern[i]] = words[i];
                w_to_p[words[i]] = pattern[i];
            } else if (p_to_w[pattern[i]] != words[i] || w_to_p[words[i]] != pattern[i]) {
                return false;
            }
        }
        return true;
    }
};
```

**Time Complexity**: O(n)  
- Splitting string and processing pattern: O(n).

**Space Complexity**: O(k)  
- Stores mappings for unique pattern characters/words.

**Explanation**:  
- Split `s` into words using space delimiter.  
- Use two maps for bidirectional one-to-one mapping.  
- Check for size equality and mapping consistency.

**Test Cases**:
1. **Typical Case**: `pattern = "abba", s = "dog cat cat dog"` → Output: `true`  
2. **Non-Matching**: `pattern = "abba", s = "dog cat cat fish"` → Output: `false`  
3. **Single Character**: `pattern = "a", s = "dog"` → Output: `true`  
4. **Size Mismatch**: `pattern = "abba", s = "dog cat"` → Output: `false`  
5. **Duplicate Words**: `pattern = "aaaa", s = "dog dog dog dog"` → Output: `true`  

---

## Test Case Implementation
Below is a program to test all four solutions with the provided test cases.

```cpp
#include <iostream>
#include <unordered_map>
#include <vector>
#include <string>
using namespace std;

// LeetCode 560: Subarray Sum Equals K
int subarraySum(vector<int>& nums, int k) {
    unordered_map<int, int> sum_freq;
    sum_freq[0] = 1;
    int sum = 0, count = 0;
    for (int num : nums) {
        sum += num;
        if (sum_freq.count(sum - k)) {
            count += sum_freq[sum - k];
        }
        sum_freq[sum]++;
    }
    return count;
}

// LeetCode 219: Contains Duplicate II
bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {
    unordered_map<long, long> buckets;
    long w = (long)t + 1;
    for (int i = 0; i < nums.size(); ++i) {
        long num = nums[i];
        long bucket = num / w;
        if (buckets.count(bucket)) return true;
        if (buckets.count(bucket - 1) && abs(num - buckets[bucket - 1]) < w) return true;
        if (buckets.count(bucket + 1) && abs(num - buckets[bucket + 1]) < w) return true;
        buckets[bucket] = num;
        if (i >= k) {
            buckets.erase((long)nums[i - k] / w);
        }
    }
    return false;
}

// LeetCode 205: Isomorphic Strings
bool isIsomorphic(string s, string t) {
    unordered_map<char, char> s_to_t;
    unordered_map<char, char> t_to_s;
    for (int i = 0; i < s.size(); ++i) {
        if (!s_to_t.count(s[i]) && !t_to_s.count(t[i])) {
            s_to_t[s[i]] = t[i];
            t_to_s[t[i]] = s[i];
        } else if (s_to_t[s[i]] != t[i] || t_to_s[t[i]] != s[i]) {
            return false;
        }
    }
    return true;
}

// LeetCode 290: Word Pattern
bool wordPattern(string pattern, string s) {
    vector<string> words;
    string word;
    for (char c : s) {
        if (c == ' ') {
            words.push_back(word);
            word = "";
        } else {
            word += c;
        }
    }
    words.push_back(word);
    
    if (pattern.size() != words.size()) return false;
    
    unordered_map<char, string> p_to_w;
    unordered_map<string, char> w_to_p;
    for (int i = 0; i < pattern.size(); ++i) {
        if (!p_to_w.count(pattern[i]) && !w_to_p.count(words[i])) {
            p_to_w[pattern[i]] = words[i];
            w_to_p[words[i]] = pattern[i];
        } else if (p_to_w[pattern[i]] != words[i] || w_to_p[words[i]] != pattern[i]) {
            return false;
        }
    }
    return true;
}

int main() {
    // Test LeetCode 560
    cout << "LeetCode 560: Subarray Sum Equals K\n";
    vector<int> nums_560 = {1, 1, 1};
    int k_560 = 2;
    cout << "Test 1: " << subarraySum(nums_560, k_560) << endl; // 2

    // Test LeetCode 219
    cout << "\nLeetCode 219: Contains Duplicate II\n";
    vector<int> nums_219 = {1, 5, 3};
    int k_219 = 2, t_219 = 2;
    cout << "Test 1: " << (containsNearbyAlmostDuplicate(nums_219, k_219, t_219) ? "true" : "false") << endl; // true

    // Test LeetCode 205
    cout << "\nLeetCode 205: Isomorphic Strings\n";
    string s_205 = "egg", t_205 = "add";
    cout << "Test 1: " << (isIsomorphic(s_205, t_205) ? "true" : "false") << endl; // true

    // Test LeetCode 290
    cout << "\nLeetCode 290: Word Pattern\n";
    string pattern_290 = "abba", s_290 = "dog cat cat dog";
    cout << "Test 1: " << (wordPattern(pattern_290, s_290) ? "true" : "false") << endl; // true

    return 0;
}
```

**Output**:
```
LeetCode 560: Subarray Sum Equals K
Test 1: 2

LeetCode 219: Contains Duplicate II
Test 1: true

LeetCode 205: Isomorphic Strings
Test 1: true

LeetCode 290: Word Pattern
Test 1: true
```

## Key Takeaways
- **Cumulative Sum**: LeetCode 560 uses `unordered_map` for tracking sum frequencies.  
- **Sliding Window**: LeetCode 219 leverages bucketing for nearby duplicates.  
- **Pattern Matching**: LeetCode 205 and 290 use bidirectional maps for isomorphism.  
- **Optimization**: Prefer `unordered_map` for speed; handle edge cases like empty inputs.  
- **Interview Prep**: These problems cover common map-based patterns (frequency, mapping, sliding window).

These solutions reinforce map manipulation skills, preparing students for interview scenarios with map-based algorithms.