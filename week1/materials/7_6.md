# Hour 7 LeetCode Problem: Intersection of Two Arrays

This document illustrates **LeetCode 349: Intersection of Two Arrays**, an easy problem that leverages STL `set` or `unordered_set` for efficient intersection computation. It includes the problem description, coding pattern, solution, complexity analysis, and test cases.

## Problem Statement: LeetCode 349 - Intersection of Two Arrays
**Link**: [LeetCode 349](https://leetcode.com/problems/intersection-of-two-arrays/)

**Description**:  
Given two integer arrays `nums1` and `nums2`, return an array of their intersection. Each element in the result must be unique, and you may return the result in any order.

**Constraints**:
- `1 <= nums1.length, nums2.length <= 10^4`
- `-10^9 <= nums1[i], nums2[i] <= 10^9`

**Example**:
- Input: `nums1 = [1,2,2,1], nums2 = [2,2]`  
  Output: `[2]`  
  Explanation: 2 is the only element common to both arrays.

**Real-World Analogy**: Imagine finding common attendees in two guest lists, ensuring no duplicates in the final list.

## Coding Pattern: Set for Intersection
- Convert one array to a `set` or `unordered_set` for O(log n) or O(1) lookups.  
- Iterate through the second array, checking for elements in the set.  
- Use a set to store results to ensure uniqueness.

## Solution
**Algorithm**:
1. Convert `nums1` to a `set` to remove duplicates and enable fast lookups.
2. Iterate through `nums2`, checking each element against the set.
3. Add common elements to a result set to ensure uniqueness.
4. Convert result set to vector and return.

**Code**:
```cpp
#include <set>
#include <vector>
using namespace std;

class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        set<int> s(nums1.begin(), nums1.end()); // Store unique elements
        set<int> result;
        
        // Check for common elements
        for (int num : nums2) {
            if (s.count(num)) {
                result.insert(num);
            }
        }
        
        // Convert to vector
        return vector<int>(result.begin(), result.end());
    }
};
```

**Alternative with Unordered Set**:
```cpp
#include <unordered_set>
#include <vector>
using namespace std;

class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int> us(nums1.begin(), nums1.end());
        vector<int> result;
        
        // Check for common elements
        for (int num : nums2) {
            if (us.count(num)) {
                result.push_back(num);
                us.erase(num); // Avoid duplicates
            }
        }
        
        return result;
    }
};
```

**Time Complexity**:  
- `set`: O(n log n) for building set + O(m log n) for lookups (n = nums1.size, m = nums2.size).  
- `unordered_set`: O(n) for building set + O(m) for lookups (O(1) average per lookup).  

**Space Complexity**: O(n)  
- Stores unique elements of `nums1` and result.

**Explanation**:  
- `set` ensures sorted order but slower (O(log n) lookups).  
- `unordered_set` is faster (O(1) average lookups) and suitable since order doesn’t matter.  
- Erasing found elements in `unordered_set` version prevents duplicates.

## Test Cases
1. **Typical Case**: `nums1 = [1,2,2,1], nums2 = [2,2]` → Output: `[2]`  
2. **No Intersection**: `nums1 = [1,2], nums2 = [3,4]` → Output: `[]`  
3. **Single Element**: `nums1 = [1], nums2 = [1]` → Output: `[1]`  
4. **Empty Array**: `nums1 = [], nums2 = [1]` → Output: `[]`  
5. **Negative Numbers**: `nums1 = [-1,-2], nums2 = [-2,-3]` → Output: `[-2]`  

**Test Case Implementation**:
```cpp
#include <iostream>
#include <unordered_set>
#include <vector>
using namespace std;

vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
    unordered_set<int> us(nums1.begin(), nums1.end());
    vector<int> result;
    for (int num : nums2) {
        if (us.count(num)) {
            result.push_back(num);
            us.erase(num);
        }
    }
    return result;
}

// Helper to print vector
void printVector(const vector<int>& v) {
    cout << "[";
    for (size_t i = 0; i < v.size(); ++i) {
        cout << v[i];
        if (i < v.size() - 1) cout << ",";
    }
    cout << "]" << endl;
}

int main() {
    // Test cases
    vector<int> nums1_1 = {1, 2, 2, 1};
    vector<int> nums2_1 = {2, 2};
    cout << "Test 1: "; printVector(intersection(nums1_1, nums2_1)); // [2]
    
    vector<int> nums1_2 = {1, 2};
    vector<int> nums2_2 = {3, 4};
    cout << "Test 2: "; printVector(intersection(nums1_2, nums2_2)); // []
    
    vector<int> nums1_3 = {1};
    vector<int> nums1_4 = {1};
    cout << "Test 3: "; printVector(intersection(nums1_3, nums1_4)); // [1]
    
    vector<int> nums1_5 = {};
    vector<int> nums2_5 = {1};
    cout << "Test 4: "; printVector(intersection(nums1_5, nums2_5)); // []
    
    vector<int> nums1_6 = {-1, -2};
    vector<int> nums2_6 = {-2, -3};
    cout << "Test 5: "; printVector(intersection(nums1_6, nums2_6)); // [-2]
    
    return 0;
}
```

**Output**:
```
Test 1: [2]
Test 2: []
Test 3: [1]
Test 4: []
Test 5: [-2]
```

## Optimization Mindset
- **Efficiency**: `unordered_set` is preferred for O(1) average lookups.  
- **Key Insight**: Erasing found elements avoids duplicates without extra set.  
- **Edge Cases**: Handle empty arrays, no intersection, and negative numbers.