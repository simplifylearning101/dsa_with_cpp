# Solutions for Leetcode Problems

1. **Implement strStr (KMP)**  
   **Explanation:** Find first occurrence of needle in haystack.  
   **Brute-Force:** Naive substring search.  
   ```cpp
   int strStr(string haystack, string needle) {
       if (needle.empty()) return 0;
       for (int i = 0; i <= haystack.length() - needle.length(); i++) {
           if (haystack.substr(i, needle.length()) == needle) return i;
       }
       return -1;
   }
   ```
   Pros: Simple. Cons: O(n*m) time.  
   **Optimized:** KMP algorithm.  
   ```cpp
   int strStr(string haystack, string needle) {
       if (needle.empty()) return 0;
       int n = haystack.length(), m = needle.length();
       std::vector<int> lps(m, 0);
       int len = 0, i = 1;
       while (i < m) {
           if (needle[i] == needle[len]) lps[i++] = ++len;
           else if (len != 0) len = lps[len - 1];
           else lps[i++] = 0;
       }
       i = 0; int j = 0;
       while (i < n) {
           if (haystack[i] == needle[j]) { i++; j++; }
           if (j == m) return i - j;
           if (i < n && haystack[i] != needle[j]) {
               if (j != 0) j = lps[j - 1];
               else i++;
           }
       }
       return -1;
   }
   ```
   Pros: O(n+m) time, O(m) space. Cons: Complex logic.

2. **Longest Palindromic Substring**  
   **Explanation:** Find longest palindromic substring.  
   **Brute-Force:** Check all substrings.  
   ```cpp
   string longestPalindrome(string s) {
       int n = s.length(), maxLen = 1, start = 0;
       for (int i = 0; i < n; i++) {
           for (int j = i; j < n; j++) {
               bool isPal = true;
               for (int k = i; k <= j; k++) {
                   if (s[k] != s[j - (k - i)]) {
                       isPal = false;
                       break;
                   }
               }
               if (isPal && j - i + 1 > maxLen) {
                   maxLen = j - i + 1;
                   start = i;
               }
           }
       }
       return s.substr(start, maxLen);
   }
   ```
   Pros: Correct. Cons: O(n^3) time.  
   **Optimized:** Expand-around-center.  
   ```cpp
   string longestPalindrome(string s) {
       int n = s.length(), start = 0, maxLen = 1;
       for (int i = 0; i < n; i++) {
           int left = i, right = i;
           while (left >= 0 && right < n && s[left] == s[right]) {
               if (right - left + 1 > maxLen) {
                   start = left;
                   maxLen = right - left + 1;
               }
               left--; right++;
           }
           left = i; right = i + 1;
           while (left >= 0 && right < n && s[left] == s[right]) {
               if (right - left + 1 > maxLen) {
                   start = left;
                   maxLen = right - left + 1;
               }
               left--; right++;
           }
       }
       return s.substr(start, maxLen);
   }
   ```
   Pros: O(n^2) time, O(1) space. Cons: Still quadratic.

3. **Repeated Substring Pattern**  
   **Explanation:** Check if string is formed by repeating a substring.  
   **Brute-Force:** Check all possible substrings.  
   ```cpp
   bool repeatedSubstringPattern(string s) {
       int n = s.length();
       for (int len = 1; len <= n / 2; len++) {
           if (n % len == 0) {
               string pattern = s.substr(0, len);
               bool valid = true;
               for (int i = len; i < n; i += len) {
                   if (s.substr(i, len) != pattern) {
                       valid = false;
                       break;
                   }
               }
               if (valid) return true;
           }
       }
       return false;
   }
   ```
   Pros: Simple. Cons: O(n^2) time.  
   **Optimized:** Concatenation method.  
   ```cpp
   bool repeatedSubstringPattern(string s) {
       string concat = s + s;
       concat = concat.substr(1, concat.length() - 2);
       return concat.find(s) != string::npos;
   }
   ```
   Pros: O(n) time with KMP, O(n) space. Cons: Relies on string search.

4. **Interleaving String**  
   **Explanation:** Check if s3 is formed by interleaving s1 and s2.  
   **Brute-Force:** Recursive approach.  
   ```cpp
   bool isInterleave(string s1, string s2, string s3) {
       if (s1.length() + s2.length() != s3.length()) return false;
       if (s1.empty()) return s2 == s3;
       if (s2.empty()) return s1 == s3;
       if (s3.empty()) return false;
       if (s1[0] == s3[0] && isInterleave(s1.substr(1), s2, s3.substr(1))) return true;
       if (s2[0] == s3[0] && isInterleave(s1, s2.substr(1), s3.substr(1))) return true;
       return false;
   }
   ```
   Pros: Intuitive. Cons: O(2^(m+n)) time.  
   **Optimized:** Dynamic programming.  
   ```cpp
   bool isInterleave(string s1, string s2, string s3) {
       if (s1.length() + s2.length() != s3.length()) return false;
       vector<vector<bool>> dp(s1.length() + 1, vector<bool>(s2.length() + 1, false));
       dp[0][0] = true;
       for (int i = 0; i <= s1.length(); i++) {
           for (int j = 0; j <= s2.length(); j++) {
               if (i > 0 && s1[i - 1] == s3[i + j - 1]) dp[i][j] |= dp[i - 1][j];
               if (j > 0 && s2[j - 1] == s3[i + j - 1]) dp[i][j] |= dp[i][j - 1];
           }
       }
       return dp[s1.length()][s2.length()];
   }
   ```
   Pros: O(m*n) time, O(m*n) space. Cons: Extra space.

5. **Distinct Subsequences**  
   **Explanation:** Count distinct subsequences of t in s.  
   **Brute-Force:** Recursive approach.  
   ```cpp
   int numDistinct(string s, string t) {
       if (t.empty()) return 1;
       if (s.empty()) return 0;
       if (s[0] == t[0]) return numDistinct(s.substr(1), t.substr(1)) + numDistinct(s.substr(1), t);
       return numDistinct(s.substr(1), t);
   }
   ```
   Pros: Simple. Cons: O(2^n) time.  
   **Optimized:** Dynamic programming.  
   ```cpp
   int numDistinct(string s, string t) {
       int m = s.length(), n = t.length();
       vector<vector<long>> dp(m + 1, vector<long>(n + 1, 0));
       for (int i = 0; i <= m; i++) dp[i][0] = 1;
       for (int i = 1; i <= m; i++) {
           for (int j = 1; j <= n; j++) {
               dp[i][j] = dp[i - 1][j];
               if (s[i - 1] == t[j - 1]) dp[i][j] += dp[i - 1][j - 1];
           }
       }
       return dp[m][n];
   }
   ```
   Pros: O(m*n) time, O(m*n) space. Cons: Extra space.