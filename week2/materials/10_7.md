# Solutions for Leetcode Problems

1. **Implement strStr (KMP)**  
   **Explanation**: Find first occurrence of pattern.  
   **Brute-Force**: Check each substring.  
   ```cpp
   int strStr(std::string haystack, std::string needle) {
       if (needle.empty()) return 0;
       for (int i = 0; i <= haystack.size() - needle.size(); i++) {
           if (haystack.substr(i, needle.size()) == needle) return i;
       }
       return -1;
   }
   ```
   Pros: Simple. Cons: O(n*m) time.  
   **Optimized**: KMP.  
   ```cpp
   int strStr(std::string haystack, std::string needle) {
       if (needle.empty()) return 0;
       int n = haystack.length(), m = needle.length();
       std::vector<int> lps(m, 0);
       int len = 0, i = 1;
       while (i < m) {
           if (needle[i] == needle[len]) lps[i++] = ++len;
           else if (len != 0) len = lps[len - 1];
           else lps[i++] = 0;
       }
       i = 0; int j = 0;
       while (i < n) {
           if (haystack[i] == needle[j]) { i++; j++; }
           if (j == m) return i - j;
           if (i < n && haystack[i] != needle[j]) {
               if (j != 0) j = lps[j - 1];
               else i++;
           }
       }
       return -1;
   }
   ```
   Pros: O(n+m) time, O(m) space. Cons: Complex logic.

2. **Group Anagrams**  
   **Explanation**: Group anagram strings.  
   **Brute-Force**: Sort each string.  
   ```cpp
   std::vector<std::vector<std::string>> groupAnagrams(std::vector<std::string>& strs) {
       std::unordered_map<std::string, std::vector<std::string>> map;
       for (std::string s : strs) {
           std::string sorted = s;
           std::sort(sorted.begin(), sorted.end());
           map[sorted].push_back(s);
       }
       std::vector<std::vector<std::string>> result;
       for (auto& pair : map) result.push_back(pair.second);
       return result;
   }
   ```
   Pros: Simple. Cons: O(n*k*log k) time.  
   **Optimized**: Frequency array.  
   ```cpp
   std::vector<std::vector<std::string>> groupAnagrams(std::vector<std::string>& strs) {
       std::unordered_map<std::string, std::vector<std::string>> map;
       for (std::string s : strs) {
           std::vector<int> count(26, 0);
           for (char c : s) count[c - 'a']++;
           std::string key;
           for (int x : count) key += std::to_string(x) + "#";
           map[key].push_back(s);
       }
       std::vector<std::vector<std::string>> result;
       for (auto& pair : map) result.push_back(pair.second);
       return result;
   }
   ```
   Pros: O(n*k) time, O(n) space. Cons: Extra space.

3. **Longest Palindromic Substring**  
   **Explanation**: Find longest palindrome.  
   **Brute-Force**: Check all substrings.  
   ```cpp
   std::string longestPalindrome(std::string s) {
       int n = s.length(), maxLen = 1, start = 0;
       for (int i = 0; i < n; i++) {
           for (int j = i; j < n; j++) {
               bool isPal = true;
               for (int k = i; k <= j; k++) {
                   if (s[k] != s[j - (k - i)]) { isPal = false; break; }
               }
               if (isPal && j - i + 1 > maxLen) {
                   maxLen = j - i + 1;
                   start = i;
               }
           }
       }
       return s.substr(start, maxLen);
   }
   ```
   Pros: Correct. Cons: O(n^3) time.  
   **Optimized**: Expand-around-center.  
   ```cpp
   std::string longestPalindrome(std::string s) {
       int n = s.length(), start = 0, maxLen = 1;
       for (int i = 0; i < n; i++) {
           int left = i, right = i;
           while (left >= 0 && right < n && s[left] == s[right]) {
               if (right - left + 1 > maxLen) {
                   start = left;
                   maxLen = right - left + 1;
               }
               left--; right++;
           }
           left = i; right = i + 1;
           while (left >= 0 && right < n && s[left] == s[right]) {
               if (right - left + 1 > maxLen) {
                   start = left;
                   maxLen = right - left + 1;
               }
               left--; right++;
           }
       }
       return s.substr(start, maxLen);
   }
   ```
   Pros: O(n^2) time, O(1) space. Cons: Quadratic time.

4. **String Compression**  
   **Explanation**: Compress repeated characters.  
   **Brute-Force**: Create new string.  
   ```cpp
   int compress(std::vector<char>& chars) {
       std::string result;
       int count = 1;
       for (int i = 1; i <= chars.size(); i++) {
           if (i < chars.size() && chars[i] == chars[i - 1]) {
               count++;
           } else {
               result += chars[i - 1];
               if (count > 1) result += std::to_string(count);
               count = 1;
           }
       }
       for (int i = 0; i < result.size(); i++) chars[i] = result[i];
       return result.size();
   }
   ```
   Pros: Simple. Cons: O(n) extra space.  
   **Optimized**: In-place compression.  
   ```cpp
   int compress(std::vector<char>& chars) {
       int n = chars.size(), write = 0, count = 1, start = 0;
       for (int i = 1; i <= n; i++) {
           if (i < n && chars[i] == chars[i - 1]) {
               count++;
           } else {
               chars[write++] = chars[start];
               if (count > 1) {
                   std::string num = std::to_string(count);
                   for (char c : num) chars[write++] = c;
               }
               start = i;
               count = 1;
           }
       }
       return write;
   }
   ```
   Pros: O(n) time, O(1) space. Cons: None.