# Hour 7: Sets in STL

**Agenda**: Introduce students to C++ STL `set` and `unordered_set`, building on their understanding of vectors (Hour 1), arrays/deques (Hour 2), strings (Hour 3), stacks (Hour 4), queues (Hour 5), and priority queues (Hour 6). Use real-world analogies and fully commented programs to simplify concepts. Emphasize practical usage, set operations, and preparation for coding interviews.

**Outcome Expected**:  
By the end of this hour, students will:  
- Understand STL `set` (ordered, unique elements) and `unordered_set` (unordered, unique elements).  
- Master set operations (e.g., insert, erase, find).  
- Compare sets with other containers like vectors and priority queues.  
- Write C++ programs using sets with proper syntax and error handling.  
- Be ready to solve LeetCode problems involving set-based algorithms.

## Topics Covered
1. **STL Set: Ordered Unique Elements**  
   - Declaration, initialization, and basic operations.  
   - Underlying structure: Red-black tree.  
   - Real-world analogy: Set as a sorted guest list.  
2. **STL Unordered Set: Unordered Unique Elements**  
   - Declaration, initialization, and hash-based operations.  
   - Underlying structure: Hash table.  
   - Real-world analogy: Unordered set as a club membership list.  
3. **Set Operations**  
   - `insert`, `erase`, `find`, `count`, `size`, `empty`.  
   - Iterating over sets.  
4. **Comparison with Other Containers**  
   - Sets vs. vectors (sorted unique vs. dynamic array).  
   - Sets vs. priority queues (sorted unique vs. heap-based).  

## Detailed Explanation of Topics Covered

### 1. STL Set: Ordered Unique Elements
The STL `set` is a container that stores unique elements in sorted order, implemented using a red-black tree (self-balancing binary search tree). Think of a set as a sorted guest list where duplicates are not allowed, and names are always in alphabetical order.

**Key Features**:  
- **Declaration**: `set<T> s;` (e.g., `set<int>` for sorted integers).  
- **Initialization**: Insert elements to build the set.  
- **Operations**: `insert()`, `erase()`, `find()`, `count()`, `size()`, `empty()`.  
- **Advantages**: O(log n) for insert/erase/find; automatically sorted.  
- **Limitations**: No random access; no duplicate elements.

**Example Program**: Basic set operations.

```cpp
#include <iostream>
#include <set>
using namespace std;

int main() {
    // Declare set
    set<int> guest_list;

    // Insert elements
    guest_list.insert(3); // O(log n)
    guest_list.insert(1);
    guest_list.insert(3); // Duplicate ignored
    guest_list.insert(2);

    // Print size
    cout << "Size: " << guest_list.size() << endl; // Output: 3

    // Print elements (sorted order)
    cout << "Guests: ";
    for (int x : guest_list) {
        cout << x << " "; // Output: 1 2 3
    }
    cout << endl;

    // Find element
    auto it = guest_list.find(2);
    cout << "Find 2: " << (it != guest_list.end() ? "Found" : "Not found") << endl; // Output: Found

    // Erase element
    guest_list.erase(2);
    cout << "After erasing 2, size: " << guest_list.size() << endl; // Output: 2

    // Check if empty
    cout << "Is set empty? " << (guest_list.empty() ? "Yes" : "No") << endl; // Output: No

    return 0;
}
```

**Explanation**:  
- `#include <set>`: Imports the set library.  
- `insert(x)`: Adds element if not present (O(log n)).  
- `erase(x)`: Removes element (O(log n)).  
- `find(x)`: Returns iterator to element or `end()` (O(log n)).  
- Elements are automatically sorted; duplicates are ignored.

### 2. STL Unordered Set: Unordered Unique Elements
The STL `unordered_set` stores unique elements in no particular order, implemented using a hash table. Think of it as a club membership list where only unique members are tracked, and order doesn’t matter.

**Key Features**:  
- **Declaration**: `unordered_set<T> us;` (e.g., `unordered_set<int>`).  
- **Operations**: Similar to `set` but O(1) average case for insert/erase/find.  
- **Advantages**: Faster than `set` for lookups (O(1) average).  
- **Limitations**: No sorting; hash collisions may degrade performance to O(n).

**Example Program**: Unordered set operations.

```cpp
#include <iostream>
#include <unordered_set>
using namespace std;

int main() {
    // Declare unordered set
    unordered_set<int> members;

    // Insert elements
    members.insert(3);
    members.insert(1);
    members.insert(3); // Duplicate ignored

    // Print size
    cout << "Size: " << members.size() << endl; // Output: 2

    // Print elements (order not guaranteed)
    cout << "Members: ";
    for (int x : members) {
        cout << x << " "; // Output: e.g., 1 3 or 3 1
    }
    cout << endl;

    // Check if element exists
    cout << "Is 1 a member? " << (members.count(1) ? "Yes" : "No") << endl; // Output: Yes

    // Erase element
    members.erase(1);
    cout << "After erasing 1, size: " << members.size() << endl; // Output: 1

    return 0;
}
```

**Explanation**:  
- `#include <unordered_set>`: Imports the unordered set library.  
- `count(x)`: Returns 1 if element exists, 0 otherwise (O(1) average).  
- Ideal for fast lookups when order isn’t needed.

### 3. Set Operations
Both `set` and `unordered_set` support key operations for managing unique elements. Iterating over `set` yields sorted order; `unordered_set` yields arbitrary order.

**Key Operations**:  
- `insert(x)`: Adds element if not present.  
- `erase(x)`: Removes element or iterator.  
- `find(x)`: Returns iterator to element or `end()`.  
- `count(x)`: Returns 1 or 0 (since no duplicates).  
- `size()`: Number of elements.  
- `empty()`: Checks if set is empty.

**Example Program**: Comparing set and unordered set.

```cpp
#include <iostream>
#include <set>
#include <unordered_set>
using namespace std;

int main() {
    // Ordered set
    set<int> s;
    s.insert(3); s.insert(1); s.insert(2);
    cout << "Set (sorted): ";
    for (int x : s) {
        cout << x << " "; // Output: 1 2 3
    }
    cout << endl;

    // Unordered set
    unordered_set<int> us;
    us.insert(3); us.insert(1); us.insert(2);
    cout << "Unordered set: ";
    for (int x : us) {
        cout << x << " "; // Output: e.g., 3 1 2
    }
    cout << endl;

    // Find in set
    cout << "Find 2 in set: " << (s.find(2) != s.end() ? "Found" : "Not found") << endl; // Output: Found

    // Count in unordered set
    cout << "Count 2 in unordered set: " << us.count(2) << endl; // Output: 1

    return 0;
}
```

**Explanation**:  
- `set` maintains sorted order; `unordered_set` does not.  
- Use `set` for sorted operations; `unordered_set` for fast lookups.

### 4. Comparison with Other Containers
- **Set vs. Vector**: `set` ensures unique, sorted elements; `vector` allows duplicates and random access (Hour 1).  
- **Set vs. Priority Queue**: `set` allows iteration and deletion of any element; `priority_queue` restricts to top element (Hour 6).

**Example Program**: Set vs. vector for unique elements.

```cpp
#include <iostream>
#include <set>
#include <vector>
using namespace std;

int main() {
    // Using set
    set<int> s;
    s.insert(1); s.insert(1); s.insert(2);
    cout << "Set size: " << s.size() << endl; // Output: 2

    // Using vector
    vector<int> v;
    v.push_back(1); v.push_back(1); v.push_back(2);
    cout << "Vector size: " << v.size() << endl; // Output: 3

    return 0;
}
```

**Explanation**:  
- `set` ignores duplicates; `vector` does not.  
- `set` is ideal for unique element management.

## Points to Remember (Interview Preparation)
1. **Set**: Ordered, unique, O(log n) operations, red-black tree.  
2. **Unordered Set**: Unordered, unique, O(1) average operations, hash table.  
3. **Time Complexities**:  
   - `set`: O(log n) for insert/erase/find.  
   - `unordered_set`: O(1) average, O(n) worst case.  
4. **Use Cases**: Sets for unique sorted data; unordered sets for fast lookups.  
5. **Safety**: Check `find()` result against `end()`; `count()` for `unordered_set`.  
6. **Interview Questions**: Be ready for intersection, duplicate detection, or unique element problems.  
7. **Common Errors**: Avoid assuming order in `unordered_set`; no direct indexing in sets.