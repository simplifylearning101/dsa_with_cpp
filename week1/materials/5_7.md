# Hour 5 Additional LeetCode Problems: Queue Solutions

This document provides detailed solutions for four LeetCode problems recommended in `5_2.md`: **LeetCode 622: Design Circular Queue**, **LeetCode 346: Moving Average from Data Stream**, **LeetCode 933: Number of Recent Calls**, and **LeetCode 2073: Time Needed to Buy Tickets**. Each solution includes a problem description, coding pattern, optimized solution with commented C++ code using STL `queue` or related structures, time and space complexity analysis, and test cases covering typical and edge cases.

## Agenda
- Provide optimized solutions for four queue-based LeetCode problems.
- Explain coding patterns (e.g., circular queue, sliding window, simulation).
- Analyze time and space complexities.
- Include test cases to ensure robustness.

## Outcome Expected
Students will:
- Master queue usage for problems like circular buffers and stream processing.
- Apply sliding window and simulation techniques with queues.
- Handle edge cases and optimize for interviews.
- Gain confidence in solving queue-based LeetCode problems.

---

## 1. LeetCode 622: Design Circular Queue (Medium)

**Link**: [LeetCode 622](https://leetcode.com/problems/design-circular-queue/)

**Description**:  
Design a circular queue with methods `enQueue`, `deQueue`, `Front`, `Rear`, `isEmpty`, `isFull`. The queue has a fixed size `k`.

**Constraints**:
- `1 <= k <= 1000`
- `0 <= value <= 1000`
- At most 3000 calls to methods.

**Example**:
- Input: `["MyCircularQueue","enQueue","enQueue","enQueue","enQueue","Rear","isFull","deQueue","enQueue","Rear"]`, `[[3],[1],[2],[3],[4],[],[],[],[4],[]]`  
  Output: `[null,true,true,true,false,3,true,true,true,4]`  
  Explanation: Queue of size 3; fourth enQueue fails.

**Coding Pattern**: Circular Queue with Array  
- Use a vector with front/rear pointers and size tracking.  
- Wrap around indices using modulo for circular behavior.

**Optimized Solution**:
```cpp
#include <vector>
using namespace std;

class MyCircularQueue {
private:
    vector<int> data;
    int front, rear, size, capacity;
public:
    MyCircularQueue(int k) : capacity(k), size(0), front(0), rear(-1), data(k) {}
    
    bool enQueue(int value) {
        if (isFull()) return false;
        rear = (rear + 1) % capacity;
        data[rear] = value;
        size++;
        return true;
    }
    
    bool deQueue() {
        if (isEmpty()) return false;
        front = (front + 1) % capacity;
        size--;
        return true;
    }
    
    int Front() {
        return isEmpty() ? -1 : data[front];
    }
    
    int Rear() {
        return isEmpty() ? -1 : data[rear];
    }
    
    bool isEmpty() {
        return size == 0;
    }
    
    bool isFull() {
        return size == capacity;
    }
};
```

**Time Complexity**: O(1) per operation  
- All operations use direct index access and modulo.

**Space Complexity**: O(k)  
- Vector of size k stores the queue.

**Explanation**:
- `front` and `rear` track queue boundaries; `size` tracks element count.  
- Modulo ensures wrap-around for circular behavior.  
- Avoids resizing by using fixed-size vector.

**Test Cases**:
1. **Typical Case**: `enQueue(1,2,3), Rear, isFull, deQueue, enQueue(4), Rear` → Output: `[3,true,true,4]`  
2. **Empty Queue**: `isEmpty` → Output: `[true]`  
3. **Full Queue**: `enQueue(1,2,3), enQueue(4)` → Output: `[false]`  
4. **Single Element**: `enQueue(1), Front, Rear` → Output: `[1,1]`  
5. **Wrap Around**: `enQueue(1,2,3), deQueue, enQueue(4)` → Output: `[true]`  

---

## 2. LeetCode 346: Moving Average from Data Stream (Easy)

**Link**: [LeetCode 346](https://leetcode.com/problems/moving-average-from-data-stream/)

**Description**:  
Given a stream of integers and a window size `size`, calculate the moving average of the last `size` numbers.

**Constraints**:
- `1 <= size <= 1000`
- `-10^5 <= val <= 10^5`
- At most 10^4 calls to `next`.

**Example**:
- Input: `["MovingAverage","next","next","next","next"]`, `[[3],[1],[10],[3],[5]]`  
  Output: `[null,1.0,5.5,4.66667,6.0]`  
  Explanation: Averages for windows [1], [1,10], [1,10,3], [10,3,5].

**Coding Pattern**: Sliding Window with Queue  
- Use a queue to store the last `size` elements.  
- Maintain a sum for efficient average calculation.  
- Remove oldest element when window size is exceeded.

**Optimized Solution**:
```cpp
#include <queue>
using namespace std;

class MovingAverage {
private:
    queue<int> q;
    int size;
    double sum;
public:
    MovingAverage(int size) : size(size), sum(0) {}
    
    double next(int val) {
        q.push(val);
        sum += val;
        // Remove oldest if window exceeded
        if (q.size() > size) {
            sum -= q.front();
            q.pop();
        }
        return sum / min((int)q.size(), size);
    }
};
```

**Time Complexity**: O(1) amortized per `next`  
- Push/pop are O(1); each element is processed once.

**Space Complexity**: O(size)  
- Queue stores up to `size` elements.

**Explanation**:
- Queue maintains the sliding window; `sum` tracks total for efficiency.  
- When window size is exceeded, remove oldest element and update sum.  
- Average is computed in O(1) using current sum and window size.

**Test Cases**:
1. **Typical Case**: `next(1,10,3,5), size=3` → Output: `[1.0,5.5,4.66667,6.0]`  
2. **Single Element**: `next(1), size=1` → Output: `[1.0]`  
3. **Window Not Full**: `next(1,2), size=3` → Output: `[1.0,1.5]`  
4. **Large Values**: `next(10000,-10000), size=2` → Output: `[10000.0,0.0]`  
5. **Full Window**: `next(1,2,3,4), size=3` → Output: `[1.0,1.5,2.0,3.0]`  

---

## 3. LeetCode 933: Number of Recent Calls (Easy)

**Link**: [LeetCode 933](https://leetcode.com/problems/number-of-recent-calls/)

**Description**:  
Implement a class to track requests within the last 3000 milliseconds. Return the number of requests in `[t-3000, t]` for each call to `ping(t)`.

**Constraints**:
- `1 <= t <= 10^9`
- Each `t` is strictly increasing.
- At most 10^4 calls to `ping`.

**Example**:
- Input: `["RecentCounter","ping","ping","ping","ping"]`, `[[],[1],[100],[3001],[3002]]`  
  Output: `[null,1,2,3,3]`  
  Explanation: Requests in [1,1], [1,100], [1,3001], [100,3002].

**Coding Pattern**: Sliding Window with Queue  
- Use a queue to store timestamps in the last 3000ms.  
- Remove timestamps outside the window `[t-3000, t]`.  
- Return queue size as the number of recent requests.

**Optimized Solution**:
```cpp
#include <queue>
using namespace std;

class RecentCounter {
private:
    queue<int> q; // Stores timestamps
public:
    RecentCounter() {}
    
    int ping(int t) {
        q.push(t);
        // Remove timestamps outside [t-3000, t]
        while (!q.empty() && q.front() < t - 3000) {
            q.pop();
        }
        return q.size();
    }
};
```

**Time Complexity**: O(1) amortized per `ping`  
- Each timestamp is pushed and popped at most once.

**Space Complexity**: O(n)  
- Queue stores timestamps within 3000ms (up to number of pings).

**Explanation**:
- Queue stores timestamps in increasing order (since `t` is increasing).  
- Remove timestamps older than `t-3000` to maintain the window.  
- Queue size is the number of valid requests.

**Test Cases**:
1. **Typical Case**: `ping(1,100,3001,3002)` → Output: `[1,2,3,3]`  
2. **Single Ping**: `ping(1)` → Output: `[1]`  
3. **No Overlap**: `ping(1,4000)` → Output: `[1,1]`  
4. **Dense Pings**: `ping(1,2,3)` → Output: `[1,2,3]`  
5. **Large Gap**: `ping(1,10000)` → Output: `[1,1]`  

---

## 4. LeetCode 2073: Time Needed to Buy Tickets (Easy)

**Link**: [LeetCode 2073](https://leetcode.com/problems/time-needed-to-buy-tickets/)

**Description**:  
Given an array `tickets` where `tickets[i]` is the number of tickets person `i` wants, and an integer `k`, return the time (in seconds) for person `k` to finish buying tickets. Each person takes 1 second per ticket, and people buy in order, looping back if they need more tickets.

**Constraints**:
- `1 <= tickets.length <= 100`
- `1 <= tickets[i] <= 100`
- `0 <= k < tickets.length`

**Example**:
- Input: `tickets = [2,3,2], k = 2`  
  Output: `6`  
  Explanation: Person 0 buys 2 tickets (2s), person 1 buys 3 tickets (3s), person 2 buys 1 ticket (1s, done). Total for person 2: 6s.

**Coding Pattern**: Queue Simulation  
- Use a queue to simulate the ticket-buying process.  
- Process each person, decrement their tickets, and re-queue if needed.  
- Track time until person `k` has no tickets left.

**Optimized Solution**:
```cpp
#include <queue>
#include <vector>
using namespace std;

class Solution {
public:
    int timeRequiredToBuy(vector<int>& tickets, int k) {
        queue<pair<int, int>> q; // {tickets, index}
        int time = 0;
        
        // Initialize queue
        for (int i = 0; i < tickets.size(); ++i) {
            q.push({tickets[i], i});
        }
        
        // Process until person k is done
        while (!q.empty()) {
            auto [t, idx] = q.front();
            q.pop();
            time++;
            t--;
            if (t > 0) {
                q.push({t, idx}); // Re-queue if tickets remain
            }
            if (idx == k && t == 0) {
                break; // Person k is done
            }
        }
        
        return time;
    }
};
```

**Time Complexity**: O(m)  
- Where m is the total number of tickets across all people (each ticket takes 1 second).

**Space Complexity**: O(n)  
- Queue stores up to n people.

**Explanation**:
- Queue simulates FIFO order of ticket buying.  
- Each person buys one ticket per second; re-queue if they have more tickets.  
- Stop when person `k` has no tickets left.

**Test Cases**:
1. **Typical Case**: `tickets = [2,3,2], k = 2` → Output: `6`  
2. **Single Person**: `tickets = [5], k = 0` → Output: `5`  
3. **k at Front**: `tickets = [2,3,2], k = 0` → Output: `2`  
4. **All Same**: `tickets = [1,1,1], k = 1` → Output: `2`  
5. **Large Tickets**: `tickets = [5,5,5], k = 2` → Output: `15`  

---

## Test Case Implementation
Below is a program to test all four solutions with the provided test cases.

```cpp
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

// LeetCode 622: Design Circular Queue
class MyCircularQueue {
private:
    vector<int> data;
    int front, rear, size, capacity;
public:
    MyCircularQueue(int k) : capacity(k), size(0), front(0), rear(-1), data(k) {}
    bool enQueue(int value) {
        if (isFull()) return false;
        rear = (rear + 1) % capacity;
        data[rear] = value;
        size++;
        return true;
    }
    bool deQueue() {
        if (isEmpty()) return false;
        front = (front + 1) % capacity;
        size--;
        return true;
    }
    int Front() { return isEmpty() ? -1 : data[front]; }
    int Rear() { return isEmpty() ? -1 : data[rear]; }
    bool isEmpty() { return size == 0; }
    bool isFull() { return size == capacity; }
};

// LeetCode 346: Moving Average
class MovingAverage {
private:
    queue<int> q;
    int size;
    double sum;
public:
    MovingAverage(int size) : size(size), sum(0) {}
    double next(int val) {
        q.push(val);
        sum += val;
        if (q.size() > size) {
            sum -= q.front();
            q.pop();
        }
        return sum / min((int)q.size(), size);
    }
};

// LeetCode 933: Number of Recent Calls
class RecentCounter {
private:
    queue<int> q;
public:
    RecentCounter() {}
    int ping(int t) {
        q.push(t);
        while (!q.empty() && q.front() < t - 3000) {
            q.pop();
        }
        return q.size();
    }
};

// LeetCode 2073: Time Needed to Buy Tickets
int timeRequiredToBuy(vector<int>& tickets, int k) {
    queue<pair<int, int>> q;
    int time = 0;
    for (int i = 0; i < tickets.size(); ++i) {
        q.push({tickets[i], i});
    }
    while (!q.empty()) {
        auto [t, idx] = q.front();
        q.pop();
        time++;
        t--;
        if (t > 0) {
            q.push({t, idx});
        }
        if (idx == k && t == 0) {
            break;
        }
    }
    return time;
}

// Helper function to print vector
void printVector(const vector<int>& v) {
    cout << "[";
    for (size_t i = 0; i < v.size(); ++i) {
        cout << v[i];
        if (i < v.size() - 1) cout << ",";
    }
    cout << "]" << endl;
}

int main() {
    // Test LeetCode 622
    cout << "LeetCode 622: Design Circular Queue\n";
    MyCircularQueue cq(3);
    cq.enQueue(1); cq.enQueue(2); cq.enQueue(3);
    cout << "Test 1: Rear = " << cq.Rear() << ", isFull = " << (cq.isFull() ? "true" : "false") << endl; // 3, true
    cq.deQueue(); cq.enQueue(4);
    cout << "After deQueue/enQueue, Rear = " << cq.Rear() << endl; // 4

    // Test LeetCode 346
    cout << "\nLeetCode 346: Moving Average\n";
    MovingAverage ma(3);
    cout << "Test 1: " << ma.next(1) << ", " << ma.next(10) << ", " << ma.next(3) << ", " << ma.next(5) << endl; // 1.0, 5.5, 4.66667, 6.0

    // Test LeetCode 933
    cout << "\nLeetCode 933: Number of Recent Calls\n";
    RecentCounter rc;
    cout << "Test 1: " << rc.ping(1) << ", " << rc.ping(100) << ", " << rc.ping(3001) << ", " << rc.ping(3002) << endl; // 1, 2, 3, 3

    // Test LeetCode 2073
    cout << "\nLeetCode 2073: Time Needed to Buy Tickets\n";
    vector<int> tickets = {2, 3, 2};
    cout << "Test 1: " << timeRequiredToBuy(tickets, 2) << endl; // 6

    return 0;
}
```

**Output**:
```
LeetCode 622: Design Circular Queue
Test 1: Rear = 3, isFull = true
After deQueue/enQueue, Rear = 4

LeetCode 346: Moving Average
Test 1: 1, 5.5, 4.66667, 6

LeetCode 933: Number of Recent Calls
Test 1: 1, 2, 3, 3

LeetCode 2073: Time Needed to Buy Tickets
Test 1: 6
```

## Key Takeaways
- **Circular Queue**: LeetCode 622 uses array-based circular buffer for efficient FIFO.  
- **Sliding Window**: LeetCode 346 and 933 use queues for stream processing.  
- **Simulation**: LeetCode 2073 simulates queue-based processing with constraints.  
- **Edge Cases**: Handle empty queues, full queues, and single-element cases.  
- **Optimization**: Use O(1) operations where possible; deque for sliding windows.

These solutions reinforce queue manipulation skills, preparing students for interview scenarios with advanced queue applications.