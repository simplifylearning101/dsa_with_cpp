# Solutions for Leetcode Problems

1. **String Compression**  
   **Explanation:** Compress repeated characters in-place.  
   **Brute-Force:** Create new string.  
   ```cpp
   int compress(vector<char>& chars) {
       string result;
       int count = 1;
       for (int i = 1; i <= chars.size(); i++) {
           if (i < chars.size() && chars[i] == chars[i - 1]) {
               count++;
           } else {
               result += chars[i - 1];
               if (count > 1) result += to_string(count);
               count = 1;
           }
       }
       for (int i = 0; i < result.size(); i++) chars[i] = result[i];
       return result.size();
   }
   ```
   Pros: Simple. Cons: O(n) extra space.  
   **Optimized:** In-place compression.  
   ```cpp
   int compress(vector<char>& chars) {
       int n = chars.size(), write = 0, count = 1, start = 0;
       for (int i = 1; i <= n; i++) {
           if (i < n && chars[i] == chars[i - 1]) {
               count++;
           } else {
               chars[write++] = chars[start];
               if (count > 1) {
                   string num = to_string(count);
                   for (char c : num) chars[write++] = c;
               }
               start = i;
               count = 1;
           }
       }
       return write;
   }
   ```
   Pros: O(n) time, O(1) space. Cons: None.

2. **Edit Distance**  
   **Explanation:** Compute minimum operations to transform strings.  
   **Brute-Force:** Recursive approach.  
   ```cpp
   int minDistance(string word1, string word2) {
       if (word1.empty()) return word2.length();
       if (word2.empty()) return word1.length();
       if (word1[0] == word2[0]) return minDistance(word1.substr(1), word2.substr(1));
       return 1 + min({minDistance(word1.substr(1), word2), 
                       minDistance(word1, word2.substr(1)), 
                       minDistance(word1.substr(1), word2.substr(1))});
   }
   ```
   Pros: Intuitive. Cons: O(3^(m+n)) time.  
   **Optimized:** Dynamic programming.  
   ```cpp
   int minDistance(string word1, string word2) {
       int m = word1.length(), n = word2.length();
       vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
       for (int i = 0; i <= m; i++) dp[i][0] = i;
       for (int j = 0; j <= n; j++) dp[0][j] = j;
       for (int i = 1; i <= m; i++) {
           for (int j = 1; j <= n; j++) {
               if (word1[i - 1] == word2[j - 1]) dp[i][j] = dp[i - 1][j - 1];
               else dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;
           }
       }
       return dp[m][n];
   }
   ```
   Pros: O(m*n) time, O(m*n) space. Cons: Extra space.

3. **Regular Expression Matching**  
   **Explanation:** Match string with pattern ('.' and '*').  
   **Brute-Force:** Recursive approach.  
   ```cpp
   bool isMatch(string s, string p) {
       if (p.empty()) return s.empty();
       bool firstMatch = !s.empty() && (p[0] == s[0] || p[0] == '.');
       if (p.length() >= 2 && p[1] == '*') {
           return isMatch(s, p.substr(2)) || (firstMatch && isMatch(s.substr(1), p));
       }
       return firstMatch && isMatch(s.substr(1), p.substr(1));
   }
   ```
   Pros: Simple. Cons: O(2^(m+n)) time.  
   **Optimized:** Dynamic programming.  
   ```cpp
   bool isMatch(string s, string p) {
       int m = s.length(), n = p.length();
       vector<vector<bool>> dp(m + 1, vector<bool>(n + 1, false));
       dp[0][0] = true;
       for (int j = 1; j <= n; j++) {
           if (p[j - 1] == '*') dp[0][j] = dp[0][j - 2];
       }
       for (int i = 1; i <= m; i++) {
           for (int j = 1; j <= n; j++) {
               if (p[j - 1] == '*') {
                   dp[i][j] = dp[i][j - 2] || (dp[i - 1][j] && (s[i - 1] == p[j - 2] || p[j - 2] == '.'));
               } else if (p[j - 1] == '.' || s[i - 1] == p[j - 1]) {
                   dp[i][j] = dp[i - 1][j - 1];
               }
           }
       }
       return dp[m][n];
   }
   ```
   Pros: O(m*n) time, O(m*n) space. Cons: Extra space.

4. **Longest Valid Parentheses**  
   **Explanation:** Find longest valid parentheses substring.  
   **Brute-Force:** Check all substrings.  
   ```cpp
   int longestValidParentheses(string s) {
       int maxLen = 0;
       for (int i = 0; i < s.length(); i++) {
           for (int j = i + 1; j < s.length(); j += 2) {
               stack<char> st;
               bool valid = true;
               for (int k = i; k <= j; k++) {
                   if (s[k] == '(') st.push('(');
                   else if (!st.empty()) st.pop();
                   else { valid = false; break; }
               }
               if (valid && st.empty()) maxLen = max(maxLen, j - i + 1);
           }
       }
       return maxLen;
   }
   ```
   Pros: Correct. Cons: O(n^3) time.  
   **Optimized:** Stack-based approach.  
   ```cpp
   int longestValidParentheses(string s) {
       stack<int> stack;
       stack.push(-1);
       int maxLen = 0;
       for (int i = 0; i < s.length(); i++) {
           if (s[i] == '(') {
               stack.push(i);
           } else {
               stack.pop();
               if (stack.empty()) {
                   stack.push(i);
               } else {
                   maxLen = max(maxLen, i - stack.top());
               }
           }
       }
       return maxLen;
   }
   ```
   Pros: O(n) time, O(n) space. Cons: Extra space.

5. **First Unique Character**  
   **Explanation:** Find index of first non-repeating character.  
   **Brute-Force:** Check each characterâ€™s frequency.  
   ```cpp
   int firstUniqChar(string s) {
       for (int i = 0; i < s.length(); i++) {
           bool unique = true;
           for (int j = 0; j < s.length(); j++) {
               if (i != j && s[i] == s[j]) {
                   unique = false;
                   break;
               }
           }
           if (unique) return i;
       }
       return -1;
   }
   ```
   Pros: Simple. Cons: O(n^2) time.  
   **Optimized:** Frequency array.  
   ```cpp
   int firstUniqChar(string s) {
       int count[26] = {0};
       for (char c : s) count[c - 'a']++;
       for (int i = 0; i < s.length(); i++) {
           if (count[s[i] - 'a'] == 1) return i;
       }
       return -1;
   }
   ```
   Pros: O(n) time, O(1) space. Cons: Limited to lowercase letters.