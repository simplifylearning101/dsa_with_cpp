# Hour 11 Additional LeetCode Problems: Unordered Map and Multimap Solutions

This document provides detailed solutions for three LeetCode problems recommended in `11_2.md`: **LeetCode 560: Subarray Sum Equals K**, **LeetCode 146: LRU Cache**, and **LeetCode 205: Isomorphic Strings**. Each solution includes a problem description, coding pattern, optimized solution with commented C++ code using STL `unordered_map` or `unordered_multimap`, time and space complexity analysis, and test cases.

## Agenda
- Provide optimized solutions for three `unordered_map`/`unordered_multimap`-based LeetCode problems.
- Explain coding patterns (e.g., prefix sums, caching, character mapping).
- Analyze time and space complexities.
- Include test cases to ensure robustness.

## Outcome Expected
Students will:
- Master `unordered_map`/`unordered_multimap` usage for prefix sums, caching, and string mapping.  
- Apply techniques for array and string processing.  
- Handle edge cases and optimize for interviews.

---

## 1. LeetCode 560: Subarray Sum Equals K (Medium)

**Link**: [LeetCode 560](https://leetcode.com/problems/subarray-sum-equals-k/)

**Description**:  
Given an array of integers `nums` and an integer `k`, return the total number of continuous subarrays whose sum equals `k`.

**Constraints**:
- `1 <= nums.length <= 2 * 10^4`
- `-1000 <= nums[i] <= 1000`
- `-10^7 <= k <= 10^7`

**Example**:
- Input: `nums = [1,1,1], k = 2`  
  Output: `2`  
  Explanation: Subarrays `[1,1]` at indices [0,1] and [1,2] sum to 2.

**Coding Pattern**: Unordered Map for Prefix Sums  
- Use `unordered_map` to store prefix sums and their frequencies.  
- For each index, compute cumulative sum and check if `sum - k` exists in the map.  
- Increment count by frequency of `sum - k`.

**Optimized Solution**:
```cpp
#include <unordered_map>
#include <vector>
using namespace std;

class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        unordered_map<long long, int> prefix_sums;  // sum -> frequency
        long long sum = 0;
        int count = 0;
        prefix_sums[0] = 1;  // Empty subarray sum
        for (int num : nums) {
            sum += num;
            if (prefix_sums.find(sum - k) != prefix_sums.end()) {
                count += prefix_sums[sum - k];
            }
            prefix_sums[sum]++;
        }
        return count;
    }
};
```

**Time Complexity**: O(n)  
- Single pass with O(1) average map operations.

**Space Complexity**: O(n)  
- Stores prefix sums.

**Explanation**:  
- `unordered_map` tracks cumulative sums.  
- `sum - k` in map indicates a subarray with sum `k`.

**Test Cases**:
1. **Typical Case**: `nums = [1,1,1], k = 2` → Output: `2`  
2. **Negative Numbers**: `nums = [1,-1,0], k = 0` → Output: `2`  
3. **Single Element**: `nums = [1], k = 1` → Output: `1`  
4. **No Subarray**: `nums = [1,2,3], k = 10` → Output: `0`  
5. **All Zeros**: `nums = [0,0], k = 0` → Output: `3`  

---

## 2. LeetCode 146: LRU Cache (Medium)

**Link**: [LeetCode 146](https://leetcode.com/problems/lru-cache/)

**Description**:  
Design a data structure that follows the constraints of a Least Recently Used (LRU) cache. Implement the `LRUCache` class with `get(key)` and `put(key, value)` operations. If capacity is reached, remove the least recently used item.

**Constraints**:
- `1 <= capacity <= 3000`
- `0 <= key, value <= 10^4`
- At most `2 * 10^5` calls to `get` and `put`.

**Example**:
- Input: `["LRUCache","put","put","get","put","get","put","get","get","get"]`, `[[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]]`  
  Output: `[null,null,null,1,null,-1,null,1,3,4]`  
  Explanation: Cache operations update recency and evict LRU items.

**Coding Pattern**: Unordered Map + Doubly Linked List  
- Use `unordered_map` for O(1) key-to-node lookups.  
- Use doubly linked list for O(1) insertion/deletion of LRU items.  
- Maintain head/tail pointers for quick updates.

**Optimized Solution**:
```cpp
#include <unordered_map>
#include <list>
using namespace std;

class LRUCache {
    int capacity;
    list<pair<int, int>> cache;  // key-value pairs in order of use
    unordered_map<int, list<pair<int, int>>::iterator> key_map;  // key -> iterator

public:
    LRUCache(int capacity) : capacity(capacity) {}
    
    int get(int key) {
        auto it = key_map.find(key);
        if (it == key_map.end()) return -1;
        // Move to front (most recently used)
        cache.splice(cache.begin(), cache, it->second);
        return it->second->second;
    }
    
    void put(int key, int value) {
        auto it = key_map.find(key);
        if (it != key_map.end()) {
            // Update existing key
            cache.splice(cache.begin(), cache, it->second);
            it->second->second = value;
            return;
        }
        // Add new key-value pair
        cache.push_front({key, value});
        key_map[key] = cache.begin();
        if (cache.size() > capacity) {
            // Remove least recently used
            key_map.erase(cache.back().first);
            cache.pop_back();
        }
    }
};
```

**Time Complexity**: O(1)  
- `get` and `put` use O(1) map and list operations.

**Space Complexity**: O(capacity)  
- Stores up to `capacity` key-value pairs.

**Explanation**:  
- `unordered_map` provides O(1) key lookups.  
- Doubly linked list (`list`) maintains LRU order.

**Test Cases**:
1. **Typical Case**: `["LRUCache","put","put","get","put","get"]`, `[[2],[1,1],[2,2],[1],[3,3],[2]]` → Output: `[null,null,null,1,null,-1]`  
2. **Single Capacity**: `["LRUCache","put","get"]`, `[[1],[1,1],[1]]` → Output: `[null,null,1]`  
3. **Eviction**: `["LRUCache","put","put","put"]`, `[[1],[1,1],[2,2],[1,3]]` → Output: `[null,null,null,null]`  
4. **Missed Get**: `["LRUCache","get"]`, `[[1],[1]]` → Output: `[null,-1]`  
5. **Full Capacity**: `["LRUCache","put","put","get","put"]`, `[[2],[1,1],[2,2],[1],[3,3]]` → Output: `[null,null,null,1,null]`  

---

## 3. LeetCode 205: Isomorphic Strings (Easy)

**Link**: [LeetCode 205](https://leetcode.com/problems/isomorphic-strings/)

**Description**:  
Given two strings `s` and `t`, determine if they are isomorphic. Two strings are isomorphic if the characters in `s` can be replaced to get `t`, maintaining order and a one-to-one mapping.

**Constraints**:
- `1 <= s.length <= 5 * 10^4`
- `s` and `t` consist of any valid ASCII characters.

**Example**:
- Input: `s = "egg", t = "add"`  
  Output: `true`  
  Explanation: `e->a`, `g->d` forms a valid mapping.

**Coding Pattern**: Unordered Map for Character Mapping  
- Use `unordered_map` to store character mappings from `s` to `t`.  
- Use another `unordered_map` to ensure one-to-one mapping.  
- Check if mappings are consistent.

**Optimized Solution**:
```cpp
#include <unordered_map>
#include <string>
using namespace std;

class Solution {
public:
    bool isIsomorphic(string s, string t) {
        if (s.length() != t.length()) return false;
        unordered_map<char, char> s_to_t;
        unordered_map<char, char> t_to_s;
        for (int i = 0; i < s.length(); ++i) {
            if (s_to_t.find(s[i]) == s_to_t.end() && t_to_s.find(t[i]) == t_to_s.end()) {
                s_to_t[s[i]] = t[i];
                t_to_s[t[i]] = s[i];
            } else if (s_to_t[s[i]] != t[i] || t_to_s[t[i]] != s[i]) {
                return false;
            }
        }
        return true;
    }
};
```

**Time Complexity**: O(n)  
- Single pass with O(1) average map operations.

**Space Complexity**: O(n)  
- Stores character mappings.

**Explanation**:  
- Two maps ensure one-to-one mapping.  
- Early check for length mismatch.

**Test Cases**:
1. **Typical Case**: `s = "egg", t = "add"` → Output: `true`  
2. **Non-Isomorphic**: `s = "foo", t = "bar"` → Output: `false`  
3. **Single Character**: `s = "a", t = "b"` → Output: `true`  
4. **Different Lengths**: `s = "ab", t = "a"` → Output: `false`  
5. **Complex Mapping**: `s = "paper", t = "title"` → Output: `true`  

---

## Test Case Implementation
Below is a program to test all three solutions with the provided test cases.

```cpp
#include <iostream>
#include <unordered_map>
#include <vector>
#include <string>
#include <list>
using namespace std;

// LeetCode 560: Subarray Sum Equals K
int subarraySum(vector<int>& nums, int k) {
    unordered_map<long long, int> prefix_sums;
    long long sum = 0;
    int count = 0;
    prefix_sums[0] = 1;
    for (int num : nums) {
        sum += num;
        if (prefix_sums.find(sum - k) != prefix_sums.end()) {
            count += prefix_sums[sum - k];
        }
        prefix_sums[sum]++;
    }
    return count;
}

// LeetCode 146: LRU Cache
class LRUCache {
    int capacity;
    list<pair<int, int>> cache;
    unordered_map<int, list<pair<int, int>>::iterator> key_map;
public:
    LRUCache(int capacity) : capacity(capacity) {}
    int get(int key) {
        auto it = key_map.find(key);
        if (it == key_map.end()) return -1;
        cache.splice(cache.begin(), cache, it->second);
        return it->second->second;
    }
    void put(int key, int value) {
        auto it = key_map.find(key);
        if (it != key_map.end()) {
            cache.splice(cache.begin(), cache, it->second);
            it->second->second = value;
            return;
        }
        cache.push_front({key, value});
        key_map[key] = cache.begin();
        if (cache.size() > capacity) {
            key_map.erase(cache.back().first);
            cache.pop_back();
        }
    }
};

// LeetCode 205: Isomorphic Strings
bool isIsomorphic(string s, string t) {
    if (s.length() != t.length()) return false;
    unordered_map<char, char> s_to_t;
    unordered_map<char, char> t_to_s;
    for (int i = 0; i < s.length(); ++i) {
        if (s_to_t.find(s[i]) == s_to_t.end() && t_to_s.find(t[i]) == t_to_s.end()) {
            s_to_t[s[i]] = t[i];
            t_to_s[t[i]] = s[i];
        } else if (s_to_t[s[i]] != t[i] || t_to_s[t[i]] != s[i]) {
            return false;
        }
    }
    return true;
}

int main() {
    // Test LeetCode 560
    cout << "LeetCode 560: Subarray Sum Equals K\n";
    vector<int> nums_560 = {1, 1, 1};
    cout << "Test 1: " << subarraySum(nums_560, 2) << endl;  // 2

    // Test LeetCode 146
    cout << "\nLeetCode 146: LRU Cache\n";
    LRUCache cache(2);
    cache.put(1, 1);
    cache.put(2, 2);
    cout << "Test 1: " << cache.get(1) << endl;  // 1
    cache.put(3, 3);
    cout << "Test 2: " << cache.get(2) << endl;  // -1

    // Test LeetCode 205
    cout << "\nLeetCode 205: Isomorphic Strings\n";
    string s_205 = "egg", t_205 = "add";
    cout << "Test 1: " << (isIsomorphic(s_205, t_205) ? "true" : "false") << endl;  // true

    return 0;
}
```

**Output**:
```
LeetCode 560: Subarray Sum Equals K
Test 1: 2

LeetCode 146: LRU Cache
Test 1: 1
Test 2: -1

LeetCode 205: Isomorphic Strings
Test 1: true
```

## Key Takeaways
- **Prefix Sums**: `unordered_map` excels at tracking sums for subarray problems.  
- **Caching**: Combine `unordered_map` with a list for O(1) LRU operations.  
- **String Mapping**: Use `unordered_map` for one-to-one character mappings.