# Hour 5: Queues in STL

**Agenda**: Introduce students to C++ STL `queue`, building on their understanding of vectors (Hour 1), arrays/deques (Hour 2), strings (Hour 3), and stacks (Hour 4). Use real-world analogies and fully commented programs to simplify concepts. Emphasize practical usage, queue operations, and preparation for coding interviews.

**Outcome Expected**:  
By the end of this hour, students will:  
- Understand STL `queue` as a First-In-First-Out (FIFO) container.  
- Master queue operations (e.g., push, pop, front, back).  
- Compare queues with stacks and deques for specific use cases.  
- Write C++ programs using queues with proper syntax and error handling.  
- Be ready to solve LeetCode problems involving queue-based algorithms.

## Topics Covered
1. **STL Queue: FIFO Container**  
   - Declaration, initialization, and basic operations.  
   - Underlying container (default: deque).  
   - Real-world analogy: Queue as a line at a ticket counter.  
2. **Queue Operations**  
   - `push`, `pop`, `front`, `back`, `empty`, `size`.  
   - Handling empty queue scenarios.  
   - Real-world analogy: People joining/leaving a queue.  
3. **Comparison with Other Containers**  
   - Queues vs. stacks (FIFO vs. LIFO).  
   - Queues vs. deques (restricted vs. flexible access).  

## Detailed Explanation of Topics Covered

### 1. STL Queue: FIFO Container
The STL `queue` is a container adapter that follows the First-In-First-Out (FIFO) principle, where the first element added is the first to be removed. It’s built on top of an underlying container (default: `deque`, but can be `list`). Think of a queue as a line at a ticket counter: the first person in line is served first.

**Key Features**:  
- **Declaration**: `queue<T> q;` (e.g., `queue<int>`).  
- **Initialization**: Push elements to build the queue.  
- **Operations**: `push()`, `pop()`, `front()`, `back()`, `empty()`, `size()`.  
- **Advantages**: Simple FIFO interface, O(1) operations for push/pop/front/back.  
- **Limitations**: No direct access to middle elements; no iterators.

**Example Program**: Basic queue operations.

```cpp
#include <iostream>
#include <queue> // Include queue library
using namespace std;

int main() {
    // Declare queue
    queue<int> ticket_line;

    // Push elements (people join queue)
    ticket_line.push(1); // Front
    ticket_line.push(2);
    ticket_line.push(3); // Back

    // Print size
    cout << "Size: " << ticket_line.size() << endl; // Output: 3

    // Access front and back
    cout << "Front: " << ticket_line.front() << endl; // Output: 1
    cout << "Back: " << ticket_line.back() << endl; // Output: 3

    // Pop front element
    ticket_line.pop();
    cout << "After pop, front: " << ticket_line.front() << endl; // Output: 2

    // Check if empty
    cout << "Is queue empty? " << (ticket_line.empty() ? "Yes" : "No") << endl; // Output: No

    // Handle empty queue
    queue<int> empty_queue;
    cout << "Is empty_queue empty? " << (empty_queue.empty() ? "Yes" : "No") << endl; // Output: Yes

    return 0;
}
```

**Explanation**:  
- `#include <queue>`: Imports the queue library.  
- `push(x)`: Adds element to back (O(1)).  
- `pop()`: Removes front element (O(1)).  
- `front()`: Returns front element (O(1)).  
- `back()`: Returns back element (O(1)).  
- `empty()`: Checks if queue is empty.

### 2. Queue Operations
STL `queue` provides a minimal, efficient interface for FIFO operations. Imagine a queue at a ticket counter where people join at the back and leave from the front.

**Key Operations**:  
- `push(x)`: Adds element `x` to back.  
- `pop()`: Removes front element (no return value).  
- `front()`: Returns reference to front element.  
- `back()`: Returns reference to back element.  
- `empty()`: Returns `true` if queue is empty.  
- `size()`: Returns number of elements.

**Example Program**: Queue-based task scheduling.

```cpp
#include <iostream>
#include <queue>
#include <string>
using namespace std;

void processTasks(const vector<string>& tasks) {
    queue<string> task_queue;
    // Add tasks to queue
    for (const string& task : tasks) {
        task_queue.push(task);
    }
    
    // Process tasks in order
    while (!task_queue.empty()) {
        cout << "Processing: " << task_queue.front() << endl;
        task_queue.pop();
    }
}

int main() {
    vector<string> tasks = {"Send email", "Write report", "Attend meeting"};
    processTasks(tasks);
    // Output:
    // Processing: Send email
    // Processing: Write report
    // Processing: Attend meeting
    return 0;
}
```

**Explanation**:  
- Queue stores tasks in order of arrival.  
- `front()` retrieves next task; `pop()` removes it.  
- Demonstrates queue’s utility in task scheduling.

### 3. Comparison with Other Containers
- **Queue vs. Stack**: Queue is FIFO; stack is LIFO (Hour 4).  
- **Queue vs. Deque**: Queue restricts to FIFO; deque allows front/back access (Hour 2).  

**Example Program**: Queue vs. stack for FIFO vs. LIFO.

```cpp
#include <iostream>
#include <queue>
#include <stack>
using namespace std;

int main() {
    // Using queue (FIFO)
    queue<int> q;
    q.push(1); q.push(2); q.push(3);
    cout << "Queue front: " << q.front() << endl; // Output: 1
    q.pop();
    cout << "Queue after pop: " << q.front() << endl; // Output: 2

    // Using stack (LIFO)
    stack<int> s;
    s.push(1); s.push(2); s.push(3);
    cout << "Stack top: " << s.top() << endl; // Output: 3
    s.pop();
    cout << "Stack after pop: " << s.top() << endl; // Output: 2

    return 0;
}
```

**Explanation**:  
- Queue processes elements in order (FIFO); stack processes last element first (LIFO).  
- Queue is ideal for order-preserving tasks; stack for reversing or backtracking.

## Points to Remember (Interview Preparation)
1. **FIFO Principle**: First-In-First-Out is key for queues; ideal for task scheduling or breadth-first search.  
2. **Time Complexities**:  
   - `push`, `pop`, `front`, `back`: O(1).  
   - `size`, `empty`: O(1).  
3. **Use Cases**: Queues for task queues, sliding windows, or level-order traversal.  
4. **Safety**: Check `empty()` before `front`, `back`, or `pop` to avoid undefined behavior.  
5. **Underlying Container**: Default is `deque`; can specify `list` (e.g., `queue<int, list<int>>`).  
6. **Interview Questions**: Be ready for sliding window, queue simulation, or circular queue problems.  
7. **Common Errors**: Avoid accessing `front`/`back`/`pop` on empty queue; no iterator support.