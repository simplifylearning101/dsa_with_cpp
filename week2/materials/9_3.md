# Solutions to Homework Problems

1. **Two-Sum**
```cpp
#include <vector>
#include <unordered_map>
std::vector<int> twoSum(std::vector<int>& nums, int target) {
    std::unordered_map<int, int> map;
    for (int i = 0; i < nums.size(); i++) {
        int complement = target - nums[i];
        if (map.count(complement)) return {map[complement], i};
        map[nums[i]] = i;
    }
    return {};
}
```

2. **Maximum Subarray**
```cpp
#include <vector>
int maxSubArray(std::vector<int>& nums) {
    int maxSum = nums[0], currSum = nums[0];
    for (int i = 1; i < nums.size(); i++) {
        currSum = std::max(nums[i], currSum + nums[i]);
        maxSum = std::max(maxSum, currSum);
    }
    return maxSum;
}
```

3. **Group Anagrams**
```cpp
#include <vector>
#include <string>
#include <unordered_map>
std::vector<std::vector<std::string>> groupAnagrams(std::vector<std::string>& strs) {
    std::unordered_map<std::string, std::vector<std::string>> map;
    for (std::string s : strs) {
        std::vector<int> count(26, 0);
        for (char c : s) count[c - 'a']++;
        std::string key;
        for (int x : count) key += std::to_string(x) + "#";
        map[key].push_back(s);
    }
    std::vector<std::vector<std::string>> result;
    for (auto& pair : map) result.push_back(pair.second);
    return result;
}
```

4. **Longest Palindromic Substring**
```cpp
#include <string>
std::string longestPalindrome(std::string s) {
    int n = s.length(), start = 0, maxLen = 1;
    for (int i = 0; i < n; i++) {
        int left = i, right = i;
        while (left >= 0 && right < n && s[left] == s[right]) {
            if (right - left + 1 > maxLen) {
                start = left;
                maxLen = right - left + 1;
            }
            left--; right++;
        }
        left = i; right = i + 1;
        while (left >= 0 && right < n && s[left] == s[right]) {
            if (right - left + 1 > maxLen) {
                start = left;
                maxLen = right - left + 1;
            }
            left--; right++;
        }
    }
    return s.substr(start, maxLen);
}
```

5. **Minimum Window Substring**
```cpp
#include <string>
#include <unordered_map>
std::string minWindow(std::string s, std::string t) {
    std::unordered_map<char, int> tMap, sMap;
    for (char c : t) tMap[c]++;
    int required = tMap.size(), formed = 0, left = 0, minLen = s.size() + 1, minLeft = 0;
    for (int right = 0; right < s.size(); right++) {
        sMap[s[right]]++;
        if (tMap.count(s[right]) && sMap[s[right]] == tMap[s[right]]) formed++;
        while (formed == required && left <= right) {
            if (right - left + 1 < minLen) {
                minLen = right - left + 1;
                minLeft = left;
            }
            sMap[s[left]]--;
            if (tMap.count(s[left]) && sMap[s[left]] < tMap[s[left]]) formed--;
            left++;
        }
    }
    return minLen > s.size() ? "" : s.substr(minLeft, minLen);
}
```

6. **KMP Pattern Search**
```cpp
#include <vector>
#include <string>
std::vector<int> computeLPS(std::string pattern) {
    int m = pattern.length();
    std::vector<int> lps(m, 0);
    int len = 0, i = 1;
    while (i < m) {
        if (pattern[i] == pattern[len]) lps[i++] = ++len;
        else if (len != 0) len = lps[len - 1];
        else lps[i++] = 0;
    }
    return lps;
}
int KMPSearch(std::string text, std::string pattern) {
    int n = text.length(), m = pattern.length();
    std::vector<int> lps = computeLPS(pattern);
    int i = 0, j = 0;
    while (i < n) {
        if (text[i] == pattern[j]) { i++; j++; }
        if (j == m) return i - j;
        if (i < n && text[i] != pattern[j]) {
            if (j != 0) j = lps[j - 1];
            else i++;
        }
    }
    return -1;
}
```

7. **Edit Distance**
```cpp
#include <string>
#include <vector>
int minDistance(std::string word1, std::string word2) {
    int m = word1.length(), n = word2.length();
    std::vector<std::vector<int>> dp(m + 1, std::vector<int>(n + 1, 0));
    for (int i = 0; i <= m; i++) dp[i][0] = i;
    for (int j = 0; j <= n; j++) dp[0][j] = j;
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (word1[i - 1] == word2[j - 1]) dp[i][j] = dp[i - 1][j - 1];
            else dp[i][j] = std::min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;
        }
    }
    return dp[m][n];
}
```

8. **Regular Expression Matching**
```cpp
#include <string>
#include <vector>
bool isMatch(std::string s, std::string p) {
    int m = s.length(), n = p.length();
    std::vector<std::vector<bool>> dp(m + 1, std::vector<bool>(n + 1, false));
    dp[0][0] = true;
    for (int j = 1; j <= n; j++) {
        if (p[j - 1] == '*') dp[0][j] = dp[0][j - 2];
    }
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (p[j - 1] == '*') {
                dp[i][j] = dp[i][j - 2] || (dp[i - 1][j] && (s[i - 1] == p[j - 2] || p[j - 2] == '.'));
            } else if (p[j - 1] == '.' || s[i - 1] == p[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1];
            }
        }
    }
    return dp[m][n];
}
```

9. **String Compression**
```cpp
#include <vector>
#include <string>
int compress(std::vector<char>& chars) {
    int n = chars.size(), write = 0, count = 1, start = 0;
    for (int i = 1; i <= n; i++) {
        if (i < n && chars[i] == chars[i - 1]) {
            count++;
        } else {
            chars[write++] = chars[start];
            if (count > 1) {
                std::string num = std::to_string(count);
                for (char c : num) chars[write++] = c;
            }
            start = i;
            count = 1;
        }
    }
    return write;
}
```

10. **Longest Valid Parentheses**
```cpp
#include <string>
#include <stack>
int longestValidParentheses(std::string s) {
    std::stack<int> stack;
    stack.push(-1);
    int maxLen = 0;
    for (int i = 0; i < s.length(); i++) {
        if (s[i] == '(') {
            stack.push(i);
        } else {
            stack.pop();
            if (stack.empty()) {
                stack.push(i);
            } else {
                maxLen = std::max(maxLen, i - stack.top());
            }
        }
    }
    return maxLen;
}
```