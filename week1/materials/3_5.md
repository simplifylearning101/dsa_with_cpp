# Deep Dive into C++ STL Strings

This document is an advanced exploration of STL strings for students aiming to master string manipulation for coding interviews. It covers internals, advanced operations, and interview questions with detailed answers, building on Hours 1 (vectors) and 2 (arrays/deques).

## Agenda
- Deep dive into string internals, operations, and optimizations.
- Illustrate complex scenarios with commented programs.
- Prepare for interviews with challenging questions and answers.

## Outcome Expected
Students will:
- Understand string internals (dynamic array, small string optimization).
- Master advanced string operations (e.g., parsing, pattern matching).
- Optimize performance and handle edge cases.
- Answer complex string-related interview questions confidently.

## Topics Covered
1. **String Internals**  
   - Dynamic array structure, small string optimization (SSO).  
   - Memory management and reallocation.  
   - Real-world analogy: String as a stretchable notebook.  
2. **Advanced Operations**  
   - Parsing, tokenization, and regex (introduction).  
   - Efficient concatenation and searching.  
   - Real-world analogy: Document editor with advanced search.  
3. **Optimization and Pitfalls**  
   - Avoiding unnecessary copies.  
   - Handling iterator invalidation.  
   - Edge cases (e.g., empty strings, `npos`).  

## Detailed Explanation

### 1. String Internals
STL `string` is a dynamic array of characters with automatic memory management. Modern implementations use **small string optimization (SSO)**, storing short strings (e.g., <16 bytes) in a local buffer to avoid heap allocation. Think of a string as a stretchable notebook that grows as you add text but keeps short notes internally for speed.

- **Memory**: Heap-allocated for large strings; SSO for small strings.  
- **Reallocation**: Occurs during `+=` or `resize` if capacity is exceeded.  
- **Safety**: Bounds checking with `at()`; iterator support.

**Example Program**: String capacity and SSO.

```cpp
#include <iostream>
#include <string>
using namespace std;

int main() {
    // Initialize strings
    string short_str = "hi"; // Likely uses SSO
    string long_str = "This is a very long string that exceeds SSO buffer";
    
    // Print size and capacity
    cout << "Short string size: " << short_str.size() << ", capacity: " << short_str.capacity() << endl;
    cout << "Long string size: " << long_str.size() << ", capacity: " << long_str.capacity() << endl;
    
    // Append to trigger reallocation
    short_str += " there";
    cout << "After append, short string capacity: " << short_str.capacity() << endl;
    
    return 0;
}
```

**Explanation**:  
- `capacity()`: Shows allocated space (may exceed `size()`).  
- SSO avoids heap for small strings, improving performance.  
- Reallocation may occur during concatenation, affecting iterators.

### 2. Advanced Operations
Strings support parsing, tokenization, and pattern matching (with `<regex>`). These are critical for interview problems like anagram grouping or substring searching.

**Example Program**: Tokenize a string with delimiters.

```cpp
#include <iostream>
#include <string>
#include <vector>
using namespace std;

vector<string> tokenize(const string& s, char delimiter) {
    vector<string> tokens;
    size_t start = 0, pos;
    
    // Extract tokens
    while ((pos = s.find(delimiter, start)) != string::npos) {
        if (pos > start) {
            tokens.push_back(s.substr(start, pos - start));
        }
        start = pos + 1;
    }
    if (start < s.size()) {
        tokens.push_back(s.substr(start));
    }
    
    return tokens;
}

int main() {
    string s = "apple,banana,cherry";
    vector<string> tokens = tokenize(s, ',');
    
    // Print tokens
    cout << "Tokens: ";
    for (const string& token : tokens) {
        cout << token << " ";
    }
    cout << endl; // Output: apple banana cherry
    
    return 0;
}
```

**Explanation**:  
- `find(delimiter, start)`: Locates next delimiter.  
- `substr`: Extracts tokens between delimiters.  
- Handles edge case where last token has no trailing delimiter.

### 3. Optimization and Pitfalls
- **Optimization**: Reserve capacity (`reserve(n)`) to avoid reallocations; use `+=` sparingly for large strings.  
- **Pitfalls**: Iterator invalidation after resizing; checking `npos` in `find`; avoiding out-of-bounds access.

**Example Program**: Efficient string concatenation.

```cpp
#include <iostream>
#include <string>
using namespace std;

int main() {
    vector<string> words = {"Hello", " ", "World", "!"};
    string result;
    
    // Reserve capacity to avoid reallocations
    size_t total_size = 0;
    for (const auto& word : words) total_size += word.size();
    result.reserve(total_size);
    
    // Concatenate
    for (const auto& word : words) {
        result += word;
    }
    
    cout << "Result: " << result << endl; // Output: Hello World!
    
    return 0;
}
```

**Explanation**:  
- `reserve(total_size)`: Pre-allocates memory to minimize reallocations.  
- Reduces overhead for large concatenations.

## Interview Questions and Answers
Below are 15 advanced interview questions on strings.

1. **Question**: How does STL `string` differ from C-style strings?  
   **Answer**: STL `string` is dynamic, safe, and provides methods like `find`, `substr`. C-strings are null-terminated, error-prone, and require manual memory management.  
   **Interviewer’s Intention**: Tests understanding of string safety.

2. **Question**: What is small string optimization (SSO)?**  
   **Answer**: SSO stores small strings in a local buffer (e.g., 16 bytes) to avoid heap allocation, improving performance.  
   **Interviewer’s Intention**: Checks knowledge of string internals.

3. **Question**: What is the time complexity of `s += str`?**  
   **Answer**: O(n) amortized, due to potential reallocation.  
   **Interviewer’s Intention**: Tests operation cost awareness.

4. **Question**: Write a program to reverse a string in-place.  
   **Answer**:  
```cpp
#include <iostream>
#include <string>
using namespace std;

void reverseString(string& s) {
    for (size_t i = 0; i < s.size() / 2; ++i) {
        swap(s[i], s[s.size() - 1 - i]);
    }
}

int main() {
    string s = "hello";
    reverseString(s);
    cout << s << endl; // Output: olleh
    return 0;
}
```
   **Interviewer’s Intention**: Tests in-place manipulation.

5. **Question**: How do you handle `string::npos` in `find`?**  
   **Answer**: Check if `find` returns `npos` to detect absence of substring.  
   **Interviewer’s Intention**: Ensures edge case handling.

6. **Question**: Why use `reserve` in string operations?**  
   **Answer**: Pre-allocates memory to avoid reallocations during concatenation.  
   **Interviewer’s Intention**: Tests optimization knowledge.

7. **Question**: Write a program to check if two strings are anagrams.  
   **Answer**:  
```cpp
#include <iostream>
#include <string>
#include <array>
using namespace std;

bool areAnagrams(const string& s1, const string& s2) {
    if (s1.size() != s2.size()) return false;
    array<int, 26> count = {0};
    for (size_t i = 0; i < s1.size(); ++i) {
        count[s1[i] - 'a']++;
        count[s2[i] - 'a']--;
    }
    for (int c : count) if (c != 0) return false;
    return true;
}

int main() {
    string s1 = "listen", s2 = "silent";
    cout << (areAnagrams(s1, s2) ? "Yes" : "No") << endl; // Output: Yes
    return 0;
}
```
   **Interviewer’s Intention**: Tests string and array usage.

8. **Question**: What happens to string iterators after `push_back`?**  
   **Answer**: May be invalidated if reallocation occurs.  
   **Interviewer’s Intention**: Checks iterator invalidation knowledge.

9. **Question**: When should you use `string` vs. `vector<char>`?**  
   **Answer**: Use `string` for text operations; `vector<char>` for raw byte data.  
   **Interviewer’s Intention**: Tests container selection.

10. **Question**: Write a program to find all occurrences of a substring.  
    **Answer**:  
```cpp
#include <iostream>
#include <string>
#include <vector>
using namespace std;

vector<size_t> findAll(const string& s, const string& sub) {
    vector<size_t> positions;
    size_t pos = 0;
    while ((pos = s.find(sub, pos)) != string::npos) {
        positions.push_back(pos);
        pos++;
    }
    return positions;
}

int main() {
    string s = "banana";
    vector<size_t> pos = findAll(s, "ana");
    for (size_t p : pos) cout << p << " "; // Output: 1 3
    cout << endl;
    return 0;
}
```
    **Interviewer’s Intention**: Tests `find` usage.

11. **Question**: What is the benefit of SSO?**  
    **Answer**: Avoids heap allocation for small strings, improving performance.  
    **Interviewer’s Intention**: Tests optimization knowledge.

12. **Question**: Write a program to count word frequency in a string.  
    **Answer**:  
```cpp
#include <iostream>
#include <string>
#include <map>
using namespace std;

map<string, int> wordFrequency(const string& s) {
    map<string, int> freq;
    size_t start = 0, pos;
    while ((pos = s.find(' ', start)) != string::npos) {
        if (pos > start) freq[s.substr(start, pos - start)]++;
        start = pos + 1;
    }
    if (start < s.size()) freq[s.substr(start)]++;
    return freq;
}

int main() {
    string s = "the quick the brown";
    auto freq = wordFrequency(s);
    for (const auto& pair : freq) {
        cout << pair.first << ": " << pair.second << endl;
    }
    // Output: brown: 1, quick: 1, the: 2
    return 0;
}
```
    **Interviewer’s Intention**: Tests parsing and counting.

13. **Question**: Why is `string::at` safer than `operator[]`?**  
    **Answer**: `at` throws `out_of_range` for invalid indices; `[]` causes undefined behavior.  
    **Interviewer’s Intention**: Tests safety awareness.

14. **Question**: How do you convert a number to a string?**  
    **Answer**: Use `to_string(n)` (C++11).  
    **Interviewer’s Intention**: Tests utility function knowledge.

15. **Question**: Write a program to remove duplicate characters from a string.  
    **Answer**:  
```cpp
#include <iostream>
#include <string>
#include <array>
using namespace std;

string removeDuplicates(const string& s) {
    array<bool, 256> seen = {false};
    string result;
    for (char c : s) {
        if (!seen[c]) {
            seen[c] = true;
            result += c;
        }
    }
    return result;
}

int main() {
    string s = "banana";
    cout << removeDuplicates(s) << endl; // Output: ban
    return 0;
}
```
    **Interviewer’s Intention**: Tests string and array manipulation.

## Practice Recommendations
- Solve LeetCode problems like **Longest Substring Without Repeating Characters** and **Valid Palindrome**.  
- Experiment with string parsing and regex.  
- Optimize concatenation with `reserve`.