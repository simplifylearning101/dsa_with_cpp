# Solutions for Leetcode Problems

1. **Longest Substring with At Most K Distinct Characters**  
   **Explanation:** Find longest substring with <= k distinct characters.  
   **Brute-Force:** Check all substrings.  
   ```cpp
   int lengthOfLongestSubstringKDistinct(string s, int k) {
       int maxLen = 0;
       for (int i = 0; i < s.size(); i++) {
           unordered_set<char> set;
           for (int j = i; j < s.size(); j++) {
               set.insert(s[j]);
               if (set.size() <= k) maxLen = max(maxLen, j - i + 1);
               else break;
           }
       }
       return maxLen;
   }
   ```
   Pros: Correct. Cons: O(n²) time.  
   **Optimized:** Sliding window.  
   ```cpp
   int lengthOfLongestSubstringKDistinct(string s, int k) {
       unordered_map<char, int> map;
       int left = 0, maxLen = 0;
       for (int right = 0; right < s.size(); right++) {
           map[s[right]]++;
           while (map.size() > k) {
               map[s[left]]--;
               if (map[s[left]] == 0) map.erase(s[left]);
               left++;
           }
           maxLen = max(maxLen, right - left + 1);
       }
       return maxLen;
   }
   ```
   Pros: O(n) time, O(k) space. Cons: None.

2. **Find All Anagrams in a String**  
   **Explanation:** Find indices of p's anagrams in s.  
   **Brute-Force:** Check all substrings.  
   ```cpp
   vector<int> findAnagrams(string s, string p) {
       vector<int> result;
       string sortedP = p;
       sort(sortedP.begin(), sortedP.end());
       for (int i = 0; i <= s.size() - p.size(); i++) {
           string sub = s.substr(i, p.size());
           sort(sub.begin(), sub.end());
           if (sub == sortedP) result.push_back(i);
       }
       return result;
   }
   ```
   Pros: Simple. Cons: O(n*k*log k) time (k=p.size()).  
   **Optimized:** Sliding window with frequency array.  
   ```cpp
   vector<int> findAnagrams(string s, string p) {
       vector<int> result;
       if (p.size() > s.size()) return result;
       int count[26] = {0}, window[26] = {0};
       for (char c : p) count[c - 'a']++;
       for (int i = 0; i < p.size(); i++) window[s[i] - 'a']++;
       if (equal(count, count + 26, window)) result.push_back(0);
       for (int i = p.size(); i < s.size(); i++) {
           window[s[i] - 'a']++;
           window[s[i - p.size()] - 'a']--;
           if (equal(count, count + 26, window)) result.push_back(i - p.size() + 1);
       }
       return result;
   }
   ```
   Pros: O(n) time, O(1) space. Cons: Limited to lowercase letters.

3. **Minimum Window Substring**  
   **Explanation:** Find smallest substring containing all characters of t.  
   **Brute-Force:** Check all substrings.  
   ```cpp
   string minWindow(string s, string t) {
       int minLen = s.size() + 1;
       string result;
       unordered_map<char, int> tMap;
       for (char c : t) tMap[c]++;
       for (int i = 0; i < s.size(); i++) {
           unordered_map<char, int> sMap;
           for (int j = i; j < s.size(); j++) {
               sMap[s[j]]++;
               bool valid = true;
               for (auto& p : tMap) {
                   if (sMap[p.first] < p.second) valid = false;
               }
               if (valid && j - i + 1 < minLen) {
                   minLen = j - i + 1;
                   result = s.substr(i, minLen);
               }
           }
       }
       return result;
   }
   ```
   Pros: Correct. Cons: O(n²) time.  
   **Optimized:** Sliding window.  
   ```cpp
   string minWindow(string s, string t) {
       unordered_map<char, int> tMap, sMap;
       for (char c : t) tMap[c]++;
       int required = tMap.size(), formed = 0, left = 0, minLen = s.size() + 1, minLeft = 0;
       for (int right = 0; right < s.size(); right++) {
           sMap[s[right]]++;
           if (tMap.count(s[right]) && sMap[s[right]] == tMap[s[right]]) formed++;
           while (formed == required && left <= right) {
               if (right - left + 1 < minLen) {
                   minLen = right - left + 1;
                   minLeft = left;
               }
               sMap[s[left]]--;
               if (tMap.count(s[left]) && sMap[s[left]] < tMap[s[left]]) formed--;
               left++;
           }
       }
       return minLen > s.size() ? "" : s.substr(minLeft, minLen);
   }
   ```
   Pros: O(n) time, O(k) space. Cons: Complex logic.

4. **Longest Repeating Character Replacement**  
   **Explanation:** Maximize substring length with k replacements.  
   **Brute-Force:** Try all substrings.  
   ```cpp
   int characterReplacement(string s, int k) {
       int maxLen = 0;
       for (int i = 0; i < s.size(); i++) {
           for (int j = i; j < s.size(); j++) {
               unordered_map<char, int> count;
               for (int x = i; x <= j; x++) count[s[x]]++;
               int maxCount = 0;
               for (auto& p : count) maxCount = max(maxCount, p.second);
               if (j - i + 1 - maxCount <= k) maxLen = max(maxLen, j - i + 1);
           }
       }
       return maxLen;
   }
   ```
   Pros: Correct. Cons: O(n²) time.  
   **Optimized:** Sliding window.  
   ```cpp
   int characterReplacement(string s, int k) {
       int count[26] = {0}, maxCount = 0, left = 0, maxLen = 0;
       for (int right = 0; right < s.size(); right++) {
           maxCount = max(maxCount, ++count[s[right] - 'A']);
           while (right - left + 1 - maxCount > k) {
               count[s[left] - 'A']--;
               left++;
           }
           maxLen = max(maxLen, right - left + 1);
       }
       return maxLen;
   }
   ```
   Pros: O(n) time, O(1) space. Cons: Limited to uppercase letters.

5. **Longest Substring Without Repeating Characters**  
   **Explanation:** Find longest substring with unique characters.  
   **Brute-Force:** Check all substrings.  
   ```cpp
   int lengthOfLongestSubstring(string s) {
       int maxLen = 0;
       for (int i = 0; i < s.size(); i++) {
           unordered_set<char> set;
           for (int j = i; j < s.size(); j++) {
               if (set.count(s[j])) break;
               set.insert(s[j]);
               maxLen = max(maxLen, j - i + 1);
           }
       }
       return maxLen;
   }
   ```
   Pros: Simple. Cons: O(n²) time.  
   **Optimized:** Sliding window.  
   ```cpp
   int lengthOfLongestSubstring(string s) {
       unordered_map<char, int> map;
       int left = 0, maxLen = 0;
       for (int right = 0; right < s.size(); right++) {
           if (map.find(s[right]) != map.end() && map[s[right]] >= left) {
               left = map[s[right]] + 1;
           }
           map[s[right]] = right;
           maxLen = max(maxLen, right - left + 1);
       }
       return maxLen;
   }
   ```
   Pros: O(n) time, O(k) space. Cons: None.