# Hour 10 Additional LeetCode Problems: Unordered Set and Multiset Solutions

This document provides detailed solutions for three LeetCode problems recommended in `10_2.md`: **LeetCode 349: Intersection of Two Arrays**, **LeetCode 202: Happy Number**, and **LeetCode 771: Jewels and Stones**. Each solution includes a problem description, coding pattern, optimized solution with commented C++ code using STL `unordered_set` or `unordered_multiset`, time and space complexity analysis, and test cases.

## Agenda
- Provide optimized solutions for three `unordered_set`/`unordered_multiset`-based LeetCode problems.
- Explain coding patterns (e.g., membership testing, cycle detection, counting).
- Analyze time and space complexities.
- Include test cases to ensure robustness.

## Outcome Expected
Students will:
- Master `unordered_set`/`unordered_multiset` usage for membership testing, intersections, and cycle detection.  
- Apply techniques for array and string processing.  
- Handle edge cases and optimize for interviews.

---

## 1. LeetCode 349: Intersection of Two Arrays (Easy)

**Link**: [LeetCode 349](https://leetcode.com/problems/intersection-of-two-arrays/)

**Description**:  
Given two integer arrays `nums1` and `nums2`, return an array of their intersection. Each element in the result must be unique, and you may return the result in any order.

**Constraints**:
- `1 <= nums1.length, nums2.length <= 1000`
- `0 <= nums1[i], nums2[i] <= 1000`

**Example**:
- Input: `nums1 = [1,2,2,1], nums2 = [2,2]`  
  Output: `[2]`  
  Explanation: `2` is the only unique element in both arrays.

**Coding Pattern**: Unordered Set for Intersection  
- Convert `nums1` to an `unordered_set`.  
- Check each element in `nums2` for presence in the set.  
- Add unique elements to result.

**Optimized Solution**:
```cpp
#include <unordered_set>
#include <vector>
using namespace std;

class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int> us(nums1.begin(), nums1.end());
        unordered_set<int> result_set;
        for (int num : nums2) {
            if (us.find(num) != us.end()) {
                result_set.insert(num);
            }
        }
        return vector<int>(result_set.begin(), result_set.end());
    }
};
```

**Time Complexity**: O(n + m)  
- Building set: O(n).  
- Checking nums2: O(m) average.

**Space Complexity**: O(n + k)  
- Stores nums1 in set and k unique intersection elements.

**Explanation**:  
- `unordered_set` ensures unique elements.  
- Second set avoids duplicates in result.

**Test Cases**:
1. **Typical Case**: `nums1 = [1,2,2,1], nums2 = [2,2]` → Output: `[2]`  
2. **No Intersection**: `nums1 = [1,2], nums2 = [3,4]` → Output: `[]`  
3. **Single Element**: `nums1 = [1], nums2 = [1]` → Output: `[1]`  
4. **All Unique**: `nums1 = [1,2,3], nums2 = [2,3,4]` → Output: `[2,3]`  
5. **Empty Array**: `nums1 = [], nums2 = [1]` → Output: `[]`  

---

## 2. LeetCode 202: Happy Number (Easy)

**Link**: [LeetCode 202](https://leetcode.com/problems/happy-number/)

**Description**:  
A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat until the number equals 1 (happy) or loops endlessly (not happy). Return `true` if the number is happy, `false` otherwise.

**Constraints**:
- `1 <= n <= 2^31 - 1`

**Example**:
- Input: `n = 19`  
  Output: `true`  
  Explanation: `1^2 + 9^2 = 82`, `8^2 + 2^2 = 68`, `6^2 + 8^2 = 100`, `1^2 + 0^2 + 0^2 = 1`.

**Coding Pattern**: Unordered Set for Cycle Detection  
- Use `unordered_set` to track seen sums.  
- Compute sum of squared digits repeatedly.  
- If sum is 1, return `true`; if a sum repeats, return `false`.

**Optimized Solution**:
```cpp
#include <unordered_set>
using namespace std;

class Solution {
public:
    int getNext(int n) {
        int sum = 0;
        while (n > 0) {
            int digit = n % 10;
            sum += digit * digit;
            n /= 10;
        }
        return sum;
    }
    
    bool isHappy(int n) {
        unordered_set<int> seen;
        while (n != 1) {
            if (seen.find(n) != seen.end()) {
                return false; // Cycle detected
            }
            seen.insert(n);
            n = getNext(n);
        }
        return true;
    }
};
```

**Time Complexity**: O(log n)  
- Each iteration reduces n logarithmically; operations are O(1) average.

**Space Complexity**: O(log n)  
- Stores seen sums.

**Explanation**:  
- `unordered_set` detects cycles by tracking sums.  
- `getNext` computes sum of squared digits.

**Test Cases**:
1. **Happy Number**: `n = 19` → Output: `true`  
2. **Non-Happy Number**: `n = 2` → Output: `false`  
3. **Single Digit**: `n = 1` → Output: `true`  
4. **Large Number**: `n = 23` → Output: `true`  
5. **Cycle Case**: `n = 4` → Output: `false`  

---

## 3. LeetCode 771: Jewels and Stones (Easy)

**Link**: [LeetCode 771](https://leetcode.com/problems/jewels-and-stones/)

**Description**:  
You're given strings `jewels` representing the types of stones that are jewels, and `stones` representing the stones you have. Each character in `stones` is a type of stone. Return the number of stones that are also jewels.

**Constraints**:
- `1 <= jewels.length, stones.length <= 50`
- `jewels` and `stones` consist of English letters.
- All characters in `jewels` are unique.

**Example**:
- Input: `jewels = "aA", stones = "aAAbbbb"`  
  Output: `3`  
  Explanation: `a` and `A` are jewels, appearing 3 times in `stones`.

**Coding Pattern**: Unordered Set for Membership Testing  
- Convert `jewels` to an `unordered_set`.  
- Count stones that exist in the set.

**Optimized Solution**:
```cpp
#include <unordered_set>
#include <string>
using namespace std;

class Solution {
public:
    int numJewelsInStones(string jewels, string stones) {
        unordered_set<char> jewel_set(jewels.begin(), jewels.end());
        int count = 0;
        for (char stone : stones) {
            if (jewel_set.find(stone) != jewel_set.end()) {
                count++;
            }
        }
        return count;
    }
};
```

**Time Complexity**: O(n + m)  
- Building set: O(n) for jewels.  
- Checking stones: O(m) average.

**Space Complexity**: O(n)  
- Stores jewels in set.

**Explanation**:  
- `unordered_set` provides O(1) average lookups.  
- Simple counting loop for stones.

**Test Cases**:
1. **Typical Case**: `jewels = "aA", stones = "aAAbbbb"` → Output: `3`  
2. **No Jewels**: `jewels = "a", stones = "BBB"` → Output: `0`  
3. **All Jewels**: `jewels = "a", stones = "aaa"` → Output: `3`  
4. **Empty Strings**: `jewels = "", stones = "a"` → Output: `0`  
5. **Case Sensitivity**: `jewels = "z", stones = "Z"` → Output: `0`  

---

## Test Case Implementation
Below is a program to test all three solutions with the provided test cases.

```cpp
#include <iostream>
#include <unordered_set>
#include <vector>
#include <string>
using namespace std;

// LeetCode 349: Intersection of Two Arrays
vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
    unordered_set<int> us(nums1.begin(), nums1.end());
    unordered_set<int> result_set;
    for (int num : nums2) {
        if (us.find(num) != us.end()) {
            result_set.insert(num);
        }
    }
    return vector<int>(result_set.begin(), result_set.end());
}

// LeetCode 202: Happy Number
int getNext(int n) {
    int sum = 0;
    while (n > 0) {
        int digit = n % 10;
        sum += digit * digit;
        n /= 10;
    }
    return sum;
}

bool isHappy(int n) {
    unordered_set<int> seen;
    while (n != 1) {
        if (seen.find(n) != seen.end()) {
            return false;
        }
        seen.insert(n);
        n = getNext(n);
    }
    return true;
}

// LeetCode 771: Jewels and Stones
int numJewelsInStones(string jewels, string stones) {
    unordered_set<char> jewel_set(jewels.begin(), jewels.end());
    int count = 0;
    for (char stone : stones) {
        if (jewel_set.find(stone) != jewel_set.end()) {
            count++;
        }
    }
    return count;
}

// Helper to print vector
void printVector(const vector<int>& v) {
    cout << "[";
    for (int i = 0; i < v.size(); ++i) {
        cout << v[i] << (i < v.size() - 1 ? "," : "");
    }
    cout << "]" << endl;
}

int main() {
    // Test LeetCode 349
    cout << "LeetCode 349: Intersection of Two Arrays\n";
    vector<int> nums1_349 = {1, 2, 2, 1}, nums2_349 = {2, 2};
    cout << "Test 1: "; printVector(intersection(nums1_349, nums2_349)); // [2]

    // Test LeetCode 202
    cout << "\nLeetCode 202: Happy Number\n";
    int n_202 = 19;
    cout << "Test 1: " << (isHappy(n_202) ? "true" : "false") << endl; // true

    // Test LeetCode 771
    cout << "\nLeetCode 771: Jewels and Stones\n";
    string jewels_771 = "aA", stones_771 = "aAAbbbb";
    cout << "Test 1: " << numJewelsInStones(jewels_771, stones_771) << endl; // 3

    return 0;
}
```

**Output**:
```
LeetCode 349: Intersection of Two Arrays
Test 1: [2]

LeetCode 202: Happy Number
Test 1: true

LeetCode 771: Jewels and Stones
Test 1: 3
```

## Key Takeaways
- **Membership Testing**: `unordered_set` excels at O(1) lookups for problems like intersections and jewel counting.  
- **Cycle Detection**: Use `unordered_set` to detect loops efficiently (e.g., happy numbers).  
- **Optimization**: Leverage hash-based containers for speed, but handle collisions carefully.