# Hour 8 Quiz: Maps in STL

Below are 30 questions to test understanding of STL `map` and `unordered_map` and concepts from Hours 1–7. The questions are designed for interview preparation, covering key operations and concepts.

## Quiz Questions

1. **What is the primary characteristic of STL `map`?**  
   a) Allows duplicate keys  
   b) Stores key-value pairs in sorted order by key  
   c) Unordered key-value pairs  
   d) LIFO structure  
   **Answer**: b) Stores key-value pairs in sorted order by key  
   **Explanation**: `map` uses a red-black tree for sorted keys.

2. **Which header is required for STL `map`?**  
   a) `<vector>`  
   b) `<map>`  
   c) `<queue>`  
   d) `<set>`  
   **Answer**: b) `<map>`  
   **Explanation**: `<map>` provides `map` and `unordered_map`.

3. **What is the time complexity of `map::insert`?**  
   a) O(1)  
   b) O(log n)  
   c) O(n)  
   d) O(n log n)  
   **Answer**: b) O(log n)  
   **Explanation**: Red-black tree operations are O(log n).

4. **How do you declare a map of strings to integers?**  
   a) `map<string, int> m;`  
   b) `unordered_map<string, int> m;`  
   c) `map<int, string> m;`  
   d) `map<string, int[]> m;`  
   **Answer**: a) `map<string, int> m;`  
   **Explanation**: Declares an ordered map.

5. **What does `m.find(key)` return if key is not in the map?**  
   a) 0  
   b) `m.end()`  
   c) Throws exception  
   d) Null  
   **Answer**: b) `m.end()`  
   **Explanation**: Returns end iterator if key not found.

6. **What is the underlying structure of `map`?**  
   a) Hash table  
   b) Red-black tree  
   c) Array  
   d) Linked list  
   **Answer**: b) Red-black tree  
   **Explanation**: Ensures sorted order and O(log n) operations.

7. **What does `m.erase(key)` do?**  
   a) Removes all pairs  
   b) Removes pair with key  
   c) Returns value  
   d) Clears the map  
   **Answer**: b) Removes pair with key  
   **Explanation**: Removes key-value pair if it exists.

8. **What is a common use case for `map`?**  
   a) Storing duplicates  
   b) Key-value mappings with sorted keys  
   c) FIFO processing  
   d) Random access  
   **Answer**: b) Key-value mappings with sorted keys  
   **Explanation**: Ideal for sorted key-value data.

9. **What is the difference between `map` and `unordered_map`?**  
   a) `map` is unordered; `unordered_map` is sorted  
   b) `map` is sorted; `unordered_map` is O(1) average  
   c) Both are sorted  
   d) Both allow duplicate keys  
   **Answer**: b) `map` is sorted; `unordered_map` is O(1) average  
   **Explanation**: `map` uses red-black tree; `unordered_map` uses hash table.

10. **What is the output of `map<string, int> m; m["a"] = 1; cout << m["a"];`?**  
    a) 0  
    b) 1  
    c) Undefined  
    d) Error  
    **Answer**: b) 1  
    **Explanation**: `operator[]` returns value for key.

11. **Which operation is NOT supported by `map`?**  
    a) `insert`  
    b) `erase`  
    c) `push_back`  
    d) `find`  
    **Answer**: c) `push_back`  
    **Explanation**: `map` does not support vector-like operations.

12. **What does `m.count(key)` return in `map`?**  
    a) Number of key occurrences  
    b) 0 or 1  
    c) Iterator  
    d) Size  
    **Answer**: b) 0 or 1  
    **Explanation**: `map` stores unique keys.

13. **Can you access map values by index?**  
    a) Yes  
    b) No  
    c) Only with iterators  
    d) Only in `unordered_map`  
    **Answer**: b) No  
    **Explanation**: No random access in maps.

14. **What is the time complexity of `unordered_map::find`?**  
    a) O(1) average  
    b) O(log n)  
    c) O(n)  
    d) O(n log n)  
    **Answer**: a) O(1) average  
    **Explanation**: Hash table provides O(1) average lookups.

15. **What is the output of `map<string, int> m; m["a"] = 1; m.erase("a"); cout << m.empty();`?**  
    a) 0  
    b) 1  
    c) Undefined  
    d) Error  
    **Answer**: b) 1  
    **Explanation**: Map is empty after erase.

16. **What happens if you insert a duplicate key into a map?**  
    a) Overwrites value  
    b) Ignored  
    c) Throws exception  
    d) Adds anyway  
    **Answer**: a) Overwrites value  
    **Explanation**: `operator[]` or `insert` updates value for existing key.

17. **What is the underlying structure of `unordered_map`?**  
    a) Red-black tree  
    b) Hash table  
    c) Array  
    d) Linked list  
    **Answer**: b) Hash table  
    **Explanation**: Enables O(1) average operations.

18. **What does `unordered_map<string, int> um; um["a"] = 1; cout << um.count("a");` output?**  
    a) 0  
    b) 1  
    c) Undefined  
    d) Error  
    **Answer**: b) 1  
    **Explanation**: `count` returns 1 if key exists.

19. **How do you iterate over a map?**  
    a) Index-based loop  
    b) Range-based for loop  
    c) No iteration possible  
    d) Only with `find`  
    **Answer**: b) Range-based for loop  
    **Explanation**: Maps support iteration.

20. **What is the output of `unordered_map<string, int> um; um["a"] = 1; um["b"] = 2; um.erase("a"); cout << um.size();`?**  
    a) 0  
    b) 1  
    c) 2  
    d) Error  
    **Answer**: b) 1  
    **Explanation**: One pair remains after erase.

21. **What is `map` best suited for?**  
    a) Random access  
    b) Sorted key-value pairs  
    c) FIFO operations  
    d) Duplicate keys  
    **Answer**: b) Sorted key-value pairs  
    **Explanation**: `map` maintains sorted order by key.

22. **What is the time complexity of `map::erase`?**  
    a) O(1)  
    b) O(log n)  
    c) O(n)  
    d) O(n log n)  
    **Answer**: b) O(log n)  
    **Explanation**: Red-black tree operation.

23. **Can you modify a value in a map?**  
    a) Yes  
    b) No  
    c) Only with `insert`  
    d) Only in `unordered_map`  
    **Answer**: a) Yes  
    **Explanation**: Use `operator[]` or iterator to modify value.

24. **What does `m.empty()` return?**  
    a) Size  
    b) Boolean  
    c) Iterator  
    d) Error  
    **Answer**: b) Boolean  
    **Explanation**: Returns `true` if empty.

25. **What is the time complexity of `unordered_map::insert`?**  
    a) O(1) average  
    b) O(log n)  
    c) O(n)  
    d) O(n log n)  
    **Answer**: a) O(1) average  
    **Explanation**: Hash table operation.

26. **How do you initialize a map with values {"a":1, "b":2}?**  
    a) `map<string, int> m = {{"a",1}, {"b",2}};`  
    b) `map<string, int> m; m["a"] = 1; m["b"] = 2;`  
    c) Both a and b  
    d) `map<string, int> m("a",1, "b",2);`  
    **Answer**: c) Both a and b  
    **Explanation**: Both methods work; initializer list is concise.

27. **What is the output of `map<string, int> m; m["a"] = 5; cout << m.find("a")->second;`?**  
    a) 0  
    b) 5  
    c) Undefined  
    d) Error  
    **Answer**: b) 5  
    **Explanation**: `find` returns iterator to pair.

28. **When should you use `unordered_map` over `map`?**  
    a) When key order matters  
    b) For faster lookups  
    c) For duplicate keys  
    d) For iteration  
    **Answer**: b) For faster lookups  
    **Explanation**: `unordered_map` is O(1) average.

29. **What does `#include <map>` do?**  
    a) Includes all containers  
    b) Provides map and unordered_map  
    c) Enables algorithms  
    d) Defines vector  
    **Answer**: b) Provides map and unordered_map  
    **Explanation**: Imports STL map containers.

30. **What happens to a map’s pairs after `erase`?**  
    a) Moved to another map  
    b) Removed  
    c) Kept in memory  
    d) Returned  
    **Answer**: b) Removed  
    **Explanation**: `erase` deletes the key-value pair.