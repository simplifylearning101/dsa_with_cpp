# Hour 9: Multiset and Multimap in STL

**Agenda**: Introduce students to C++ STL `multiset` and `multimap`, building on their understanding of vectors (Hour 1), arrays/deques (Hour 2), strings (Hour 3), stacks (Hour 4), queues (Hour 5), priority queues (Hour 6), sets (Hour 7), and maps (Hour 8). Use real-world analogies and fully commented programs to simplify concepts. Emphasize practical usage, operations, and preparation for coding interviews.

**Outcome Expected**:  
By the end of this hour, students will:  
- Understand STL `multiset` (ordered container allowing duplicates) and `multimap` (ordered key-value pairs allowing duplicate keys).  
- Master multiset and multimap operations (e.g., insert, erase, find, count).  
- Compare multisets with sets and multimaps with maps.  
- Write C++ programs using multisets and multimaps with proper syntax.  
- Be ready to solve LeetCode problems involving frequency counting and duplicate handling.

## Topics Covered
1. **STL Multiset: Ordered Container with Duplicates**  
   - Declaration, initialization, and basic operations.  
   - Underlying structure: Red-black tree.  
   - Real-world analogy: Multiset as a sorted list of exam scores.  
2. **STL Multimap: Ordered Key-Value Pairs with Duplicate Keys**  
   - Declaration, initialization, and operations.  
   - Underlying structure: Red-black tree.  
   - Real-world analogy: Multimap as a phone book with multiple numbers per person.  
3. **Multiset and Multimap Operations**  
   - `insert`, `erase`, `find`, `count`, `equal_range`, `size`, `empty`.  
   - Iterating over multisets and multimaps.  
4. **Comparison with Set and Map**  
   - Multiset vs. set (duplicates allowed vs. unique elements).  
   - Multimap vs. map (duplicate keys vs. unique keys).  

## Detailed Explanation of Topics Covered

### 1. STL Multiset: Ordered Container with Duplicates
The STL `multiset` is a container that stores elements in sorted order, allowing duplicates, implemented using a red-black tree. Think of a `multiset` as a sorted list of exam scores where multiple students can have the same score.

**Key Features**:  
- **Declaration**: `multiset<T> ms;` (e.g., `multiset<int>` for scores).  
- **Initialization**: Insert elements, duplicates allowed.  
- **Operations**: `insert`, `erase`, `find`, `count`, `equal_range`, `size`, `empty`.  
- **Advantages**: O(log n) for insert/erase/find; sorted order.  
- **Limitations**: No random access; no direct modification of elements.

**Example Program**: Basic multiset operations.

```cpp
#include <iostream>
#include <set>
using namespace std;

int main() {
    // Declare multiset
    multiset<int> scores;

    // Insert elements (duplicates allowed)
    scores.insert(85); // O(log n)
    scores.insert(90);
    scores.insert(85); // Duplicate inserted
    scores.insert(95);

    // Print size
    cout << "Size: " << scores.size() << endl; // Output: 4

    // Print elements (sorted order)
    cout << "Scores: ";
    for (const int& score : scores) {
        cout << score << " "; // Output: 85 85 90 95
    }
    cout << endl;

    // Count occurrences of a value
    cout << "Count of 85: " << scores.count(85) << endl; // Output: 2

    // Find first occurrence
    auto it = scores.find(85);
    cout << "Find 85: " << (it != scores.end() ? to_string(*it) : "Not found") << endl; // Output: 85

    // Erase one occurrence
    scores.erase(scores.find(85)); // Erases one 85
    cout << "After erasing one 85, size: " << scores.size() << endl; // Output: 3

    // Erase all occurrences
    scores.erase(85); // Erases all 85s
    cout << "After erasing all 85s, size: " << scores.size() << endl; // Output: 2

    return 0;
}
```

**Explanation**:  
- `#include <set>`: Imports the set library (includes `multiset`).  
- `insert`: Adds elements in sorted order (O(log n)).  
- `count(value)`: Returns number of occurrences (O(log n + k), k = occurrences).  
- `erase(iterator)`: Erases one occurrence; `erase(value)` erases all.  
- Elements are automatically sorted; duplicates are allowed.

### 2. STL Multimap: Ordered Key-Value Pairs with Duplicate Keys
The STL `multimap` stores key-value pairs in sorted order by key, allowing duplicate keys, implemented using a red-black tree. Think of it as a phone book where one person can have multiple phone numbers.

**Key Features**:  
- **Declaration**: `multimap<K, V> mm;` (e.g., `multimap<string, int>`).  
- **Operations**: `insert`, `erase`, `find`, `count`, `equal_range`, `size`, `empty`.  
- **Advantages**: O(log n) for operations; sorted by key.  
- **Limitations**: No `operator[]` (due to duplicate keys); no direct value modification.

**Example Program**: Multimap operations.

```cpp
#include <iostream>
#include <map>
#include <string>
using namespace std;

int main() {
    // Declare multimap
    multimap<string, int> phone_book;

    // Insert key-value pairs
    phone_book.insert({"Alice", 1234567890}); // O(log n)
    phone_book.insert({"Alice", 1112223333}); // Duplicate key
    phone_book.insert({"Bob", 9876543210});

    // Print size
    cout << "Size: " << phone_book.size() << endl; // Output: 3

    // Print elements (sorted by key)
    cout << "Phone book: ";
    for (const auto& pair : phone_book) {
        cout << pair.first << ":" << pair.second << " "; // Output: Alice:1234567890 Alice:1112223333 Bob:9876543210
    }
    cout << endl;

    // Count keys
    cout << "Count of Alice: " << phone_book.count("Alice") << endl; // Output: 2

    // Find range of keys
    auto range = phone_book.equal_range("Alice");
    cout << "Alice's numbers: ";
    for (auto it = range.first; it != range.second; ++it) {
        cout << it->second << " "; // Output: 1234567890 1112223333
    }
    cout << endl;

    // Erase one entry
    phone_book.erase(phone_book.find("Alice")); // Erases one Alice entry
    cout << "After erasing one Alice, size: " << phone_book.size() << endl; // Output: 2

    return 0;
}
```

**Explanation**:  
- `#include <map>`: Imports the map library (includes `multimap`).  
- `equal_range(key)`: Returns iterator range for all pairs with key.  
- No `operator[]` since duplicate keys exist.

### 3. Multiset and Multimap Operations
Both `multiset` and `multimap` support operations for managing elements or key-value pairs with duplicates. Elements/keys are sorted.

**Key Operations**:  
- `insert(value)` or `insert({key, value})`: Adds element/pair (O(log n)).  
- `erase(iterator)`: Removes one element/pair; `erase(value)` removes all.  
- `find(value)` or `find(key)`: Returns iterator to first occurrence or `end()`.  
- `count(value)` or `count(key)`: Returns number of occurrences.  
- `equal_range(value)` or `equal_range(key)`: Returns iterator range for duplicates.  
- `size()`: Number of elements/pairs.  
- `empty()`: Checks if container is empty.

**Example Program**: Comparing multiset and multimap.

```cpp
#include <iostream>
#include <set>
#include <map>
#include <string>
using namespace std;

int main() {
    // Multiset
    multiset<int> ms;
    ms.insert(10); ms.insert(10); ms.insert(20);
    cout << "Multiset: ";
    for (const int& x : ms) {
        cout << x << " "; // Output: 10 10 20
    }
    cout << endl;
    cout << "Count of 10: " << ms.count(10) << endl; // Output: 2

    // Multimap
    multimap<string, int> mm;
    mm.insert({"Alice", 1}); mm.insert({"Alice", 2}); mm.insert({"Bob", 3});
    cout << "Multimap: ";
    for (const auto& pair : mm) {
        cout << pair.first << ":" << pair.second << " "; // Output: Alice:1 Alice:2 Bob:3
    }
    cout << endl;
    cout << "Count of Alice: " << mm.count("Alice") << endl; // Output: 2

    return 0;
}
```

**Explanation**:  
- `multiset` stores duplicate elements; `multimap` stores duplicate keys.  
- Use `equal_range` for accessing all duplicates.

### 4. Comparison with Set and Map
- **Multiset vs. Set**: `multiset` allows duplicates; `set` ensures unique elements (Hour 7).  
- **Multimap vs. Map**: `multimap` allows duplicate keys; `map` ensures unique keys (Hour 8).

**Example Program**: Multiset vs. set.

```cpp
#include <iostream>
#include <set>
using namespace std;

int main() {
    // Using multiset
    multiset<int> ms;
    ms.insert(10); ms.insert(10);
    cout << "Multiset size: " << ms.size() << endl; // Output: 2
    cout << "Multiset: ";
    for (const int& x : ms) {
        cout << x << " "; // Output: 10 10
    }
    cout << endl;

    // Using set
    set<int> s;
    s.insert(10); s.insert(10);
    cout << "Set size: " << s.size() << endl; // Output: 1
    cout << "Set: ";
    for (const int& x : s) {
        cout << x << " "; // Output: 10
    }
    cout << endl;

    return 0;
}
```

**Explanation**:  
- `multiset` stores duplicates; `set` discards them.  
- `multimap` allows multiple values per key; `map` overwrites.

## Points to Remember (Interview Preparation)
1. **Multiset**: Ordered, allows duplicates, O(log n) operations, red-black tree.  
2. **Multimap**: Ordered, allows duplicate keys, O(log n) operations, no `operator[]`.  
3. **Time Complexities**:  
   - `insert`, `erase`, `find`, `count`, `equal_range`: O(log n).  
   - `count` includes O(k) for k duplicates.  
4. **Use Cases**: Multisets for frequency counting with duplicates; multimaps for multiple key-value mappings.  
5. **Safety**: Use `find` and `equal_range` for duplicates; check iterators against `end()`.  
6. **Interview Questions**: Be ready for frequency counting, top-k elements, or intersection problems.  
7. **Common Errors**: Avoid assuming unique elements/keys; use `equal_range` for duplicates.