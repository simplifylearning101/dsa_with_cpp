# Hour 12 Additional LeetCode Problems: STL Algorithms Solutions

This document provides solutions for two LeetCode problems recommended in `12_2.md`: **LeetCode 88: Merge Sorted Array** and **LeetCode 75: Sort Colors**. Each solution includes a problem description, coding pattern, optimized solution with commented C++ code using STL algorithms, complexity analysis, and test cases.

## Agenda
- Provide optimized solutions using STL algorithms and containers.  
- Explain coding patterns (e.g., sorting, two-pointer).  
- Analyze complexities and test cases.

## Outcome Expected
Students will:  
- Master STL algorithms for sorting and merging.  
- Apply techniques for array manipulation.  
- Handle edge cases for interviews.

---

## 1. LeetCode 88: Merge Sorted Array (Easy)

**Link**: [LeetCode 88](https://leetcode.com/problems/merge-sorted-array/)

**Description**:  
Merge two sorted arrays `nums1` and `nums2` into `nums1` in non-decreasing order. `nums1` has size `m + n`, with the first `m` elements valid and space for `n` elements from `nums2`.

**Constraints**:
- `nums1.length == m + n`
- `nums2.length == n`
- `0 <= m, n <= 200`
- `-10^9 <= nums1[i], nums2[i] <= 10^9`

**Example**:
- Input: `nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3`  
  Output: `[1,2,2,3,5,6]`  
  Explanation: Merge into `nums1`.

**Coding Pattern**: Merge with STL  
- Copy `nums2` into `nums1`’s extra space.  
- Use `sort` to sort the combined array.

**Optimized Solution**:
```cpp
#include <vector>
#include <algorithm>
using namespace std;

class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        // Copy nums2 into nums1's extra space
        copy(nums2.begin(), nums2.end(), nums1.begin() + m);
        // Sort nums1
        sort(nums1.begin(), nums1.end());
    }
};
```

**Time Complexity**: O((m+n) log (m+n))  
- `copy`: O(n); `sort`: O((m+n) log (m+n)).

**Space Complexity**: O(1)  
- In-place modification.

**Explanation**:  
- `copy` places `nums2` elements in `nums1`.  
- `sort` ensures non-decreasing order.

**Test Cases**:
1. **Typical Case**: `nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3` → Output: `[1,2,2,3,5,6]`  
2. **Empty nums2**: `nums1 = [1], m = 1, nums2 = [], n = 0` → Output: `[1]`  
3. **Empty nums1**: `nums1 = [0], m = 0, nums2 = [1], n = 1` → Output: `[1]`  
4. **Single Elements**: `nums1 = [1,0], m = 1, nums2 = [2], n = 1` → Output: `[1,2]`  
5. **Negative Numbers**: `nums1 = [-1,0,0], m = 1, nums2 = [-2,2], n = 2` → Output: `[-2,-1,2]`  

---

## 2. LeetCode 75: Sort Colors (Medium)

**Link**: [LeetCode 75](https://leetcode.com/problems/sort-colors/)

**Description**:  
Given an array `nums` with `n` objects colored red (0), white (1), or blue (2), sort them in-place so that objects of the same color are adjacent, in order 0, 1, 2.

**Constraints**:
- `n == nums.length`
- `1 <= n <= 300`
- `nums[i]` is 0, 1, or 2.

**Example**:
- Input: `nums = [2,0,2,1,1,0]`  
  Output: `[0,0,1,1,2,2]`  
  Explanation: Sort by color.

**Coding Pattern**: Dutch National Flag (Custom Algorithm)  
- Use two pointers and manual swapping for O(n).  
- (Note: While `sort` could be used, the problem expects a one-pass solution, so we avoid STL `sort` for optimality.)

**Optimized Solution**:
```cpp
#include <vector>
using namespace std;

class Solution {
public:
    void sortColors(vector<int>& nums) {
        int low = 0, mid = 0, high = nums.size() - 1;
        while (mid <= high) {
            if (nums[mid] == 0) {
                swap(nums[low], nums[mid]);
                low++;
                mid++;
            } else if (nums[mid] == 1) {
                mid++;
            } else {  // nums[mid] == 2
                swap(nums[mid], nums[high]);
                high--;
            }
        }
    }
};
```

**Time Complexity**: O(n)  
- Single pass with two pointers.

**Space Complexity**: O(1)  
- In-place swapping.

**Explanation**:  
- Dutch National Flag algorithm partitions array into 0s, 1s, 2s.  
- `low` tracks 0s, `high` tracks 2s, `mid` processes elements.

**Test Cases**:
1. **Typical Case**: `nums = [2,0,2,1,1,0]` → Output: `[0,0,1,1,2,2]`  
2. **Single Element**: `nums = [1]` → Output: `[1]`  
3. **All Same**: `nums = [2,2,2]` → Output: `[2,2,2]`  
4. **Two Colors**: `nums = [0,1]` → Output: `[0,1]`  
5. **Mixed**: `nums = [1,2,0]` → Output: `[0,1,2]`  

---

## Test Case Implementation
Below is a program to test both solutions with the provided test cases.

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

// LeetCode 88: Merge Sorted Array
void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
    copy(nums2.begin(), nums2.end(), nums1.begin() + m);
    sort(nums1.begin(), nums1.end());
}

// LeetCode 75: Sort Colors
void sortColors(vector<int>& nums) {
    int low = 0, mid = 0, high = nums.size() - 1;
    while (mid <= high) {
        if (nums[mid] == 0) {
            swap(nums[low], nums[mid]);
            low++;
            mid++;
        } else if (nums[mid] == 1) {
            mid++;
        } else {
            swap(nums[mid], nums[high]);
            high--;
        }
    }
}

void printVector(const vector<int>& v) {
    cout << "[";
    for (int i = 0; i < v.size(); ++i) {
        cout << v[i];
        if (i < v.size() - 1) cout << ",";
    }
    cout << "]" << endl;
}

int main() {
    // Test LeetCode 88
    cout << "LeetCode 88: Merge Sorted Array\n";
    vector<int> nums1 = {1, 2, 3, 0, 0, 0};
    vector<int> nums2 = {2, 5, 6};
    merge(nums1, 3, nums2, 3);
    cout << "Test 1: "; printVector(nums1);  // [1,2,2,3,5,6]
    
    // Test LeetCode 75
    cout << "\nLeetCode 75: Sort Colors\n";
    vector<int> nums = {2, 0, 2, 1, 1, 0};
    sortColors(nums);
    cout << "Test 1: "; printVector(nums);  // [0,0,1,1,2,2]
    
    return 0;
}
```

**Output**:
```
LeetCode 88: Merge Sorted Array
Test 1: [1,2,2,3,5,6]

LeetCode 75: Sort Colors
Test 1: [0,0,1,1,2,2]
```

## Key Takeaways
- **Merging**: Use `copy` and `sort` for simplicity, or optimize with two-pointer for O(m+n).  
- **Sorting**: Dutch National Flag algorithm is optimal for fixed values (0, 1, 2).