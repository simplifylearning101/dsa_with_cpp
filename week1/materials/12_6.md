# Hour 12 LeetCode Problem: Missing Number

This document illustrates **LeetCode 268: Missing Number**, an easy problem using STL algorithms with vectors. It includes the problem description, coding pattern, solution, complexity analysis, and test cases.

## Problem Statement: LeetCode 268 - Missing Number
**Link**: [LeetCode 268](https://leetcode.com/problems/missing-number/)

**Description**:  
Given an array `nums` containing `n` distinct numbers in the range `[0, n]`, return the only number in the range that is missing.

**Constraints**:
- `n == nums.length`
- `1 <= n <= 10^4`
- `0 <= nums[i] <= n`
- All numbers in `nums` are unique.

**Example**:
- Input: `nums = [3,0,1]`  
  Output: `2`  
  Explanation: `n = 3`, range `[0, 3]`, missing number is `2`.

**Real-World Analogy**: Finding a missing book in a numbered shelf.

## Coding Pattern: Sum with Accumulate
- Use `accumulate` to sum array elements.  
- Compute expected sum of range `[0, n]` using `n * (n + 1) / 2`.  
- Missing number is expected sum minus actual sum.

## Solution
**Algorithm**:
1. Compute actual sum using `accumulate`.  
2. Compute expected sum: `n * (n + 1) / 2`.  
3. Return difference.

**Code**:
```cpp
#include <vector>
#include <numeric>
using namespace std;

class Solution {
public:
    int missingNumber(vector<int>& nums) {
        int n = nums.size();
        int actual_sum = accumulate(nums.begin(), nums.end(), 0);
        int expected_sum = n * (n + 1) / 2;
        return expected_sum - actual_sum;
    }
};
```

**Time Complexity**: O(n)  
- `accumulate` is O(n).

**Space Complexity**: O(1)  
- Only uses variables.

**Explanation**:  
- `accumulate` sums array efficiently.  
- Formula `n * (n + 1) / 2` gives expected sum.

## Test Cases
1. **Typical Case**: `nums = [3,0,1]` → Output: `2`  
2. **Missing Zero**: `nums = [1,2,3]` → Output: `0`  
3. **Single Element**: `nums = [0]` → Output: `1`  
4. **Max Range**: `nums = [0,1,3,4]` → Output: `2`  
5. **All Present Except Last**: `nums = [0,1,2]` → Output: `3`  

**Test Case Implementation**:
```cpp
#include <iostream>
#include <vector>
#include <numeric>
using namespace std;

int missingNumber(vector<int>& nums) {
    int n = nums.size();
    int actual_sum = accumulate(nums.begin(), nums.end(), 0);
    int expected_sum = n * (n + 1) / 2;
    return expected_sum - actual_sum;
}

int main() {
    vector<int> nums1 = {3, 0, 1};
    cout << "Test 1: " << missingNumber(nums1) << endl;  // 2
    
    vector<int> nums2 = {1, 2, 3};
    cout << "Test 2: " << missingNumber(nums2) << endl;  // 0
    
    vector<int> nums3 = {0};
    cout << "Test 3: " << missingNumber(nums3) << endl;  // 1
    
    vector<int> nums4 = {0, 1, 3, 4};
    cout << "Test 4: " << missingNumber(nums4) << endl;  // 2
    
    vector<int> nums5 = {0, 1, 2};
    cout << "Test 5: " << missingNumber(nums5) << endl;  // 3
    
    return 0;
}
```

**Output**:
```
Test 1: 2
Test 2: 0
Test 3: 1
Test 4: 2
Test 5: 3
```

## Optimization Mindset
- **Efficiency**: `accumulate` avoids manual loops.  
- **Key Insight**: Use mathematical formula for range sum.  
- **Edge Cases**: Handle `n = 1`, missing `0`, or missing `n`.