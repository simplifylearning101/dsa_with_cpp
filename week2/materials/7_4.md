# Quiz: Advanced String Algorithms

30 questions: 20 on advanced string algorithms, 5 on two-pointer/sliding window for strings (Week 3, Hour 2), 5 on string basics (Week 3, Hour 1).

1. What is the purpose of the LPS array in KMP?  
2. How does KMP improve over naive substring search?  
3. Write code for KMP pattern search.  
4. What is the time complexity of KMP algorithm?  
5. Write code for Rabin-Karp substring search.  
6. How does Rabin-Karp handle hash collisions?  
7. Write code to find all occurrences of a pattern using KMP.  
8. What is the longest palindromic substring problem?  
9. Write code for longest palindromic substring.  
10. How to check if a string is a rotation of another?  
11. Write code to check string rotation.  
12. True/False: Rabin-Karp is always faster than KMP.  
13. What is the longest common substring problem?  
14. Write code for longest common substring.  
15. How to find the shortest superstring?  
16. Write code for shortest superstring.  
17. True/False: KMP uses O(n) space for LPS array.  
18. Write code for interleaving string.  
19. What is the distinct subsequences problem?  
20. Write code for distinct subsequences.  
21. (Two-Pointer/Sliding Window) What is the sliding window technique for strings?  
22. (Two-Pointer/Sliding Window) Write code for longest substring with k distinct characters.  
23. (Two-Pointer/Sliding Window) How to find all anagrams in a string?  
24. (Two-Pointer/Sliding Window) Write code for minimum window substring.  
25. (Two-Pointer/Sliding Window) What is longest repeating character replacement?  
26. (String Basics) How to check if two strings are anagrams?  
27. (String Basics) Write code to reverse a string in-place.  
28. (String Basics) What does std::string::find return if not found?  
29. (String Basics) Write code for longest common prefix.  
30. (String Basics) How to check if a string is a palindrome?

## Solutions for the Quiz

1. Tracks longest prefix that is also a suffix for pattern matching.  
2. Avoids redundant comparisons using LPS array.  
3. 
   ```cpp
   int KMPSearch(std::string text, std::string pattern) {
       int n = text.length(), m = pattern.length();
       std::vector<int> lps(m, 0);
       int len = 0, i = 1;
       while (i < m) {
           if (pattern[i] == pattern[len]) lps[i++] = ++len;
           else if (len != 0) len = lps[len - 1];
           else lps[i++] = 0;
       }
       i = 0; int j = 0;
       while (i < n) {
           if (text[i] == pattern[j]) { i++; j++; }
           if (j == m) return i - j;
           if (i < n && text[i] != pattern[j]) {
               if (j != 0) j = lps[j - 1];
               else i++;
           }
       }
       return -1;
   }
   ```
4. O(n+m).  
5. 
   ```cpp
   int RabinKarp(std::string text, std::string pattern, int q) {
       int n = text.length(), m = pattern.length(), p = 0, t = 0, h = 1, d = 256;
       for (int i = 0; i < m - 1; i++) h = (h * d) % q;
       for (int i = 0; i < m; i++) {
           p = (d * p + pattern[i]) % q;
           t = (d * t + text[i]) % q;
       }
       for (int i = 0; i <= n - m; i++) {
           if (p == t) {
               bool match = true;
               for (int j = 0; j < m; j++) {
                   if (text[i + j] != pattern[j]) { match = false; break; }
               }
               if (match) return i;
           }
           if (i < n - m) {
               t = (d * (t - text[i] * h) + text[i + m]) % q;
               if (t < 0) t += q;
           }
       }
       return -1;
   }
   ```
6. Verifies matches with character-by-character comparison.  
7. 
   ```cpp
   std::vector<int> findAllOccurrences(std::string text, std::string pattern) {
       std::vector<int> result;
       int n = text.length(), m = pattern.length();
       std::vector<int> lps(m, 0);
       int len = 0, i = 1;
       while (i < m) {
           if (pattern[i] == pattern[len]) lps[i++] = ++len;
           else if (len != 0) len = lps[len - 1];
           else lps[i++] = 0;
       }
       i = 0; int j = 0;
       while (i < n) {
           if (text[i] == pattern[j]) { i++; j++; }
           if (j == m) { result.push_back(i - j); j = lps[j - 1]; }
           if (i < n && text[i] != pattern[j]) {
               if (j != 0) j = lps[j - 1];
               else i++;
           }
       }
       return result;
   }
   ```
8. Find the longest substring that is a palindrome.  
9. 
   ```cpp
   std::string longestPalindrome(std::string s) {
       int n = s.length(), start = 0, maxLen = 1;
       for (int i = 0; i < n; i++) {
           int left = i, right = i;
           while (left >= 0 && right < n && s[left] == s[right]) {
               if (right - left + 1 > maxLen) {
                   start = left;
                   maxLen = right - left + 1;
               }
               left--; right++;
           }
           left = i; right = i + 1;
           while (left >= 0 && right < n && s[left] == s[right]) {
               if (right - left + 1 > maxLen) {
                   start = left;
                   maxLen = right - left + 1;
               }
               left--; right++;
           }
       }
       return s.substr(start, maxLen);
   }
   ```
10. Check if s2 is a rotation of s1 using concatenation or KMP.  
11. 
   ```cpp
   bool isRotation(std::string s1, std::string s2) {
       if (s1.length() != s2.length()) return false;
       std::string concat = s1 + s1;
       return concat.find(s2) != std::string::npos;
   }
   ```
12. False, KMP is O(n+m), Rabin-Karp is O(n+m) average but O(nm) worst.  
13. Find longest substring common to two strings.  
14. 
   ```cpp
   std::string longestCommonSubstring(std::string s1, std::string s2) {
       int m = s1.length(), n = s2.length(), maxLen = 0, end = 0;
       std::vector<std::vector<int>> dp(m + 1, std::vector<int>(n + 1, 0));
       for (int i = 1; i <= m; i++) {
           for (int j = 1; j <= n; j++) {
               if (s1[i - 1] == s2[j - 1]) {
                   dp[i][j] = dp[i - 1][j - 1] + 1;
                   if (dp[i][j] > maxLen) {
                       maxLen = dp[i][j];
                       end = i - 1;
                   }
               }
           }
       }
       return s1.substr(end - maxLen + 1, maxLen);
   }
   ```
15. Greedy or dynamic programming to combine strings with maximum overlap.  
16. 
   ```cpp
   std::string shortestSuperstring(std::vector<std::string>& A) {
       int n = A.size();
       std::vector<std::vector<int>> overlap(n, std::vector<int>(n, 0));
       for (int i = 0; i < n; i++) {
           for (int j = 0; j < n; j++) {
               if (i != j) {
                   for (int k = std::min(A[i].size(), A[j].size()); k >= 0; k--) {
                       if (A[i].substr(A[i].size() - k) == A[j].substr(0, k)) {
                           overlap[i][j] = k;
                           break;
                       }
                   }
               }
           }
       }
       std::vector<int> path;
       std::string result = A[0];
       for (int i = 1; i < n; i++) {
           int maxOverlap = 0, bestJ = -1;
           for (int j = 0; j < n; j++) {
               if (std::find(path.begin(), path.end(), j) == path.end() && overlap[i - 1][j] > maxOverlap) {
                   maxOverlap = overlap[i - 1][j];
                   bestJ = j;
               }
           }
           path.push_back(bestJ);
           result += A[bestJ].substr(maxOverlap);
       }
       return result;
   }
   ```
17. True, LPS array is O(m) where m is pattern length.  
18. 
   ```cpp
   bool isInterleave(std::string s1, std::string s2, std::string s3) {
       if (s1.length() + s2.length() != s3.length()) return false;
       std::vector<std::vector<bool>> dp(s1.length() + 1, std::vector<bool>(s2.length() + 1, false));
       dp[0][0] = true;
       for (int i = 0; i <= s1.length(); i++) {
           for (int j = 0; j <= s2.length(); j++) {
               if (i > 0 && s1[i - 1] == s3[i + j - 1]) dp[i][j] |= dp[i - 1][j];
               if (j > 0 && s2[j - 1] == s3[i + j - 1]) dp[i][j] |= dp[i][j - 1];
           }
       }
       return dp[s1.length()][s2.length()];
   }
   ```
19. Count distinct subsequences of t in s.  
20. 
   ```cpp
   int numDistinct(std::string s, std::string t) {
       int m = s.length(), n = t.length();
       std::vector<std::vector<long>> dp(m + 1, std::vector<long>(n + 1, 0));
       for (int i = 0; i <= m; i++) dp[i][0] = 1;
       for (int i = 1; i <= m; i++) {
           for (int j = 1; j <= n; j++) {
               dp[i][j] = dp[i - 1][j];
               if (s[i - 1] == t[j - 1]) dp[i][j] += dp[i - 1][j - 1];
           }
       }
       return dp[m][n];
   }
   ```
21. Uses two pointers to maintain a dynamic window for substring problems.  
22. 
   ```cpp
   int lengthOfLongestSubstringKDistinct(std::string s, int k) {
       std::unordered_map<char, int> map;
       int left = 0, maxLen = 0;
       for (int right = 0; right < s.size(); right++) {
           map[s[right]]++;
           while (map.size() > k) {
               map[s[left]]--;
               if (map[s[left]] == 0) map.erase(s[left]);
               left++;
           }
           maxLen = std::max(maxLen, right - left + 1);
       }
       return maxLen;
   }
   ```
23. Use sliding window with frequency array.  
24. 
   ```cpp
   std::string minWindow(std::string s, std::string t) {
       std::unordered_map<char, int> tMap, sMap;
       for (char c : t) tMap[c]++;
       int required = tMap.size(), formed = 0, left = 0, minLen = s.size() + 1, minLeft = 0;
       for (int right = 0; right < s.size(); right++) {
           sMap[s[right]]++;
           if (tMap.count(s[right]) && sMap[s[right]] == tMap[s[right]]) formed++;
           while (formed == required && left <= right) {
               if (right - left + 1 < minLen) {
                   minLen = right - left + 1;
                   minLeft = left;
               }
               sMap[s[left]]--;
               if (tMap.count(s[left]) && sMap[s[left]] < tMap[s[left]]) formed--;
               left++;
           }
       }
       return minLen > s.size() ? "" : s.substr(minLeft, minLen);
   }
   ```
25. Find longest substring with k replacements to make all characters same.  
26. Sort or use frequency array.  
27. 
   ```cpp
   void reverseString(std::string& s) {
       int left = 0, right = s.length() - 1;
       while (left < right) std::swap(s[left++], s[right--]);
   }
   ```
28. std::string::npos.  
29. 
   ```cpp
   std::string longestCommonPrefix(std::vector<std::string>& strs) {
       if (strs.empty()) return "";
       std::string prefix = strs[0];
       for (int i = 1; i < strs.size(); i++) {
           while (strs[i].find(prefix) != 0) {
               prefix = prefix.substr(0, prefix.length() - 1);
               if (prefix.empty()) return "";
           }
       }
       return prefix;
   }
   ```
30. Use two-pointer to compare characters from ends.