# Deep Dive into C++ STL Multisets and Multimaps

This document is an advanced exploration of STL `multiset` and `multimap` for students aiming to master these containers for coding interviews. It covers internals, advanced applications, and interview questions with detailed answers, building on Hours 1–8.

## Agenda
- Deep dive into multiset and multimap internals, operations, and optimizations.
- Illustrate complex scenarios with commented programs.
- Prepare for interviews with challenging questions and answers.

## Outcome Expected
Students will:
- Understand `multiset` and `multimap` internals (red-black tree).  
- Master advanced applications (e.g., frequency counting, top-k elements, intersections).  
- Optimize performance and handle edge cases.  
- Answer complex multiset/multimap-related interview questions confidently.

## Topics Covered
1. **Multiset Internals**  
   - Red-black tree structure and balancing.  
   - Performance characteristics (O(log n)).  
   - Real-world analogy: Multiset as a sorted attendance log.  
2. **Multimap Internals**  
   - Red-black tree structure for key-value pairs.  
   - Performance characteristics (O(log n)).  
   - Real-world analogy: Multimap as a course enrollment system.  
3. **Advanced Applications**  
   - Frequency counting, top-k elements, and intersection problems.  
   - Handling duplicates in pattern matching.  
4. **Optimization and Pitfalls**  
   - Choosing `multiset` vs. `set`, `multimap` vs. `map`.  
   - Efficient duplicate handling with `equal_range`.

## Detailed Explanation

### 1. Multiset Internals
STL `multiset` is implemented as a red-black tree, allowing duplicate elements in sorted order. Think of it as a sorted attendance log where multiple entries for the same person are allowed.

- **Structure**: Nodes with parent-child links, balanced for O(log n).  
- **Performance**: O(log n) for `insert`, `erase`, `find`; O(log n + k) for `count`.  
- **Limitations**: No random access; elements immutable (erase and re-insert to modify).

**Example Program**: Multiset with custom comparator.

```cpp
#include <iostream>
#include <set>
using namespace std;

struct Compare {
    bool operator()(const int& a, const int& b) const {
        return a > b; // Reverse order
    }
};

int main() {
    multiset<int, Compare> ms;
    
    // Insert elements
    ms.insert(10); ms.insert(20); ms.insert(10);
    
    // Print in reverse order
    cout << "Multiset: ";
    for (const int& x : ms) {
        cout << x << " "; // Output: 20 10 10
    }
    cout << endl;
    
    return 0;
}
```

**Explanation**:  
- Custom comparator reverses sort order.  
- Red-black tree maintains order with duplicates.

### 2. Multimap Internals
STL `multimap` uses a red-black tree to store key-value pairs, allowing duplicate keys. Think of it as a course enrollment system where one student can enroll in multiple courses.

- **Structure**: Nodes store key-value pairs, balanced for O(log n).  
- **Performance**: O(log n) for `insert`, `erase`, `find`, `equal_range`.  
- **Limitations**: No `operator[]`; values immutable.

**Example Program**: Multimap with duplicate keys.

```cpp
#include <iostream>
#include <map>
#include <string>
using namespace std;

int main() {
    multimap<string, int> enrollments;
    
    // Insert key-value pairs
    enrollments.insert({"Alice", 101}); enrollments.insert({"Alice", 102}); enrollments.insert({"Bob", 103});
    
    // Print enrollments
    cout << "Enrollments: ";
    for (const auto& pair : enrollments) {
        cout << pair.first << ":" << pair.second << " "; // Output: Alice:101 Alice:102 Bob:103
    }
    cout << endl;
    
    // Get all courses for Alice
    auto range = enrollments.equal_range("Alice");
    cout << "Alice's courses: ";
    for (auto it = range.first; it != range.second; ++it) {
        cout << it->second << " "; // Output: 101 102
    }
    cout << endl;
    
    return 0;
}
```

**Explanation**:  
- `equal_range` retrieves all pairs for a key.  
- No `operator[]` due to duplicate keys.

### 3. Advanced Applications
Multisets and multimaps are ideal for problems involving duplicates, such as frequency counting or top-k elements.

**Example Program**: Top k frequent elements.

```cpp
#include <iostream>
#include <set>
#include <unordered_map>
#include <vector>
using namespace std;

vector<int> topKFrequent(const vector<int>& nums, int k) {
    unordered_map<int, int> freq;
    for (int num : nums) {
        freq[num]++;
    }
    multiset<pair<int, int>, greater<pair<int, int>>> ms; // {freq, num}
    for (const auto& pair : freq) {
        ms.insert({pair.second, pair.first});
    }
    vector<int> result;
    auto it = ms.begin();
    for (int i = 0; i < k; ++i) {
        result.push_back(it->second);
        ++it;
    }
    return result;
}

int main() {
    vector<int> nums = {1, 1, 1, 2, 2, 3};
    int k = 2;
    vector<int> result = topKFrequent(nums, k);
    cout << "[";
    for (int i = 0; i < result.size(); ++i) {
        cout << result[i] << (i < result.size() - 1 ? "," : "");
    }
    cout << "]" << endl; // Output: [1,2]
    return 0;
}
```

**Explanation**:  
- `multiset` sorts by frequency for top-k selection.  
- O(n log n) for sorting frequencies; efficient for small datasets.

### 4. Optimization and Pitfalls
- **Optimization**: Use `multiset` for sorted duplicates; `multimap` for multiple key-value mappings.  
- **Pitfalls**: Avoid assuming uniqueness; use `equal_range` for duplicates.

**Example Program**: Safe multimap operations.

```cpp
#include <iostream>
#include <map>
#include <string>
using namespace std;

int main() {
    multimap<string, int> mm;
    mm.insert({"apple", 5}); mm.insert({"apple", 3});
    
    // Safe access with equal_range
    string key = "apple";
    auto range = mm.equal_range(key);
    cout << key << ": ";
    for (auto it = range.first; it != range.second; ++it) {
        cout << it->second << " "; // Output: 5 3
    }
    cout << endl;
    
    // Count check
    cout << "Count of apple: " << mm.count(key) << endl; // Output: 2
    
    return 0;
}
```

**Explanation**:  
- Use `equal_range` to handle duplicate keys safely.  
- Avoid direct value modification; erase and re-insert.

## Interview Questions and Answers
Below are 15 advanced interview questions on multisets and multimaps.

1. **Question**: What is the primary difference between `multiset` and `set`?  
   **Answer**: `multiset` allows duplicates; `set` ensures unique elements.  
   **Interviewer’s Intention**: Tests container understanding.

2. **Question**: Why use a red-black tree for `multiset`?**  
   **Answer**: Ensures O(log n) operations and sorted order with duplicates.  
   **Interviewer’s Intention**: Checks internal structure knowledge.

3. **Question**: What is the time complexity of `multimap::equal_range`?**  
   **Answer**: O(log n) to find range.  
   **Interviewer’s Intention**: Tests performance awareness.

4. **Question**: Write a program to find top k frequent elements.  
   **Answer**: (See above example.)  
   **Interviewer’s Intention**: Tests multiset application.

5. **Question**: How do you handle duplicate keys in a multimap?**  
   **Answer**: `multimap` stores all key-value pairs; use `equal_range`.  
   **Interviewer’s Intention**: Tests duplicate handling.

6. **Question**: What is the difference between `multimap` and `map`?**  
   **Answer**: `multimap` allows duplicate keys; `map` does not.  
   **Interviewer’s Intention**: Tests container differences.

7. **Question**: Write a program to count frequencies with a multiset.  
   **Answer**: (See homework solution 5.)  
   **Interviewer’s Intention**: Tests frequency counting.

8. **Question**: Why can’t you use `operator[]` in a multimap?**  
   **Answer**: Duplicate keys make `operator[]` ambiguous.  
   **Interviewer’s Intention**: Tests container limitations.

9. **Question**: When should you use `multiset` over `vector`?**  
   **Answer**: Use `multiset` for sorted duplicates; `vector` for indexed access.  
   **Interviewer’s Intention**: Tests container selection.

10. **Question**: Write a program to simulate a phone book with multimap.  
    **Answer**: (See homework solution 9.)  
    **Interviewer’s Intention**: Tests practical application.

11. **Question**: What is the space complexity of `multiset`?**  
    **Answer**: O(n) for n elements.  
    **Interviewer’s Intention**: Tests complexity awareness.

12. **Question**: Write a program to find the intersection of two arrays.  
    **Answer**: (See homework solution 7.)  
    **Interviewer’s Intention**: Tests intersection handling.

13. **Question**: Why use `equal_range` in `multimap`?**  
    **Answer**: Retrieves all pairs for a key efficiently.  
    **Interviewer’s Intention**: Tests duplicate access.

14. **Question**: How do you create a multiset with a custom comparator?**  
    **Answer**: Define a comparator struct (see custom comparator example).  
    **Interviewer’s Intention**: Tests advanced usage.

15. **Question**: Write a program to sort characters by frequency.  
    **Answer**: (See homework solution 8.)  
    **Interviewer’s Intention**: Tests frequency sorting.

## Practice Recommendations
- Solve LeetCode problems like **Top K Frequent Elements** and **Sort Characters By Frequency**.  
- Experiment with custom comparators for sorting.  
- Practice safe operations with `equal_range` and `count`.