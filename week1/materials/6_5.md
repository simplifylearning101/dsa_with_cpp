# Deep Dive into C++ STL Priority Queues

This document is an advanced exploration of STL `priority_queue` for students aiming to master heap-based algorithms for coding interviews. It covers internals, advanced applications, and interview questions with detailed answers, building on Hours 1–5 (vectors, arrays/deques, strings, stacks, queues).

## Agenda
- Deep dive into priority queue internals, operations, and optimizations.
- Illustrate complex scenarios with commented programs.
- Prepare for interviews with challenging questions and answers.

## Outcome Expected
Students will:
- Understand priority queue internals (container adapter, heap).  
- Master advanced applications (e.g., kth largest, merging sorted data, stream processing).  
- Optimize performance and handle edge cases.  
- Answer complex priority queue-related interview questions confidently.

## Topics Covered
1. **Priority Queue Internals**  
   - Container adapter design, underlying vector.  
   - Heap properties and performance characteristics.  
   - Real-world analogy: Priority queue as an airport security line.  
2. **Advanced Applications**  
   - Kth largest/smallest problems.  
   - Merging sorted streams with priority queues.  
   - Real-world analogy: Task prioritization in a CPU scheduler.  
3. **Optimization and Pitfalls**  
   - Choosing max-heap vs. min-heap.  
   - Handling empty queue errors.  
   - Custom comparators for complex objects.  

## Detailed Explanation

### 1. Priority Queue Internals
STL `priority_queue` is a container adapter that wraps a vector (default) or deque to maintain a heap structure. By default, it’s a max-heap, ensuring the largest element is at the top. Think of it as an airport security line where high-priority passengers (e.g., VIPs) are processed first.

- **Container Adapter**: Wraps `vector` or `deque`.  
- **Performance**: O(log n) for `push`/`pop`, O(1) for `top`.  
- **Limitations**: No iterators, only top element accessible.

**Example Program**: Priority queue with custom container.

```cpp
#include <iostream>
#include <queue>
#include <deque>
using namespace std;

int main() {
    // Priority queue with deque
    priority_queue<int, deque<int>> pq;
    
    // Push elements
    pq.push(1); pq.push(3); pq.push(2);
    
    // Print size and top
    cout << "Size: " << pq.size() << endl; // Output: 3
    cout << "Top: " << pq.top() << endl; // Output: 3
    pq.pop();
    cout << "After pop, top: " << pq.top() << endl; // Output: 2
    
    return 0;
}
```

**Explanation**:  
- `priority_queue<int, deque<int>>`: Uses deque instead of vector.  
- Operations remain O(log n) for push/pop, O(1) for top.  
- Deque is rarely used but valid for specific cases.

### 2. Advanced Applications
Priority queues excel in problems like finding kth largest/smallest elements, merging sorted streams, and processing data with priorities, such as CPU task scheduling.

**Example Program**: Kth largest element using min-heap.

```cpp
#include <iostream>
#include <queue>
#include <vector>
using namespace std;

int findKthLargest(const vector<int>& nums, int k) {
    priority_queue<int, vector<int>, greater<int>> pq; // Min-heap
    for (int num : nums) {
        pq.push(num);
        if (pq.size() > k) {
            pq.pop(); // Keep only k largest
        }
    }
    return pq.top();
}

int main() {
    vector<int> nums = {3, 2, 1, 5, 6, 4};
    int k = 2;
    cout << "Kth largest: " << findKthLargest(nums, k) << endl; // Output: 5
    return 0;
}
```

**Explanation**:  
- Min-heap keeps the k largest elements.  
- Pop smallest when size exceeds k, ensuring top is kth largest.  
- Efficient for large arrays with small k.

### 3. Optimization and Pitfalls
- **Optimization**: Use min-heap for kth largest; max-heap for kth smallest.  
- **Pitfalls**: Check `empty()` before `top` or `pop`; avoid invalid comparators.

**Example Program**: Custom comparator for pairs.

```cpp
#include <iostream>
#include <queue>
#include <vector>
using namespace std;

struct Compare {
    bool operator()(const pair<int, int>& a, const pair<int, int>& b) {
        return a.first > b.first; // Min-heap on first element
    }
};

int main() {
    priority_queue<pair<int, int>, vector<pair<int, int>>, Compare> pq;
    pq.push({3, 1}); pq.push({1, 2}); pq.push({2, 3});
    
    // Print in ascending order of first element
    while (!pq.empty()) {
        cout << pq.top().first << "," << pq.top().second << " "; // Output: 1,2 2,3 3,1
        pq.pop();
    }
    cout << endl;
    
    return 0;
}
```

**Explanation**:  
- Custom comparator enables min-heap on pair’s first element.  
- Useful for problems like k closest points or custom prioritization.

## Interview Questions and Answers
Below are 15 advanced interview questions on priority queues.

1. **Question**: What is a priority queue’s primary characteristic?  
   **Answer**: Maintains elements in heap order (max or min).  
   **Interviewer’s Intention**: Tests basic understanding.

2. **Question**: Why use `vector` as the default container?**  
   **Answer**: Provides O(1) random access for heap operations.  
   **Interviewer’s Intention**: Checks container knowledge.

3. **Question**: What is the time complexity of `push`?**  
   **Answer**: O(log n).  
   **Interviewer’s Intention**: Tests operation cost awareness.

4. **Question**: Write a program to find kth largest element.  
   **Answer**: (See above example.)  
   **Interviewer’s Intention**: Tests min-heap application.

5. **Question**: How do you handle empty priority queue errors?**  
   **Answer**: Check `empty()` before `top` or `pop`.  
   **Interviewer’s Intention**: Ensures error handling.

6. **Question**: What is a min-heap priority queue?**  
   **Answer**: Priority queue where smallest element is at the top, using `greater<T>`.  
   **Interviewer’s Intention**: Tests custom comparator knowledge.

7. **Question**: Write a program to merge k sorted arrays.  
   **Answer**: (See homework solution 7.)  
   **Interviewer’s Intention**: Tests multi-stream merging.

8. **Question**: Why can’t you iterate a priority queue?**  
   **Answer**: Restricts to top access; no iterators provided.  
   **Interviewer’s Intention**: Tests container limitations.

9. **Question**: When should you use a priority queue over a set?**  
   **Answer**: Use priority queue for dynamic prioritization; set for unique sorted elements.  
   **Interviewer’s Intention**: Tests container selection.

10. **Question**: Write a program to simulate a priority-based task queue.  
    **Answer**:  
```cpp
#include <iostream>
#include <queue>
#include <string>
using namespace std;

void processTasks(const vector<pair<string, int>>& tasks) {
    priority_queue<pair<int, string>> pq;
    for (const auto& task : tasks) {
        pq.push({task.second, task.first});
    }
    while (!pq.empty()) {
        cout << "Processing: " << pq.top().second << endl;
        pq.pop();
    }
}

int main() {
    vector<pair<string, int>> tasks = {{"Task1", 2}, {"Task2", 5}, {"Task3", 1}};
    processTasks(tasks); // Output: Processing: Task2, Processing: Task1, Processing: Task3
    return 0;
}
```
    **Interviewer’s Intention**: Tests priority queue application.

11. **Question**: What is the space complexity of a priority queue?**  
    **Answer**: O(n), where n is number of elements.  
    **Interviewer’s Intention**: Tests complexity awareness.

12. **Question**: Write a program to find top k frequent elements.  
    **Answer**: (See homework solution 9.)  
    **Interviewer’s Intention**: Tests frequency-based problems.

13. **Question**: Why use a priority queue for task scheduling?**  
    **Answer**: Prioritizes tasks by urgency or weight.  
    **Interviewer’s Intention**: Tests real-world application.

14. **Question**: How do you create a min-heap for custom objects?**  
    **Answer**: Define a comparator struct or function (see custom comparator example).  
    **Interviewer’s Intention**: Tests advanced usage.

15. **Question**: Write a program to find median from a data stream.  
    **Answer**: (See homework solution 10.)  
    **Interviewer’s Intention**: Tests two-heap technique.

## Practice Recommendations
- Solve LeetCode problems like **Merge k Sorted Lists** and **Kth Largest Element**.  
- Experiment with custom comparators for complex objects.  
- Practice safe priority queue operations with `empty()` checks.