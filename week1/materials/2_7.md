# Hour 2 Additional LeetCode Problems: Array and Deque Solutions

This document provides detailed solutions for four LeetCode problems recommended in `2_2.md` to reinforce C++ STL array and deque usage: **LeetCode 933: Number of Recent Calls**, **LeetCode 622: Design Circular Queue**, **LeetCode 346: Moving Average from Data Stream**, and **LeetCode 1679: Max Number of K-Sum Pairs**. Each solution includes a problem description, coding pattern, optimized solution with comprehensive comments, time and space complexity analysis, and test cases covering typical and edge cases. The solutions leverage arrays and deques, aligning with Hour 2’s focus and preparing students for coding interviews.

## Agenda
- Provide optimized solutions for four LeetCode problems using STL arrays and deques.
- Explain coding patterns (e.g., deque for queues, arrays for fixed-size buffers, Two Pointers).
- Analyze time and space complexities.
- Include test cases to ensure robustness across various scenarios.

## Outcome Expected
By studying these solutions, students will:
- Master deque usage for queue-based problems and sliding window scenarios.
- Understand how to use arrays for fixed-size data structures.
- Apply queue-based patterns or Two Pointers to solve problems efficiently.
- Handle edge cases and analyze complexities for interview problems.
- Gain confidence in solving array- and deque-based LeetCode problems.

---

## 1. LeetCode 933: Number of Recent Calls (Easy)

**Link**: [LeetCode 933](https://leetcode.com/problems/number-of-recent-calls/)

**Description**:  
Implement a `RecentCounter` class that counts the number of requests in the last 3000 milliseconds. The class has one method, `ping(t)`, which accepts a time `t` (in milliseconds) and returns the number of pings in the inclusive range `[t-3000, t]`.

**Constraints**:
- `1 <= t <= 10^9`
- Each `t` is strictly increasing.
- At most `10^4` calls to `ping`.

**Example**:
- Input: `["RecentCounter","ping","ping","ping","ping"]`, `[[],[1],[100],[3001],[3002]]`  
  Output: `[null,1,2,3,3]`  
  Explanation:
  - `ping(1)`: Window [-2999, 1] → 1 ping.
  - `ping(100)`: Window [-2900, 100] → 2 pings (1, 100).
  - `ping(3001)`: Window [1, 3001] → 3 pings (1, 100, 3001).
  - `ping(3002)`: Window [2, 3002] → 3 pings (100, 3001, 3002).

**Coding Pattern**: Sliding Window with Deque  
- Use a deque to store timestamps of pings.
- Remove timestamps outside the 3000ms window (`t-3000`).
- The deque’s size is the number of valid pings.

**Optimized Solution**:
```cpp
#include <deque>
using namespace std;

class RecentCounter {
private:
    deque<int> requests; // Stores timestamps of pings

public:
    RecentCounter() {
        // Initialize empty deque
    }
    
    int ping(int t) {
        // Add new timestamp to back
        requests.push_back(t);
        
        // Remove timestamps outside the window [t-3000, t]
        while (!requests.empty() && requests.front() < t - 3000) {
            requests.pop_front(); // O(1) operation
        }
        
        // Return number of pings in window
        return requests.size();
    }
};
```

**Time Complexity**: O(1) amortized per `ping`  
- Each timestamp is pushed and popped at most once across all calls.
- Amortized O(1) per operation, though a single `ping` may pop multiple elements.

**Space Complexity**: O(N), where N is the number of pings in a 3000ms window  
- Deque stores at most the number of timestamps within [t-3000, t].

**Explanation**:
- `push_back(t)`: Adds the new timestamp.
- `pop_front()`: Removes timestamps older than `t-3000`.
- `size()`: Returns the count of valid pings.
- Deque’s O(1) front/back operations make it ideal for this sliding window problem.

**Test Cases**:
1. **Typical Case**: `pings = [1, 100, 3001, 3002]` → Output: `[1, 2, 3, 3]`  
2. **Single Ping**: `pings = [1]` → Output: `[1]`  
3. **Large Gap**: `pings = [1, 4000]` → Output: `[1, 1]`  
4. **Dense Pings**: `pings = [1, 2, 3, 4]` → Output: `[1, 2, 3, 4]`  
5. **Edge Case (Max t)**: `pings = [1000000000]` → Output: `[1]`  

---

## 2. LeetCode 622: Design Circular Queue (Medium)

**Link**: [LeetCode 622](https://leetcode.com/problems/design-circular-queue/)

**Description**:  
Design a circular queue with a fixed size `k`. Implement methods: `enQueue(value)`, `deQueue()`, `Front()`, `Rear()`, `isEmpty()`, `isFull()`. The queue should reuse space after dequeuing.

**Constraints**:
- `1 <= k <= 1000`
- `0 <= value <= 1000`
- At most 3000 calls to methods.

**Example**:
- Input: `["MyCircularQueue","enQueue","enQueue","enQueue","enQueue","Rear","isFull","deQueue","enQueue","Rear"]`, `[[3],[1],[2],[3],[4],[],[],[],[4],[]]`  
  Output: `[null,true,true,true,false,3,true,true,true,4]`  
  Explanation: Queue of size 3 enqueues 1, 2, 3; rejects 4; returns rear (3); dequeues; enqueues 4; returns rear (4).

**Coding Pattern**: Circular Buffer with Array  
- Use an STL `array` to store elements in a fixed-size buffer.
- Maintain `front` and `rear` indices to track the queue’s boundaries.
- Use modulo arithmetic to wrap around indices.

**Optimized Solution**:
```cpp
#include <array>
using namespace std;

class MyCircularQueue {
private:
    array<int, 1001> buffer; // Fixed-size array (k <= 1000)
    int front, rear, size, capacity;

public:
    MyCircularQueue(int k) : front(0), rear(-1), size(0), capacity(k) {
        // Initialize empty queue
    }
    
    bool enQueue(int value) {
        if (isFull()) return false;
        rear = (rear + 1) % capacity; // Move rear forward
        buffer[rear] = value; // Add element
        size++;
        return true;
    }
    
    bool deQueue() {
        if (isEmpty()) return false;
        front = (front + 1) % capacity; // Move front forward
        size--;
        return true;
    }
    
    int Front() {
        if (isEmpty()) return -1;
        return buffer[front];
    }
    
    int Rear() {
        if (isEmpty()) return -1;
        return buffer[rear];
    }
    
    bool isEmpty() {
        return size == 0;
    }
    
    bool isFull() {
        return size == capacity;
    }
};
```

**Time Complexity**: O(1) per operation  
- All operations (`enQueue`, `deQueue`, `Front`, `Rear`, `isEmpty`, `isFull`) are O(1).

**Space Complexity**: O(k)  
- Fixed-size array of size `k+1` to accommodate constraints.

**Explanation**:
- `array<int, 1001>`: Fixed-size buffer (k ≤ 1000).
- `front`: Index of the first element.
- `rear`: Index of the last element.
- `size`: Tracks current number of elements.
- Modulo (`% capacity`) ensures circular wrapping.

**Test Cases**:
1. **Typical Case**: `k=3, enQueue(1,2,3), enQueue(4), Rear, deQueue, enQueue(4), Rear` → Output: `[true,true,true,false,3,true,true,4]`  
2. **Empty Queue**: `k=1, Front` → Output: `[-1]`  
3. **Full Queue**: `k=1, enQueue(1), enQueue(2)` → Output: `[true,false]`  
4. **Single Operation**: `k=2, enQueue(1), Front` → Output: `[true,1]`  
5. **Wrap Around**: `k=2, enQueue(1,2), deQueue, enQueue(3)` → Output: `[true,true,true,true]`  

---

## 3. LeetCode 346: Moving Average from Data Stream (Easy)

**Link**: [LeetCode 346](https://leetcode.com/problems/moving-average-from-data-stream/)

**Description**:  
Implement a `MovingAverage` class that calculates the average of the last `size` elements in a data stream. Method `next(val)` adds `val` to the stream and returns the average of the last `size` elements.

**Constraints**:
- `1 <= size <= 1000`
- `-10^5 <= val <= 10^5`
- At most `10^4` calls to `next`.

**Example**:
- Input: `["MovingAverage","next","next","next","next"]`, `[[3],[1],[10],[3],[5]]`  
  Output: `[null,1.0,5.5,4.66667,6.0]`  
  Explanation:
  - `next(1)`: Window [1] → 1.0
  - `next(10)`: Window [1,10] → 5.5
  - `next(3)`: Window [1,10,3] → 4.66667
  - `next(5)`: Window [10,3,5] → 6.0

**Coding Pattern**: Sliding Window with Deque  
- Use a deque to store the last `size` elements.
- Maintain a running sum to compute averages efficiently.
- Remove old elements when the window size is exceeded.

**Optimized Solution**:
```cpp
#include <deque>
using namespace std;

class MovingAverage {
private:
    deque<int> window; // Stores last size elements
    int size; // Window size
    double sum; // Running sum for average

public:
    MovingAverage(int s) : size(s), sum(0.0) {
        // Initialize empty deque and sum
    }
    
    double next(int val) {
        window.push_back(val); // Add new value
        sum += val; // Update sum
        
        // Remove element if window exceeds size
        if (window.size() > size) {
            sum -= window.front();
            window.pop_front();
        }
        
        // Return average
        return sum / window.size();
    }
};
```

**Time Complexity**: O(1) amortized per `next`  
- Push and pop operations are O(1).
- Each element is pushed/popped at most once.

**Space Complexity**: O(size)  
- Deque stores at most `size` elements.

**Explanation**:
- `push_back(val)`: Adds new value to the window.
- `sum`: Tracks total to avoid recomputing.
- `pop_front()`: Removes oldest element when window size is exceeded.
- Average is `sum / window.size()`.

**Test Cases**:
1. **Typical Case**: `size=3, next(1,10,3,5)` → Output: `[1.0,5.5,4.66667,6.0]`  
2. **Single Value**: `size=1, next(1)` → Output: `[1.0]`  
3. **Large Window**: `size=3, next(1,1,1)` → Output: `[1.0,1.0,1.0]`  
4. **Negative Values**: `size=2, next(-1,-2)` → Output: `[-1.0,-1.5]`  
5. **Full Window**: `size=2, next(1,2,3)` → Output: `[1.0,1.5,2.5]`  

---

## 4. LeetCode 1679: Max Number of K-Sum Pairs (Medium)

**Link**: [LeetCode 1679](https://leetcode.com/problems/max-number-of-k-sum-pairs/)

**Description**:  
Given an integer array `nums` and an integer `k`, find the maximum number of pairs `(nums[i], nums[j])` such that `nums[i] + nums[j] == k`. Remove each pair found.

**Constraints**:
- `1 <= nums.length <= 10^5`
- `1 <= nums[i] <= 10^9`
- `1 <= k <= 10^9`

**Example**:
- Input: `nums = [1,2,3,4], k = 5`  
  Output: `2`  
  Explanation: Pairs (1,4) and (2,3) sum to 5.

**Coding Pattern**: Two Pointers with Sorted Array  
- Sort the array to use Two Pointers.
- Use `array` for fixed-size storage if size is known, or vector for flexibility.
- Move pointers based on sum comparison to find pairs.

**Optimized Solution**:
```cpp
#include <vector>
#include <algorithm>
using namespace std;

class Solution {
public:
    int maxOperations(vector<int>& nums, int k) {
        // Sort the array
        sort(nums.begin(), nums.end());
        
        int left = 0, right = nums.size() - 1;
        int count = 0;
        
        // Use two pointers to find pairs
        while (left < right) {
            int sum = nums[left] + nums[right];
            if (sum == k) {
                count++; // Found a valid pair
                left++;
                right--;
            } else if (sum < k) {
                left++; // Need larger sum
            } else {
                right--; // Need smaller sum
            }
        }
        
        return count;
    }
};
```

**Time Complexity**: O(n log n)  
- Sorting: O(n log n).
- Two Pointers: O(n).
- Total: O(n log n).

**Space Complexity**: O(1)  
- In-place sorting and two pointers.

**Explanation**:
- Sort `nums` to enable Two Pointers.
- `left` points to the smallest element, `right` to the largest.
- Adjust pointers based on `nums[left] + nums[right]` vs. `k`.
- Note: Uses `vector` as input, but `array` could be used if size is fixed and known.

**Test Cases**:
1. **Typical Case**: `nums = [1,2,3,4], k = 5` → Output: `2`  
2. **No Pairs**: `nums = [1,2,3], k = 10` → Output: `0`  
3. **All Pairs**: `nums = [3,3,3,3], k = 6` → Output: `2`  
4. **Single Element**: `nums = [1], k = 2` → Output: `0`  
5. **Duplicates**: `nums = [2,2,2,2], k = 4` → Output: `2`  

---

## Test Case Implementation
Below is a program to test all four solutions with the provided test cases.

```cpp
#include <iostream>
#include <vector>
#include <deque>
#include <array>
#include <algorithm>
using namespace std;

// LeetCode 933: Number of Recent Calls
class RecentCounter {
private:
    deque<int> requests;
public:
    RecentCounter() {}
    int ping(int t) {
        requests.push_back(t);
        while (!requests.empty() && requests.front() < t - 3000) {
            requests.pop_front();
        }
        return requests.size();
    }
};

// LeetCode 622: Design Circular Queue
class MyCircularQueue {
private:
    array<int, 1001> buffer;
    int front, rear, size, capacity;
public:
    MyCircularQueue(int k) : front(0), rear(-1), size(0), capacity(k) {}
    bool enQueue(int value) {
        if (isFull()) return false;
        rear = (rear + 1) % capacity;
        buffer[rear] = value;
        size++;
        return true;
    }
    bool deQueue() {
        if (isEmpty()) return false;
        front = (front + 1) % capacity;
        size--;
        return true;
    }
    int Front() {
        if (isEmpty()) return -1;
        return buffer[front];
    }
    int Rear() {
        if (isEmpty()) return -1;
        return buffer[rear];
    }
    bool isEmpty() { return size == 0; }
    bool isFull() { return size == capacity; }
};

// LeetCode 346: Moving Average from Data Stream
class MovingAverage {
private:
    deque<int> window;
    int size;
    double sum;
public:
    MovingAverage(int s) : size(s), sum(0.0) {}
    double next(int val) {
        window.push_back(val);
        sum += val;
        if (window.size() > size) {
            sum -= window.front();
            window.pop_front();
        }
        return sum / window.size();
    }
};

// LeetCode 1679: Max Number of K-Sum Pairs
int maxOperations(vector<int>& nums, int k) {
    sort(nums.begin(), nums.end());
    int left = 0, right = nums.size() - 1;
    int count = 0;
    while (left < right) {
        int sum = nums[left] + nums[right];
        if (sum == k) {
            count++;
            left++;
            right--;
        } else if (sum < k) {
            left++;
        } else {
            right--;
        }
    }
    return count;
}

// Helper function to print vector
void printVector(const vector<int>& v) {
    cout << "[";
    for (size_t i = 0; i < v.size(); ++i) {
        cout << v[i];
        if (i < v.size() - 1) cout << ",";
    }
    cout << "]" << endl;
}

// Helper function to print vector of doubles
void printVectorDouble(const vector<double>& v) {
    cout << "[";
    for (size_t i = 0; i < v.size(); ++i) {
        cout << fixed << setprecision(5) << v[i];
        if (i < v.size() - 1) cout << ",";
    }
    cout << "]" << endl;
}

int main() {
    // Test LeetCode 933
    cout << "LeetCode 933: Number of Recent Calls\n";
    RecentCounter rc;
    vector<int> pings = {1, 100, 3001, 3002};
    cout << "Test 1: ";
    for (int t : pings) cout << rc.ping(t) << " "; // Output: 1 2 3 3
    cout << endl;

    // Test LeetCode 622
    cout << "\nLeetCode 622: Design Circular Queue\n";
    MyCircularQueue q(3);
    cout << "Test 1: ";
    cout << q.enQueue(1) << " "; // true
    cout << q.enQueue(2) << " "; // true
    cout << q.enQueue(3) << " "; // true
    cout << q.enQueue(4) << " "; // false
    cout << q.Rear() << " "; // 3
    cout << q.isFull() << " "; // true
    cout << q.deQueue() << " "; // true
    cout << q.enQueue(4) << " "; // true
    cout << q.Rear() << " "; // 4
    cout << endl;

    // Test LeetCode 346
    cout << "\nLeetCode 346: Moving Average\n";
    MovingAverage ma(3);
    vector<double> averages;
    for (int val : {1, 10, 3, 5}) {
        averages.push_back(ma.next(val));
    }
    cout << "Test 1: ";
    printVectorDouble(averages); // [1.00000,5.50000,4.66667,6.00000]

    // Test LeetCode 1679
    cout << "\nLeetCode 1679: Max Number of K-Sum Pairs\n";
    vector<int> nums1 = {1, 2, 3, 4};
    int k1 = 5;
    cout << "Test 1: " << maxOperations(nums1, k1) << endl; // 2
    vector<int> nums2 = {3, 3, 3, 3};
    int k2 = 6;
    cout << "Test 2: " << maxOperations(nums2, k2) << endl; // 2

    return 0;
}
```

**Output**:
```
LeetCode 933: Number of Recent Calls
Test 1: 1 2 3 3

LeetCode 622: Design Circular Queue
Test 1: 1 1 1 0 3 1 1 1 4

LeetCode 346: Moving Average
Test 1: [1.00000,5.50000,4.66667,6.00000]

LeetCode 1679: Max Number of K-Sum Pairs
Test 1: 2
Test 2: 2
```

## Key Takeaways
- **Deque for Queues**: Problems 933 and 346 use deques for sliding window queues, leveraging O(1) front/back operations.
- **Array for Fixed Buffers**: Problem 622 uses an STL `array` for a circular queue, exploiting fixed-size efficiency.
- **Two Pointers**: Problem 1679 uses Two Pointers with a sorted array, showing versatility beyond deques.
- **Edge Cases**: Always test empty inputs, single elements, and boundary conditions (e.g., full queue, large `t`).
- **Optimization**: Deque’s O(1) operations and array’s fixed-size efficiency are key for interview problems.

These solutions reinforce array and deque manipulation skills, preparing students for interview scenarios with queue-based and Two Pointers patterns.