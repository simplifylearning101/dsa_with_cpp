# Quiz: Two-Pointer Technique in Arrays (Mixed with Previous Learnings)

Below are 30 questions: 20 on the two-pointer technique (current topic), 5 on arrays (Week 2, Hour 1), and 5 on C++ fundamentals/STL (Weeks 0-1). Each question is designed to reinforce concepts critical for coding interviews.

1. What is the two-pointer technique?  
2. Name two types of two-pointer approaches.  
3. When is the opposite ends approach used?  
4. Write code to check if an array is a palindrome using two pointers.  
5. What is the time complexity of pair sum with two pointers in a sorted array?  
6. How does the same-direction two-pointer work for removing duplicates?  
7. True/False: The two-pointer technique always requires a sorted array.  
8. Write code to move zeros to the end of an array using two pointers.  
9. What is the space complexity of most two-pointer solutions?  
10. Explain how the two-pointer technique reduces time complexity.  
11. Write code to find a pair summing to a target in a sorted array.  
12. What happens when pointers cross in the opposite ends approach?  
13. True/False: The two-pointer technique can be used for partitioning arrays.  
14. Write code to merge two sorted arrays using two pointers.  
15. What is a common pitfall in two-pointer implementations?  
16. How do you handle unsorted arrays in pair sum problems?  
17. Write code to partition an array around a pivot value.  
18. Explain the sliding window approach with two pointers.  
19. True/False: The two-pointer technique is always O(n) time complexity.  
20. Give an example of a two-pointer problem commonly asked in interviews.  
21. (Arrays) How do you initialize an array with all zeros?  
22. (Arrays) What is meant by array decay in C++?  
23. (Arrays) What is the time complexity of accessing an array element?  
24. (Arrays) How do you find the size of a raw array in C++?  
25. (Arrays) What is a common error when working with array bounds?  
26. (C++ Fundamentals) What is the role of the `const` keyword in function parameters?  
27. (STL) How do you declare a vector in C++?  
28. (STL) What is the difference between a vector and an array?  
29. (STL) How do you use `std::sort` to sort a vector?  
30. (C++ Fundamentals) What is pointer arithmetic in C++?

## Solutions for the Quiz

1. The two-pointer technique uses two indices to traverse an array, often reducing time complexity from O(n²) to O(n) by avoiding nested loops.  
2. Opposite ends (converging pointers) and same direction (fast and slow pointers).  
3. Used for problems like pair sum in sorted arrays or checking palindromes, where pointers move toward each other.  
4. 
   ```cpp
   bool isPalindrome(int arr[], int n) {
       int left = 0, right = n - 1;
       while (left < right) {
           if (arr[left++] != arr[right--]) return false;
       }
       return true;
   }
   ```
5. O(n) after an O(n log n) sort, if sorting is required.  
6. Slow pointer tracks the position for the next unique element, fast pointer scans for new unique elements.  
7. False, some problems (e.g., move zeros) work with unsorted arrays.  
8. 
   ```cpp
   void moveZeroes(int arr[], int n) {
       int nonZeroPos = 0;
       for (int i = 0; i < n; i++) {
           if (arr[i] != 0) arr[nonZeroPos++] = arr[i];
       }
       while (nonZeroPos < n) arr[nonZeroPos++] = 0;
   }
   ```
9. Typically O(1) for in-place operations, excluding output or sorting space.  
10. Avoids nested loops by using two pointers to scan the array in a single pass, reducing O(n²) to O(n).  
11. 
   ```cpp
   bool findPairSum(int arr[], int n, int target) {
       std::sort(arr, arr + n);
       int left = 0, right = n - 1;
       while (left < right) {
           int sum = arr[left] + arr[right];
           if (sum == target) return true;
           else if (sum < target) left++;
           else right--;
       }
       return false;
   }
   ```
12. Indicates the search is complete, and no solution was found.  
13. True, e.g., partitioning around a pivot or moving zeros.  
14. 
   ```cpp
   std::vector<int> mergeSorted(int arr1[], int n1, int arr2[], int n2) {
       std::vector<int> res;
       int i = 0, j = 0;
       while (i < n1 && j < n2) {
           if (arr1[i] <= arr2[j]) res.push_back(arr1[i++]);
           else res.push_back(arr2[j++]);
       }
       while (i < n1) res.push_back(arr1[i++]);
       while (j < n2) res.push_back(arr2[j++]);
       return res;
   }
   ```
15. Incorrect pointer updates leading to out-of-bounds access or infinite loops.  
16. Sort the array first (O(n log n)) or use a hash table (O(n) time, O(n) space).  
17. 
   ```cpp
   int partition(int arr[], int n, int pivot) {
       int i = 0;
       for (int j = 0; j < n; j++) {
           if (arr[j] <= pivot) std::swap(arr[i++], arr[j]);
       }
       return i;
   }
   ```
18. Two pointers define a dynamic window, adjusting based on a condition (e.g., sum <= k), used for subarray problems.  
19. False, may involve O(n log n) if sorting is required.  
20. Two Sum, Remove Duplicates, or Container With Most Water.  
21. 
   ```cpp
   int arr[5] = {};
   ```
22. When an array is passed to a function, it decays to a pointer, losing size information.  
23. O(1).  
24. 
   ```cpp
   size_t size = sizeof(arr) / sizeof(arr[0]);
   ```
25. Out-of-bounds access, leading to undefined behavior.  
26. Prevents modification of the parameter, ensuring read-only access.  
27. 
   ```cpp
   #include <vector>
   std::vector<int> v;
   ```
28. Vector is dynamic and resizable; array is fixed-size.  
29. 
   ```cpp
   #include <algorithm>
   std::sort(v.begin(), v.end());
   ```
30. Operations like addition or subtraction on pointers to navigate memory (e.g., `arr + 1` points to next element).