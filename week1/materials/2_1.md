# Hour 2: Arrays and Deques in STL

**Agenda**: Introduce students to C++ STL arrays and deques, building on their understanding of vectors from Hour 1. Use real-world analogies and fully commented programs to simplify concepts. Emphasize practical usage and prepare students for coding interviews by focusing on operations and trade-offs.

**Outcome Expected**:  
By the end of this hour, students will:  
- Understand STL `array` as a fixed-size container and its advantages over C-style arrays.  
- Master `deque` (double-ended queue) operations for efficient front and back insertions/deletions.  
- Compare arrays, deques, and vectors to choose the right container for specific problems.  
- Be able to write C++ programs using arrays and deques with proper syntax and error handling.  
- Be ready to solve LeetCode problems involving sliding windows or queues using deques.

## Topics Covered
1. **STL Array: Fixed-Size Containers**  
   - Declaration, initialization, and operations.  
   - Advantages over C-style arrays (bounds checking, size awareness).  
   - Real-world analogy: Array as a fixed-size tray of cupcakes.  
2. **STL Deque: Double-Ended Queue**  
   - Declaration, initialization, and operations (push_front, push_back, pop_front, pop_back).  
   - Comparison with vectors (efficient front operations).  
   - Real-world analogy: Deque as a conveyor belt with access at both ends.  
3. **Iterators and Common Operations**  
   - Using iterators to traverse arrays and deques.  
   - Key operations and their time complexities.  

## Detailed Explanation of Topics Covered

### 1. STL Array: Fixed-Size Containers
The STL `array` is a fixed-size container that wraps C-style arrays with a safer, more modern interface. Unlike vectors, its size is set at compile-time and cannot change. Think of an `array` as a tray of cupcakes with a fixed number of slots—once the tray is made, you can’t add or remove slots, but you can change the cupcakes.

**Key Features**:  
- **Declaration**: `array<int, 5> arr;` (fixed size of 5 integers).  
- **Initialization**: `array<int, 5> arr = {1, 2, 3, 4, 5};`  
- **Operations**: `at(i)` (bounds-checked), `operator[i]`, `front()`, `back()`, `size()`.  
- **Advantages**: Bounds checking with `at()`, fixed memory (no reallocation), stack allocation (faster than vector’s heap).  
- **Limitations**: Cannot resize, fixed at compile-time.

**Example Program**: Basic array operations.

```cpp
#include <iostream>
#include <array> // Include array library
using namespace std;

int main() {
    // Declare and initialize a fixed-size array of 5 integers
    array<int, 5> tray = {1, 2, 3, 4, 5};

    // Print size (fixed at 5)
    cout << "Size of array: " << tray.size() << endl; // Output: 5

    // Access elements safely with at()
    try {
        cout << "Element at index 2: " << tray.at(2) << endl; // Output: 3
        // tray.at(10); // Would throw out_of_range exception
    } catch (const out_of_range& e) {
        cout << "Error: " << e.what() << endl;
    }

    // Modify elements using operator[]
    tray[1] = 20; // Change second element
    cout << "Modified tray: ";
    for (int num : tray) { // Range-based for loop
        cout << num << " ";
    }
    cout << endl; // Output: 1 20 3 4 5

    // Access first and last elements
    cout << "First: " << tray.front() << ", Last: " << tray.back() << endl; // Output: First: 1, Last: 5

    return 0;
}
```

**Explanation**:  
- `#include <array>`: Imports the array library.  
- `array<int, 5>`: Fixed-size array of 5 integers.  
- `at(i)`: Safe access with bounds checking.  
- `front()` and `back()`: Access first/last elements.  
- Fixed size ensures no reallocation, making it efficient for known sizes.

### 2. STL Deque: Double-Ended Queue
The STL `deque` (double-ended queue) allows efficient insertions and deletions at both ends, unlike vectors, which are optimized for back operations. Imagine a deque as a conveyor belt where you can add or remove items from either end quickly.

**Key Features**:  
- **Declaration**: `deque<int> dq;` (empty deque).  
- **Operations**: `push_front`, `push_back`, `pop_front`, `pop_back`, `at(i)`, `operator[i]`.  
- **Advantages**: O(1) for front/back operations, dynamic size like vectors.  
- **Limitations**: Non-contiguous memory (less cache-friendly than vectors), slower random access.  
- **Use Cases**: Queues, stacks, or sliding window problems requiring front/back access.

**Example Program**: Deque operations.

```cpp
#include <iostream>
#include <deque> // Include deque library
using namespace std;

int main() {
    // Declare an empty deque
    deque<string> conveyor;

    // Add elements to front and back
    conveyor.push_back("Apple"); // Add to end
    conveyor.push_front("Banana"); // Add to front
    conveyor.push_back("Cherry"); // Add to end

    // Print size and elements
    cout << "Size of deque: " << conveyor.size() << endl; // Output: 3
    cout << "Elements: ";
    for (const auto& item : conveyor) {
        cout << item << " ";
    }
    cout << endl; // Output: Banana Apple Cherry

    // Remove elements
    conveyor.pop_front(); // Remove Banana
    conveyor.pop_back(); // Remove Cherry
    cout << "After pop: ";
    for (const auto& item : conveyor) {
        cout << item << " ";
    }
    cout << endl; // Output: Apple

    // Access with bounds checking
    cout << "First element: " << conveyor.at(0) << endl; // Output: Apple

    return 0;
}
```

**Explanation**:  
- `push_front` and `push_back`: Add elements to front/back in O(1).  
- `pop_front` and `pop_back`: Remove elements from front/back in O(1).  
- `at(0)`: Safe access with bounds checking.  
- Deque’s flexibility makes it ideal for queue-like structures.

### 3. Iterators and Common Operations
Both `array` and `deque` support iterators for traversal, similar to vectors. Iterators allow generic processing with STL algorithms (covered later).

**Key Iterator Types**:  
- `begin()`, `end()`: Forward traversal.  
- `rbegin()`, `rend()`: Reverse traversal.  
- Deques support random-access iterators; arrays do too, but their fixed size limits flexibility.

**Example Program**: Using iterators with array and deque.

```cpp
#include <iostream>
#include <array>
#include <deque>
using namespace std;

int main() {
    // Initialize array and deque
    array<int, 4> arr = {10, 20, 30, 40};
    deque<int> dq = {1, 2, 3};

    // Traverse array with iterators
    cout << "Array elements: ";
    for (auto it = arr.begin(); it != arr.end(); ++it) {
        cout << *it << " "; // Dereference iterator
    }
    cout << endl; // Output: 10 20 30 40

    // Traverse deque in reverse
    cout << "Deque reverse: ";
    for (auto rit = dq.rbegin(); rit != dq.rend(); ++rit) {
        cout << *rit << " "; // Dereference reverse iterator
    }
    cout << endl; // Output: 3 2 1

    // Modify deque using iterator
    for (auto it = dq.begin(); it != dq.end(); ++it) {
        *it *= 2; // Double each element
    }
    cout << "Modified deque: ";
    for (int num : dq) {
        cout << num << " ";
    }
    cout << endl; // Output: 2 4 6

    return 0;
}
```

**Explanation**:  
- `arr.begin()` and `dq.begin()`: Start of containers.  
- `dq.rbegin()`: Reverse iterator for deque.  
- Iterators allow modification and work with STL algorithms.

## Points to Remember (Interview Preparation)
1. **Array vs. C-Style Array**: STL `array` provides bounds checking (`at()`), `size()`, and iterator support, unlike raw arrays.  
2. **Deque vs. Vector**: Use deques for frequent front/back operations (O(1)); vectors are better for random access and back-only operations.  
3. **Time Complexities**:  
   - Array: `at()`, `[]`, `front()`, `back()` are O(1).  
   - Deque: `push_front`, `push_back`, `pop_front`, `pop_back` are O(1); random access is O(1) but slower due to non-contiguous memory.  
4. **Use Cases**: Arrays for fixed-size data; deques for queues, stacks, or sliding windows.  
5. **Safety**: Use `at()` for bounds checking in production; `[]` for performance in interviews (if bounds are guaranteed).  
6. **Iterator Invalidation**: Deque iterators may be invalidated by `push_front`/`push_back` due to internal block reallocation.  
7. **Interview Questions**: Be ready to explain trade-offs (e.g., deque vs. vector) and implement queue/stack using deque.  
8. **Common Errors**: Avoid out-of-bounds access in arrays (fixed size) and ensure deque operations are used appropriately.