# Project Quiz: Inventory Management System

20 questions to test understanding of the project.

1. What is the purpose of KMP in inventory search?  
2. Write KMP LPS computation.  
3. How to handle duplicate items in addition?  
4. Write code for item addition.  
5. What is grouping by category?  
6. Write code for group by category.  
7. How does compression work in inventory?  
8. Write code for compression.  
9. True/False: KMP is O(n+m).  
10. What is file I/O role?  
11. Write code to read inventory from file.  
12. How to handle empty inventory?  
13. What is time complexity of grouping?  
14. Write code for Rabin-Karp alternative.  
15. True/False: Compression is O(n).  
16. How to optimize space in compression?  
17. What are common edge cases?  
18. Write code for KMP search.  
19. How does project use arrays and strings?  
20. What is the output format?  

## Solutions for the Quiz

1. Efficiently search item names in concatenated inventory.  
2. 
   ```cpp
   std::vector<int> computeLPS(std::string pattern) {
       int m = pattern.length();
       std::vector<int> lps(m, 0);
       int len = 0, i = 1;
       while (i < m) {
           if (pattern[i] == pattern[len]) lps[i++] = ++len;
           else if (len != 0) len = lps[len - 1];
           else lps[i++] = 0;
       }
       return lps;
   }
   ```
3. Update quantity if name exists.  
4. 
   ```cpp
   void addItem(std::vector<std::pair<std::string, int>>& inventory, std::string name, int qty) {
       for (auto& item : inventory) {
           if (item.first == name) {
               item.second += qty;
               return;
           }
       }
       inventory.push_back({name, qty});
   }
   ```
5. Group items based on first letter or category string.  
6. 
   ```cpp
   std::unordered_map<char, std::vector<std::string>> groupByCategory(const std::vector<std::pair<std::string, int>>& inventory) {
       std::unordered_map<char, std::vector<std::string>> groups;
       for (const auto& item : inventory) {
           if (!item.first.empty()) groups[item.first[0]].push_back(item.first);
       }
       return groups;
   }
   ```
7. Compress concatenated inventory string.  
8. 
   ```cpp
   std::string compressInventory(const std::vector<std::pair<std::string, int>>& inventory) {
       std::string result;
       for (const auto& item : inventory) {
           result += item.first + std::to_string(item.second);
       }
       int n = result.length(), write = 0, count = 1, start = 0;
       std::string compressed = result;
       for (int i = 1; i <= n; i++) {
           if (i < n && result[i] == result[i - 1]) {
               count++;
           } else {
               compressed[write++] = result[start];
               if (count > 1) {
                   std::string num = std::to_string(count);
                   for (char c : num) compressed[write++] = c;
               }
               start = i;
               count = 1;
           }
       }
       return compressed.substr(0, write);
   }
   ```
9. True.  
10. Read/write inventory data.  
11. 
   ```cpp
   std::vector<std::pair<std::string, int>> readInventory(std::ifstream& inFile) {
       std::vector<std::pair<std::string, int>> inventory;
       std::string line;
       while (std::getline(inFile, line)) {
           size_t comma = line.find(',');
           if (comma != std::string::npos) {
               std::string name = line.substr(0, comma);
               int qty = std::stoi(line.substr(comma + 1));
               inventory.push_back({name, qty});
           }
       }
       return inventory;
   }
   ```
12. Return empty vector or handle gracefully.  
13. O(n*k) for n items, k max name length.  
14. 
   ```cpp
   int RabinKarp(std::string text, std::string pattern, int q) {
       int n = text.length(), m = pattern.length(), p = 0, t = 0, h = 1, d = 256;
       for (int i = 0; i < m - 1; i++) h = (h * d) % q;
       for (int i = 0; i < m; i++) {
           p = (d * p + pattern[i]) % q;
           t = (d * t + text[i]) % q;
       }
       for (int i = 0; i <= n - m; i++) {
           if (p == t) {
               bool match = true;
               for (int j = 0; j < m; j++) {
                   if (text[i + j] != pattern[j]) { match = false; break; }
               }
               if (match) return i;
           }
           if (i < n - m) {
               t = (d * (t - text[i] * h) + text[i + m]) % q;
               if (t < 0) t += q;
           }
       }
       return -1;
   }
   ```
15. True.  
16. Use in-place modification.  
17. Empty file, no items, invalid quantities.  
18. 
   ```cpp
   int KMPSearch(std::string text, std::string pattern) {
       int n = text.length(), m = pattern.length();
       std::vector<int> lps = computeLPS(pattern);
       int i = 0, j = 0;
       while (i < n) {
           if (text[i] == pattern[j]) { i++; j++; }
           if (j == m) return i - j;
           if (i < n && text[i] != pattern[j]) {
               if (j != 0) j = lps[j - 1];
               else i++;
           }
       }
       return -1;
   }
   ```
19. Arrays for inventory, strings for names.  
20. Pattern matches, groups, palindrome, compressed string.