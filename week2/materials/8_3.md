# Solutions to Homework Problems

1. **String Compression**
```cpp
#include <iostream>
#include <string>
int compress(std::string& chars) {
    int n = chars.length(), write = 0, count = 1, start = 0;
    for (int i = 1; i <= n; i++) {
        if (i < n && chars[i] == chars[i - 1]) {
            count++;
        } else {
            chars[write++] = chars[start];
            if (count > 1) {
                std::string num = std::to_string(count);
                for (char c : num) chars[write++] = c;
            }
            start = i;
            count = 1;
        }
    }
    return write;
}
int main() {
    std::string s = "aabbccc";
    int len = compress(s);
    for (int i = 0; i < len; i++) std::cout << s[i]; // Output: a2b2c3
    std::cout << std::endl;
    return 0;
}
```

2. **Edit Distance**
```cpp
#include <iostream>
#include <string>
#include <vector>
int minDistance(std::string word1, std::string word2) {
    int m = word1.length(), n = word2.length();
    std::vector<std::vector<int>> dp(m + 1, std::vector<int>(n + 1, 0));
    for (int i = 0; i <= m; i++) dp[i][0] = i;
    for (int j = 0; j <= n; j++) dp[0][j] = j;
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (word1[i - 1] == word2[j - 1]) dp[i][j] = dp[i - 1][j - 1];
            else dp[i][j] = std::min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;
        }
    }
    return dp[m][n];
}
int main() {
    std::string word1 = "horse", word2 = "ros";
    std::cout << minDistance(word1, word2) << std::endl; // Output: 3
    return 0;
}
```

3. **Regular Expression Matching**
```cpp
#include <iostream>
#include <string>
#include <vector>
bool isMatch(std::string s, std::string p) {
    int m = s.length(), n = p.length();
    std::vector<std::vector<bool>> dp(m + 1, std::vector<bool>(n + 1, false));
    dp[0][0] = true;
    for (int j = 1; j <= n; j++) {
        if (p[j - 1] == '*') dp[0][j] = dp[0][j - 2];
    }
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (p[j - 1] == '*') {
                dp[i][j] = dp[i][j - 2] || (dp[i - 1][j] && (s[i - 1] == p[j - 2] || p[j - 2] == '.'));
            } else if (p[j - 1] == '.' || s[i - 1] == p[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1];
            }
        }
    }
    return dp[m][n];
}
int main() {
    std::string s = "aab", p = "c*a*b";
    std::cout << (isMatch(s, p) ? "true" : "false") << std::endl; // Output: true
    return 0;
}
```

4. **Longest Valid Parentheses**
```cpp
#include <iostream>
#include <string>
#include <stack>
int longestValidParentheses(std::string s) {
    std::stack<int> stack;
    stack.push(-1);
    int maxLen = 0;
    for (int i = 0; i < s.length(); i++) {
        if (s[i] == '(') {
            stack.push(i);
        } else {
            stack.pop();
            if (stack.empty()) {
                stack.push(i);
            } else {
                maxLen = std::max(maxLen, i - stack.top());
            }
        }
    }
    return maxLen;
}
int main() {
    std::string s = "(()";
    std::cout << longestValidParentheses(s) << std::endl; // Output: 2
    return 0;
}
```

5. **Group Anagrams**
```cpp
#include <iostream>
#include <vector>
#include <string>
#include <unordered_map>
std::vector<std::vector<std::string>> groupAnagrams(std::vector<std::string>& strs) {
    std::unordered_map<std::string, std::vector<std::string>> map;
    for (std::string s : strs) {
        std::vector<int> count(26, 0);
        for (char c : s) count[c - 'a']++;
        std::string key;
        for (int x : count) key += std::to_string(x) + "#";
        map[key].push_back(s);
    }
    std::vector<std::vector<std::string>> result;
    for (auto& pair : map) result.push_back(pair.second);
    return result;
}
int main() {
    std::vector<std::string> strs = {"eat", "tea", "tan", "ate", "nat", "bat"};
    auto res = groupAnagrams(strs);
    for (auto& group : res) {
        for (std::string s : group) std::cout << s << " ";
        std::cout << std::endl;
    }
    return 0;
}
```

6. **KMP Pattern Search**
```cpp
#include <iostream>
#include <vector>
#include <string>
std::vector<int> computeLPS(std::string pattern) {
    int m = pattern.length();
    std::vector<int> lps(m, 0);
    int len = 0, i = 1;
    while (i < m) {
        if (pattern[i] == pattern[len]) lps[i++] = ++len;
        else if (len != 0) len = lps[len - 1];
        else lps[i++] = 0;
    }
    return lps;
}
int KMPSearch(std::string text, std::string pattern) {
    int n = text.length(), m = pattern.length();
    std::vector<int> lps = computeLPS(pattern);
    int i = 0, j = 0;
    while (i < n) {
        if (text[i] == pattern[j]) { i++; j++; }
        if (j == m) return i - j;
        if (i < n && text[i] != pattern[j]) {
            if (j != 0) j = lps[j - 1];
            else i++;
        }
    }
    return -1;
}
int main() {
    std::string text = "ABABDABACDABABCABAB", pattern = "ABABCABAB";
    std::cout << KMPSearch(text, pattern) << std::endl; // Output: 10
    return 0;
}
```

7. **First Unique Character**
```cpp
#include <iostream>
#include <string>
int firstUniqChar(std::string s) {
    int count[26] = {0};
    for (char c : s) count[c - 'a']++;
    for (int i = 0; i < s.length(); i++) {
        if (count[s[i] - 'a'] == 1) return i;
    }
    return -1;
}
int main() {
    std::string s = "leetcode";
    std::cout << firstUniqChar(s) << std::endl; // Output: 0
    return 0;
}
```

8. **Wildcard Pattern Matching**
```cpp
#include <iostream>
#include <string>
#include <vector>
bool isMatch(std::string s, std::string p) {
    int m = s.length(), n = p.length();
    std::vector<std::vector<bool>> dp(m + 1, std::vector<bool>(n + 1, false));
    dp[0][0] = true;
    for (int j = 1; j <= n; j++) {
        if (p[j - 1] == '*') dp[0][j] = dp[0][j - 1];
    }
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (p[j - 1] == '*') {
                dp[i][j] = dp[i][j - 1] || dp[i - 1][j];
            } else if (p[j - 1] == '?' || s[i - 1] == p[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1];
            }
        }
    }
    return dp[m][n];
}
int main() {
    std::string s = "adceb", p = "*a*b";
    std::cout << (isMatch(s, p) ? "true" : "false") << std::endl; // Output: true
    return 0;
}
```

9. **Reverse Words in a String**
```cpp
#include <iostream>
#include <string>
std::string reverseWords(std::string s) {
    int n = s.length(), start = 0, write = 0;
    std::string result;
    for (int i = 0; i <= n; i++) {
        if (i == n || s[i] == ' ') {
            if (start < i) {
                if (!result.empty()) result = s.substr(start, i - start) + " " + result;
                else result = s.substr(start, i - start);
            }
            start = i + 1;
        }
    }
    return result;
}
int main() {
    std::string s = "  hello world  ";
    std::cout << reverseWords(s) << std::endl; // Output: world hello
    return 0;
}
```

10. **Longest Substring with K Distinct Characters**
```cpp
#include <iostream>
#include <string>
#include <unordered_map>
int lengthOfLongestSubstringKDistinct(std::string s, int k) {
    std::unordered_map<char, int> map;
    int left = 0, maxLen = 0;
    for (int right = 0; right < s.size(); right++) {
        map[s[right]]++;
        while (map.size() > k) {
            map[s[left]]--;
            if (map[s[left]] == 0) map.erase(s[left]);
            left++;
        }
        maxLen = std::max(maxLen, right - left + 1);
    }
    return maxLen;
}
int main() {
    std::string s = "eceba";
    std::cout << lengthOfLongestSubstringKDistinct(s, 2) << std::endl; // Output: 3
    return 0;
}
```