# Hour 11 LeetCode Problem: Two Sum

This document illustrates **LeetCode 1: Two Sum**, an easy problem that leverages STL `unordered_map` for efficient key-value lookups. It includes the problem description, coding pattern, solution, complexity analysis, and test cases.

## Problem Statement: LeetCode 1 - Two Sum
**Link**: [LeetCode 1](https://leetcode.com/problems/two-sum/)

**Description**:  
Given an array of integers `nums` and an integer `target`, return indices of the two numbers such that they add up to `target`. You may assume that each input has exactly one solution, and you may not use the same element twice.

**Constraints**:
- `2 <= nums.length <= 10^4`
- `-10^9 <= nums[i] <= 10^9`
- `-10^9 <= target <= 10^9`

**Example**:
- Input: `nums = [2,7,11,15], target = 9`  
  Output: `[0,1]`  
  Explanation: `nums[0] + nums[1] = 2 + 7 = 9`.

**Real-World Analogy**: Finding two items in a catalog whose prices sum to a budget.

## Coding Pattern: Unordered Map for Two Sum
- Use `unordered_map` to store number-index pairs.  
- For each number, check if `target - number` exists in the map.  
- If found, return current index and stored index.

## Solution
**Algorithm**:
1. Initialize an `unordered_map` to store number-index pairs.  
2. Iterate through `nums`.  
3. For each `nums[i]`, check if `target - nums[i]` is in the map.  
4. If found, return `[map[target - nums[i]], i]`.  
5. Insert `nums[i]` and index `i` into the map.

**Code**:
```cpp
#include <unordered_map>
#include <vector>
using namespace std;

class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> num_map;  // number -> index
        for (int i = 0; i < nums.size(); ++i) {
            int complement = target - nums[i];
            if (num_map.find(complement) != num_map.end()) {
                return {num_map[complement], i};
            }
            num_map[nums[i]] = i;
        }
        return {};  // No solution (not expected per constraints)
    }
};
```

**Time Complexity**: O(n)  
- Each `find` and `insert` is O(1) average, for n elements.

**Space Complexity**: O(n)  
- Stores up to n number-index pairs.

**Explanation**:  
- `unordered_map` provides O(1) average lookups.  
- Single pass ensures efficiency.

## Test Cases
1. **Typical Case**: `nums = [2,7,11,15], target = 9` → Output: `[0,1]`  
2. **Negative Numbers**: `nums = [-3,4,3,90], target = 0` → Output: `[0,2]`  
3. **Same Number**: `nums = [3,2,4], target = 6` → Output: `[1,2]`  
4. **Large Numbers**: `nums = [1000000,2000000], target = 3000000` → Output: `[0,1]`  
5. **Minimum Size**: `nums = [1,2], target = 3` → Output: `[0,1]`  

**Test Case Implementation**:
```cpp
#include <iostream>
#include <unordered_map>
#include <vector>
using namespace std;

vector<int> twoSum(vector<int>& nums, int target) {
    unordered_map<int, int> num_map;
    for (int i = 0; i < nums.size(); ++i) {
        int complement = target - nums[i];
        if (num_map.find(complement) != num_map.end()) {
            return {num_map[complement], i};
        }
        num_map[nums[i]] = i;
    }
    return {};
}

void printVector(const vector<int>& v) {
    cout << "[" << v[0] << "," << v[1] << "]" << endl;
}

int main() {
    // Test cases
    vector<int> nums1 = {2, 7, 11, 15};
    cout << "Test 1: "; printVector(twoSum(nums1, 9));  // [0,1]
    
    vector<int> nums2 = {-3, 4, 3, 90};
    cout << "Test 2: "; printVector(twoSum(nums2, 0));  // [0,2]
    
    vector<int> nums3 = {3, 2, 4};
    cout << "Test 3: "; printVector(twoSum(nums3, 6));  // [1,2]
    
    vector<int> nums4 = {1000000, 2000000};
    cout << "Test 4: "; printVector(twoSum(nums4, 3000000));  // [0,1]
    
    vector<int> nums5 = {1, 2};
    cout << "Test 5: "; printVector(twoSum(nums5, 3));  // [0,1]
    
    return 0;
}
```

**Output**:
```
Test 1: [0,1]
Test 2: [0,2]
Test 3: [1,2]
Test 4: [0,1]
Test 5: [0,1]
```

## Optimization Mindset
- **Efficiency**: `unordered_map` ensures O(n) average time.  
- **Key Insight**: Store indices while scanning to avoid double pass.  
- **Edge Cases**: Handle negative numbers and large inputs.