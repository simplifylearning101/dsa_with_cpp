# Solutions for Leetcode Problems

1. **Two-Sum**  
   **Explanation:** Find indices summing to target.  
   **Brute-Force:** Nested loops.  
   ```cpp
   std::vector<int> twoSum(std::vector<int>& nums, int target) {
       for (int i = 0; i < nums.size(); i++) {
           for (int j = i + 1; j < nums.size(); j++) {
               if (nums[i] + nums[j] == target) return {i, j};
           }
       }
       return {};
   }
   ```
   Pros: Simple. Cons: O(n^2) time.  
   **Optimized:** Hash map.  
   ```cpp
   std::vector<int> twoSum(std::vector<int>& nums, int target) {
       std::unordered_map<int, int> map;
       for (int i = 0; i < nums.size(); i++) {
           int complement = target - nums[i];
           if (map.count(complement)) return {map[complement], i};
           map[nums[i]] = i;
       }
       return {};
   }
   ```
   Pros: O(n) time, O(n) space. Cons: Extra space.

2. **Maximum Subarray**  
   **Explanation:** Find subarray with maximum sum.  
   **Brute-Force:** Check all subarrays.  
   ```cpp
   int maxSubArray(std::vector<int>& nums) {
       int maxSum = nums[0];
       for (int i = 0; i < nums.size(); i++) {
           int currSum = 0;
           for (int j = i; j < nums.size(); j++) {
               currSum += nums[j];
               maxSum = std::max(maxSum, currSum);
           }
       }
       return maxSum;
   }
   ```
   Pros: Correct. Cons: O(n^2) time.  
   **Optimized:** Kadaneâ€™s algorithm.  
   ```cpp
   int maxSubArray(std::vector<int>& nums) {
       int maxSum = nums[0], currSum = nums[0];
       for (int i = 1; i < nums.size(); i++) {
           currSum = std::max(nums[i], currSum + nums[i]);
           maxSum = std::max(maxSum, currSum);
       }
       return maxSum;
   }
   ```
   Pros: O(n) time, O(1) space. Cons: None.

3. **Group Anagrams**  
   **Explanation:** Group strings that are anagrams.  
   **Brute-Force:** Sort each string.  
   ```cpp
   std::vector<std::vector<std::string>> groupAnagrams(std::vector<std::string>& strs) {
       std::unordered_map<std::string, std::vector<std::string>> map;
       for (std::string s : strs) {
           std::string sorted = s;
           std::sort(sorted.begin(), sorted.end());
           map[sorted].push_back(s);
       }
       std::vector<std::vector<std::string>> result;
       for (auto& pair : map) result.push_back(pair.second);
       return result;
   }
   ```
   Pros: Simple. Cons: O(n*k*log k) time.  
   **Optimized:** Frequency array.  
   ```cpp
   std::vector<std::vector<std::string>> groupAnagrams(std::vector<std::string>& strs) {
       std::unordered_map<std::string, std::vector<std::string>> map;
       for (std::string s : strs) {
           std::vector<int> count(26, 0);
           for (char c : s) count[c - 'a']++;
           std::string key;
           for (int x : count) key += std::to_string(x) + "#";
           map[key].push_back(s);
       }
       std::vector<std::vector<std::string>> result;
       for (auto& pair : map) result.push_back(pair.second);
       return result;
   }
   ```
   Pros: O(n*k) time, O(n) space. Cons: Extra space.

4. **Longest Palindromic Substring**  
   **Explanation:** Find longest palindrome.  
   **Brute-Force:** Check all substrings.  
   ```cpp
   std::string longestPalindrome(std::string s) {
       int n = s.length(), maxLen = 1, start = 0;
       for (int i = 0; i < n; i++) {
           for (int j = i; j < n; j++) {
               bool isPal = true;
               for (int k = i; k <= j; k++) {
                   if (s[k] != s[j - (k - i)]) { isPal = false; break; }
               }
               if (isPal && j - i + 1 > maxLen) {
                   maxLen = j - i + 1;
                   start = i;
               }
           }
       }
       return s.substr(start, maxLen);
   }
   ```
   Pros: Correct. Cons: O(n^3) time.  
   **Optimized:** Expand-around-center.  
   ```cpp
   std::string longestPalindrome(std::string s) {
       int n = s.length(), start = 0, maxLen = 1;
       for (int i = 0; i < n; i++) {
           int left = i, right = i;
           while (left >= 0 && right < n && s[left] == s[right]) {
               if (right - left + 1 > maxLen) {
                   start = left;
                   maxLen = right - left + 1;
               }
               left--; right++;
           }
           left = i; right = i + 1;
           while (left >= 0 && right < n && s[left] == s[right]) {
               if (right - left + 1 > maxLen) {
                   start = left;
                   maxLen = right - left + 1;
               }
               left--; right++;
           }
       }
       return s.substr(start, maxLen);
   }
   ```
   Pros: O(n^2) time, O(1) space. Cons: Quadratic time.

5. **Minimum Window Substring**  
   **Explanation:** Smallest substring with all characters.  
   **Brute-Force:** Check all substrings.  
   ```cpp
   std::string minWindow(std::string s, std::string t) {
       std::string result = s + " ";
       for (int i = 0; i < s.size(); i++) {
           std::unordered_map<char, int> tMap;
           for (char c : t) tMap[c]++;
           std::unordered_map<char, int> sMap;
           for (int j = i; j < s.size(); j++) {
               sMap[s[j]]++;
               bool valid = true;
               for (auto& p : tMap) {
                   if (sMap[p.first] < p.second) { valid = false; break; }
               }
               if (valid && j - i + 1 < result.size()) result = s.substr(i, j - i + 1);
           }
       }
       return result.size() > s.size() ? "" : result;
   }
   ```
   Pros: Correct. Cons: O(n^3) time.  
   **Optimized:** Sliding window.  
   ```cpp
   std::string minWindow(std::string s, std::string t) {
       std::unordered_map<char, int> tMap, sMap;
       for (char c : t) tMap[c]++;
       int required = tMap.size(), formed = 0, left = 0, minLen = s.size() + 1, minLeft = 0;
       for (int right = 0; right < s.size(); right++) {
           sMap[s[right]]++;
           if (tMap.count(s[right]) && sMap[s[right]] == tMap[s[right]]) formed++;
           while (formed == required && left <= right) {
               if (right - left + 1 < minLen) {
                   minLen = right - left + 1;
                   minLeft = left;
               }
               sMap[s[left]]--;
               if (tMap.count(s[left]) && sMap[s[left]] < tMap[s[left]]) formed--;
               left++;
           }
       }
       return minLen > s.size() ? "" : s.substr(minLeft, minLen);
   }
   ```
   Pros: O(n) time, O(k) space. Cons: Complex logic.