# Solutions for Leetcode Problems

1. **Trapping Rain Water**  
   **Explanation:** Compute trapped water. Example: [0,1,0,2,1,0,1,3,2,1,2,1] -> 6.  
   **Brute-Force:** Check each bar’s min(maxLeft, maxRight).  
   ```cpp
   int trap(vector<int>& height) {
       int water = 0;
       for (int i = 1; i < height.size() - 1; i++) {
           int leftMax = 0, rightMax = 0;
           for (int j = 0; j < i; j++) leftMax = max(leftMax, height[j]);
           for (int j = i + 1; j < height.size(); j++) rightMax = max(rightMax, height[j]);
           water += min(leftMax, rightMax) - height[i];
       }
       return water;
   }
   ```
   Pros: Correct. Cons: O(n²) time.  
   **Optimized:** Two-pointer.  
   ```cpp
   int trap(vector<int>& height) {
       if (height.size() <= 2) return 0;
       int left = 0, right = height.size() - 1, leftMax = 0, rightMax = 0, water = 0;
       while (left < right) {
           if (height[left] < height[right]) {
               if (height[left] >= leftMax) leftMax = height[left];
               else water += leftMax - height[left];
               left++;
           } else {
               if (height[right] >= rightMax) rightMax = height[right];
               else water += rightMax - height[right];
               right--;
           }
       }
       return water;
   }
   ```
   Pros: O(n) time, O(1) space. Cons: None.

2. **Longest Valid Parentheses**  
   **Explanation:** Find longest valid substring.  
   **Brute-Force:** Check all substrings.  
   ```cpp
   int longestValidParentheses(string s) {
       int maxLen = 0;
       for (int i = 0; i < s.size(); i++) {
           for (int j = i + 1; j < s.size(); j += 2) {
               string sub = s.substr(i, j - i + 1);
               stack<char> st;
               bool valid = true;
               for (char c : sub) {
                   if (c == '(') st.push(c);
                   else if (!st.empty()) st.pop();
                   else valid = false;
               }
               if (valid && st.empty()) maxLen = max(maxLen, j - i + 1);
           }
       }
       return maxLen;
   }
   ```
   Pros: Works. Cons: O(n³) time.  
   **Optimized:** Stack-based.  
   ```cpp
   int longestValidParentheses(string s) {
       stack<int> stack;
       stack.push(-1);
       int maxLen = 0;
       for (int i = 0; i < s.size(); i++) {
           if (s[i] == '(') stack.push(i);
           else {
               stack.pop();
               if (stack.empty()) stack.push(i);
               else maxLen = max(maxLen, i - stack.top());
           }
       }
       return maxLen;
   }
   ```
   Pros: O(n) time, O(n) space. Cons: Extra space.

3. **Container With Most Water**  
   **Explanation:** Maximize area between lines.  
   **Brute-Force:** Check all pairs.  
   ```cpp
   int maxArea(vector<int>& height) {
       int maxWater = 0;
       for (int i = 0; i < height.size(); i++) {
           for (int j = i + 1; j < height.size(); j++) {
               int water = min(height[i], height[j]) * (j - i);
               maxWater = max(maxWater, water);
           }
       }
       return maxWater;
   }
   ```
   Pros: Simple. Cons: O(n²) time.  
   **Optimized:** Two-pointer.  
   ```cpp
   int maxArea(vector<int>& height) {
       int maxWater = 0, left = 0, right = height.size() - 1;
       while (left < right) {
           int water = min(height[left], height[right]) * (right - left);
           maxWater = max(maxWater, water);
           if (height[left] < height[right]) left++;
           else right--;
       }
       return maxWater;
   }
   ```
   Pros: O(n) time, O(1) space. Cons: None.

4. **Maximum Sum Circular Subarray**  
   **Explanation:** Max sum in circular or straight subarray.  
   **Brute-Force:** Check all subarrays with wraparound.  
   ```cpp
   int maxSubarraySumCircular(vector<int>& nums) {
       int maxSum = nums[0];
       for (int i = 0; i < nums.size(); i++) {
           int sum = 0;
           for (int j = 0; j < nums.size(); j++) {
               int idx = (i + j) % nums.size();
               sum += nums[idx];
               maxSum = max(maxSum, sum);
           }
       }
       return maxSum;
   }
   ```
   Pros: Correct. Cons: O(n²) time.  
   **Optimized:** Kadane’s with circular adjustment.  
   ```cpp
   int maxSubarraySumCircular(vector<int>& nums) {
       int maxStraight = nums[0], currMax = nums[0];
       int minStraight = nums[0], currMin = nums[0], total = nums[0];
       for (int i = 1; i < nums.size(); i++) {
           currMax = max(nums[i], currMax + nums[i]);
           maxStraight = max(maxStraight, currMax);
           currMin = min(nums[i], currMin + nums[i]);
           minStraight = min(minStraight, currMin);
           total += nums[i];
       }
       if (maxStraight < 0) return maxStraight;
       return max(maxStraight, total - minStraight);
   }
   ```
   Pros: O(n) time, O(1) space. Cons: Complex logic.

5. **Subarray Sum Equals K**  
   **Explanation:** Count subarrays with sum k.  
   **Brute-Force:** Check all subarrays.  
   ```cpp
   int subarraySum(vector<int>& nums, int k) {
       int count = 0;
       for (int i = 0; i < nums.size(); i++) {
           int sum = 0;
           for (int j = i; j < nums.size(); j++) {
               sum += nums[j];
               if (sum == k) count++;
           }
       }
       return count;
   }
   ```
   Pros: Simple. Cons: O(n²) time.  
   **Optimized:** Prefix sum with hash map.  
   ```cpp
   int subarraySum(vector<int>& nums, int k) {
       unordered_map<int, int> map;
       map[0] = 1;
       int sum = 0, count = 0;
       for (int num : nums) {
           sum += num;
           if (map.find(sum - k) != map.end()) count += map[sum - k];
           map[sum]++;
       }
       return count;
   }
   ```
   Pros: O(n) time, O(n) space. Cons: Extra space.