# Hour 4: Stacks in STL

**Agenda**: Introduce students to C++ STL `stack`, building on their understanding of vectors (Hour 1), arrays/deques (Hour 2), and strings (Hour 3). Use real-world analogies and fully commented programs to simplify concepts. Emphasize practical usage, stack operations, and preparation for coding interviews.

**Outcome Expected**:  
By the end of this hour, students will:  
- Understand STL `stack` as a Last-In-First-Out (LIFO) container.  
- Master stack operations (e.g., push, pop, top).  
- Compare stacks with vectors and deques for specific use cases.  
- Write C++ programs using stacks with proper syntax and error handling.  
- Be ready to solve LeetCode problems involving stack-based algorithms.

## Topics Covered
1. **STL Stack: LIFO Container**  
   - Declaration, initialization, and basic operations.  
   - Underlying container (default: deque).  
   - Real-world analogy: Stack as a pile of plates.  
2. **Stack Operations**  
   - `push`, `pop`, `top`, `empty`, `size`.  
   - Handling empty stack scenarios.  
   - Real-world analogy: Adding/removing plates from a pile.  
3. **Comparison with Other Containers**  
   - Stacks vs. vectors (dynamic arrays).  
   - Stacks vs. deques (double-ended queues).  

## Detailed Explanation of Topics Covered

### 1. STL Stack: LIFO Container
The STL `stack` is a container adapter that follows the Last-In-First-Out (LIFO) principle, where the last element added is the first to be removed. It’s built on top of an underlying container (default: `deque`, but can be `vector` or `list`). Think of a stack as a pile of plates: you can only add or remove the top plate.

**Key Features**:  
- **Declaration**: `stack<T> s;` (e.g., `stack<int>`).  
- **Initialization**: Push elements to build the stack.  
- **Operations**: `push()`, `pop()`, `top()`, `empty()`, `size()`.  
- **Advantages**: Simple interface, O(1) operations for push/pop/top.  
- **Limitations**: No direct access to non-top elements; no iterators.

**Example Program**: Basic stack operations.

```cpp
#include <iostream>
#include <stack> // Include stack library
using namespace std;

int main() {
    // Declare stack
    stack<int> plates;

    // Push elements (add plates)
    plates.push(1); // Bottom
    plates.push(2);
    plates.push(3); // Top

    // Print size
    cout << "Size: " << plates.size() << endl; // Output: 3

    // Access top element
    cout << "Top plate: " << plates.top() << endl; // Output: 3

    // Pop top element
    plates.pop();
    cout << "After pop, top: " << plates.top() << endl; // Output: 2

    // Check if empty
    cout << "Is stack empty? " << (plates.empty() ? "Yes" : "No") << endl; // Output: No

    // Handle empty stack
    stack<int> empty_stack;
    cout << "Is empty_stack empty? " << (empty_stack.empty() ? "Yes" : "No") << endl; // Output: Yes

    return 0;
}
```

**Explanation**:  
- `#include <stack>`: Imports the stack library.  
- `push(x)`: Adds element to top (O(1)).  
- `pop()`: Removes top element (O(1)).  
- `top()`: Returns top element (O(1)).  
- `empty()`: Checks if stack is empty.

### 2. Stack Operations
STL `stack` provides a minimal, efficient interface for LIFO operations. Imagine managing a pile of plates where you can only interact with the topmost plate.

**Key Operations**:  
- `push(x)`: Adds element `x` to top.  
- `pop()`: Removes top element (no return value).  
- `top()`: Returns reference to top element.  
- `empty()`: Returns `true` if stack is empty.  
- `size()`: Returns number of elements.

**Example Program**: Stack-based expression evaluation.

```cpp
#include <iostream>
#include <stack>
#include <string>
using namespace std;

int evaluatePostfix(const string& expr) {
    stack<int> operands; // Stack for numbers
    // Assume expr is space-separated digits and operators (+, *)
    for (char c : expr) {
        if (isdigit(c)) {
            operands.push(c - '0'); // Convert char to int
        } else if (c == '+' || c == '*') {
            int b = operands.top(); operands.pop(); // Second operand
            int a = operands.top(); operands.pop(); // First operand
            if (c == '+') operands.push(a + b);
            else operands.push(a * b);
        }
    }
    return operands.top();
}

int main() {
    string expr = "5 3 + 2 *"; // (5 + 3) * 2 = 16
    cout << "Result: " << evaluatePostfix(expr) << endl; // Output: 16
    return 0;
}
```

**Explanation**:  
- Stack stores operands for postfix evaluation.  
- Digits are pushed; operators pop two operands, compute, and push result.  
- Demonstrates stack’s utility in expression parsing.

### 3. Comparison with Other Containers
- **Stack vs. Vector**: Stack restricts to LIFO; vector allows random access but requires manual index management.  
- **Stack vs. Deque**: Stack uses deque by default for O(1) push/pop; deque allows front/back operations but is more complex.  

**Example Program**: Stack vs. vector for LIFO.

```cpp
#include <iostream>
#include <stack>
#include <vector>
using namespace std;

int main() {
    // Using stack
    stack<int> s;
    s.push(1); s.push(2); s.push(3);
    cout << "Stack top: " << s.top() << endl; // Output: 3
    s.pop();
    cout << "Stack after pop: " << s.top() << endl; // Output: 2

    // Using vector as stack
    vector<int> v;
    v.push_back(1); v.push_back(2); v.push_back(3);
    cout << "Vector top: " << v.back() << endl; // Output: 3
    v.pop_back();
    cout << "Vector after pop: " << v.back() << endl; // Output: 2

    return 0;
}
```

**Explanation**:  
- Stack provides clean LIFO interface; vector requires manual `push_back`/`pop_back`.  
- Stack is safer for LIFO tasks, preventing accidental index access.

## Points to Remember (Interview Preparation)
1. **LIFO Principle**: Last-In-First-Out is key for stacks; ideal for reversing, parsing, or backtracking.  
2. **Time Complexities**:  
   - `push`, `pop`, `top`: O(1).  
   - `size`, `empty`: O(1).  
3. **Use Cases**: Stacks for expression evaluation, parentheses matching, and backtracking problems.  
4. **Safety**: Check `empty()` before `top` or `pop` to avoid undefined behavior.  
5. **Underlying Container**: Default is `deque`; can specify `vector` or `list` (e.g., `stack<int, vector<int>>`).  
6. **Interview Questions**: Be ready for parentheses validation, min stack, or monotonic stack problems.  
7. **Common Errors**: Avoid accessing `top`/`pop` on empty stack; no iterator support.