# Deep Dive: Two-Pointer Technique in Arrays

This deep dive explores advanced applications of the two-pointer technique, complex problems, and interview-focused insights.

## Complex Topics and Illustrations

### Advanced Two-Pointer: Sliding Window
Used for subarray problems (e.g., max sum, longest valid subarray).

Example (Longest Substring with At Most K Distinct Characters):
```cpp
#include <iostream>
#include <unordered_map>
int lengthOfLongestSubstringKDistinct(std::string s, int k) {
    std::unordered_map<char, int> map;
    int left = 0, maxLen = 0;
    for (int right = 0; right < s.size(); right++) {
        map[s[right]]++;
        while (map.size() > k) {
            map[s[left]]--;
            if (map[s[left]] == 0) map.erase(s[left]);
            left++;
        }
        maxLen = std::max(maxLen, right - left + 1);
    }
    return maxLen;
}
int main() {
    std::cout << lengthOfLongestSubstringKDistinct("eceba", 2) << std::endl; // Output: 3
    return 0;
}
```

### Multi-Pointer Extensions
Extend to three pointers for triplet problems.

Example (Triplet Sum):
```cpp
#include <iostream>
#include <algorithm>
bool findTriplet(int arr[], int n, int target) {
    std::sort(arr, arr + n);
    for (int i = 0; i < n - 2; i++) {
        int left = i + 1, right = n - 1;
        while (left < right) {
            int sum = arr[i] + arr[left] + arr[right];
            if (sum == target) return true;
            else if (sum < target) left++;
            else right--;
        }
    }
    return false;
}
int main() {
    int arr[] = {1, 4, 6, 8, 10};
    std::cout << (findTriplet(arr, 5, 12) ? "Yes" : "No") << std::endl; // Output: Yes
    return 0;
}
```

### Interview Questions and Detailed Answers

1. **Question:** Find two numbers summing to target (Two Sum). (Intention: Test efficiency, handling unsorted arrays.)  
   **Answer:** Sort for O(n log n) or use hash map for O(n). Two-pointer needs sorted array.
   ```cpp
   std::vector<int> twoSum(std::vector<int>& nums, int target) {
       std::vector<std::pair<int, int>> indexed;
       for (int i = 0; i < nums.size(); i++) indexed.push_back({nums[i], i});
       std::sort(indexed.begin(), indexed.end());
       int left = 0, right = nums.size() - 1;
       while (left < right) {
           int sum = indexed[left].first + indexed[right].first;
           if (sum == target) return {indexed[left].second, indexed[right].second};
           else if (sum < target) left++;
           else right--;
       }
       return {};
   }
   ```

2. **Question:** Remove duplicates from sorted array in-place. (Intention: In-place manipulation, pointer logic.)  
   **Answer:** Slow pointer for unique position, fast pointer scans. O(n) time, O(1) space.

3. **Question:** Find longest subarray with sum <= k. (Intention: Sliding window mastery.)  
   **Answer:** Two pointers adjust window based on sum. O(n) time.

4. **Question:** Why use two-pointer over brute force? (Intention: Understand efficiency.)  
   **Answer:** Reduces O(n²) to O(n) by avoiding redundant comparisons.

5. **Question:** Handle edge cases in two-pointer. (Intention: Robustness check.)  
   **Answer:** Check for empty arrays, single elements, invalid inputs.

6. **Question:** Partition array for quicksort-like logic. (Intention: Algorithm connection.)  
   **Answer:** Two pointers rearrange elements around pivot.

Pitfall: Ensure pointers don’t cross incorrectly, handle duplicates in sorted arrays.