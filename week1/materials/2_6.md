# Hour 2 LeetCode Problem: Sliding Window Maximum

This document illustrates **LeetCode 239: Sliding Window Maximum**, a hard problem that leverages STL deques for efficient sliding window processing. It includes the problem description, coding pattern, brute-force and optimized solutions, complexity analysis, and test cases.

## Problem Statement: LeetCode 239 - Sliding Window Maximum
**Link**: [LeetCode 239](https://leetcode.com/problems/sliding-window-maximum/)

**Description**:  
Given an array `nums` and an integer `k`, return the maximum element in each sliding window of size `k`. The window moves one position to the right each time.

**Constraints**:
- `1 <= nums.length <= 10^5`
- `-10^4 <= nums[i] <= 10^4`
- `1 <= k <= nums.length`

**Example**:
- Input: `nums = [1,3,-1,-3,5,3,6,7], k = 3`  
  Output: `[3,3,5,5,6,7]`  
  Explanation: Maximums for windows: [1,3,-1] → 3, [3,-1,-3] → 3, [-1,-3,5] → 5, etc.

**Real-World Analogy**: Imagine a conveyor belt with items passing by a window of fixed size `k`. You need to report the largest item visible in the window as it moves.

## Coding Pattern: Monotonic Deque
- Use a deque to maintain indices of potential maximums in decreasing order.
- Remove out-of-window indices and smaller elements to keep the deque monotonic.
- The front of the deque always holds the maximum’s index.

## Brute-Force Solution
**Algorithm**:
1. For each window of size `k`, iterate to find the maximum.
2. Store maximums in a result vector.

**Code**:
```cpp
#include <vector>
using namespace std;

class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        vector<int> result;
        // For each window
        for (int i = 0; i <= nums.size() - k; ++i) {
            int maxVal = nums[i];
            // Find max in window
            for (int j = i; j < i + k; ++j) {
                maxVal = max(maxVal, nums[j]);
            }
            result.push_back(maxVal);
        }
        return result;
    }
};
```

**Time Complexity**: O(n * k)  
- Each window requires O(k) to find the maximum.
- Total: O(n * k) for n-k+1 windows.

**Space Complexity**: O(n-k+1)  
- Stores result vector.

**Why It’s Not Optimal**: O(n * k) is too slow for large `n` and `k`.

## Optimized Solution (Monotonic Deque)
**Algorithm**:
1. Use a deque to store indices of potential maximums.
2. For each element:
   - Remove out-of-window indices from front.
   - Remove smaller elements from back.
   - Add current index to back.
3. After processing first `k` elements, the front index is the maximum.
4. Repeat for remaining windows.

**Code**:
```cpp
#include <vector>
#include <deque>
using namespace std;

class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        vector<int> result;
        deque<int> dq; // Store indices of potential maximums

        // Process first k elements
        for (int i = 0; i < k; ++i) {
            // Remove smaller elements from back
            while (!dq.empty() && nums[dq.back()] <= nums[i]) {
                dq.pop_back();
            }
            dq.push_back(i);
        }
        result.push_back(nums[dq.front()]); // Maximum of first window

        // Process remaining windows
        for (int i = k; i < nums.size(); ++i) {
            // Remove indices outside current window
            while (!dq.empty() && dq.front() <= i - k) {
                dq.pop_front();
            }
            // Remove smaller elements
            while (!dq.empty() && nums[dq.back()] <= nums[i]) {
                dq.pop_back();
            }
            dq.push_back(i);
            result.push_back(nums[dq.front()]); // Maximum of current window
        }

        return result;
    }
};
```

**Time Complexity**: O(n)  
- Each element is pushed/popped at most once: O(n).
- Each operation (push/pop) is O(1).

**Space Complexity**: O(k)  
- Deque stores at most `k` indices.

**Explanation**:
- Deque maintains indices in decreasing order of their values.
- Front index is the maximum; out-of-window indices are removed.
- Smaller elements are removed from back to keep deque monotonic.

## Test Cases
1. **Typical Case**: `nums = [1,3,-1,-3,5,3,6,7], k = 3` → Output: `[3,3,5,5,6,7]`  
2. **Single Element**: `nums = [1], k = 1` → Output: `[1]`  
3. **All Same**: `nums = [1,1,1,1], k = 2` → Output: `[1,1,1]`  
4. **Large k**: `nums = [1,2,3], k = 3` → Output: `[3]`  
5. **Negative Numbers**: `nums = [-7,-8,7,5,7,1,6,0], k = 4` → Output: `[7,7,7,7,7]`  
6. **k = 1**: `nums = [1,2,3], k = 1` → Output: `[1,2,3]`  

**Test Case Implementation**:
```cpp
#include <iostream>
#include <vector>
#include <deque>
using namespace std;

vector<int> maxSlidingWindow(vector<int>& nums, int k) {
    vector<int> result;
    deque<int> dq;

    for (int i = 0; i < k; ++i) {
        while (!dq.empty() && nums[dq.back()] <= nums[i]) {
            dq.pop_back();
        }
        dq.push_back(i);
    }
    result.push_back(nums[dq.front()]);

    for (int i = k; i < nums.size(); ++i) {
        while (!dq.empty() && dq.front() <= i - k) {
            dq.pop_front();
        }
        while (!dq.empty() && nums[dq.back()] <= nums[i]) {
            dq.pop_back();
        }
        dq.push_back(i);
        result.push_back(nums[dq.front()]);
    }
    return result;
}

void printResult(const vector<int>& result) {
    cout << "[";
    for (size_t i = 0; i < result.size(); ++i) {
        cout << result[i];
        if (i < result.size() - 1) cout << ",";
    }
    cout << "]" << endl;
}

int main() {
    // Test Case 1
    vector<int> nums1 = {1,3,-1,-3,5,3,6,7};
    int k1 = 3;
    cout << "Test 1: "; printResult(maxSlidingWindow(nums1, k1));

    // Test Case 2
    vector<int> nums2 = {1};
    int k2 = 1;
    cout << "Test 2: "; printResult(maxSlidingWindow(nums2, k2));

    // Test Case 3
    vector<int> nums3 = {1,1,1,1};
    int k3 = 2;
    cout << "Test 3: "; printResult(maxSlidingWindow(nums3, k3));

    // Test Case 4
    vector<int> nums4 = {1,2,3};
    int k4 = 3;
    cout << "Test 4: "; printResult(maxSlidingWindow(nums4, k4));

    // Test Case 5
    vector<int> nums5 = {-7,-8,7,5,7,1,6,0};
    int k5 = 4;
    cout << "Test 5: "; printResult(maxSlidingWindow(nums5, k5));

    // Test Case 6
    vector<int> nums6 = {1,2,3};
    int k6 = 1;
    cout << "Test 6: "; printResult(maxSlidingWindow(nums6, k6));

    return 0;
}
```

**Output**:
```
Test 1: [3,3,5,5,6,7]
Test 2: [1]
Test 3: [1,1,1]
Test 4: [3]
Test 5: [7,7,7,7,7]
Test 6: [1,2,3]
```

## Optimization Mindset
- **Brute-Force**: O(n * k) by scanning each window, inefficient for large `k`.  
- **Optimized**: Use deque to maintain monotonic property, reducing to O(n).  
- **Key Insight**: Leverage deque’s O(1) front/back operations for sliding windows.  
- **Edge Cases**: Handle single-element, same-element, and large `k` scenarios.