# Solutions for Leetcode Problems

1. **Maximum Subarray**  
   **Explanation:** Find max sum subarray. Example: [-2,1,-3,4,-1,2,1,-5,4] -> 6.  
   **Brute-Force:** Check all subarrays.  
   ```cpp
   int maxSubArray(vector<int>& nums) {
       int maxSum = nums[0];
       for (int i = 0; i < nums.size(); i++) {
           int sum = 0;
           for (int j = i; j < nums.size(); j++) {
               sum += nums[j];
               maxSum = max(maxSum, sum);
           }
       }
       return maxSum;
   }
   ```
   Pros: Works. Cons: O(n²) time.  
   **Optimized:** Kadane’s algorithm.  
   ```cpp
   int maxSubArray(vector<int>& nums) {
       int maxSum = nums[0], currSum = nums[0];
       for (int i = 1; i < nums.size(); i++) {
           currSum = max(nums[i], currSum + nums[i]);
           maxSum = max(maxSum, currSum);
       }
       return maxSum;
   }
   ```
   Pros: O(n) time, O(1) space. Cons: None.

2. **Subarray Sum Equals K**  
   **Explanation:** Count subarrays summing to k.  
   **Brute-Force:** Check all subarrays.  
   ```cpp
   int subarraySum(vector<int>& nums, int k) {
       int count = 0;
       for (int i = 0; i < nums.size(); i++) {
           int sum = 0;
           for (int j = i; j < nums.size(); j++) {
               sum += nums[j];
               if (sum == k) count++;
           }
       }
       return count;
   }
   ```
   Pros: Simple. Cons: O(n²) time.  
   **Optimized:** Prefix sum with hash map.  
   ```cpp
   #include <unordered_map>
   int subarraySum(vector<int>& nums, int k) {
       unordered_map<int, int> map;
       map[0] = 1;
       int sum = 0, count = 0;
       for (int num : nums) {
           sum += num;
           if (map.find(sum - k) != map.end()) count += map[sum - k];
           map[sum]++;
       }
       return count;
   }
   ```
   Pros: O(n) time, O(n) space. Cons: Extra space.

3. **Minimum Size Subarray Sum**  
   **Explanation:** Find smallest subarray with sum >= target.  
   **Brute-Force:** Check all subarrays.  
   ```cpp
   int minSubArrayLen(int target, vector<int>& nums) {
       int minLen = nums.size() + 1;
       for (int i = 0; i < nums.size(); i++) {
           int sum = 0;
           for (int j = i; j < nums.size(); j++) {
               sum += nums[j];
               if (sum >= target) minLen = min(minLen, j - i + 1);
           }
       }
       return minLen > nums.size() ? 0 : minLen;
   }
   ```
   Pros: Works. Cons: O(n²) time.  
   **Optimized:** Sliding window.  
   ```cpp
   int minSubArrayLen(int target, vector<int>& nums) {
       int sum = 0, minLen = nums.size() + 1, left = 0;
       for (int right = 0; right < nums.size(); right++) {
           sum += nums[right];
           while (sum >= target && left <= right) {
               minLen = min(minLen, right - left + 1);
               sum -= nums[left++];
           }
       }
       return minLen > nums.size() ? 0 : minLen;
   }
   ```
   Pros: O(n) time, O(1) space. Cons: None.

4. **Maximum Product Subarray**  
   **Explanation:** Find max product subarray.  
   **Brute-Force:** Check all subarrays.  
   ```cpp
   int maxProduct(vector<int>& nums) {
       int maxProd = nums[0];
       for (int i = 0; i < nums.size(); i++) {
           int prod = 1;
           for (int j = i; j < nums.size(); j++) {
               prod *= nums[j];
               maxProd = max(maxProd, prod);
           }
       }
       return maxProd;
   }
   ```
   Pros: Correct. Cons: O(n²) time.  
   **Optimized:** Modified Kadane’s.  
   ```cpp
   int maxProduct(vector<int>& nums) {
       int maxProd = nums[0], currMax = nums[0], currMin = nums[0];
       for (int i = 1; i < nums.size(); i++) {
           int temp = currMax;
           currMax = max({nums[i], currMax * nums[i], currMin * nums[i]});
           currMin = min({nums[i], temp * nums[i], currMin * nums[i]});
           maxProd = max(maxProd, currMax);
       }
       return maxProd;
   }
   ```
   Pros: O(n) time, O(1) space. Cons: Complex logic for negatives.

5. **Subarray Product Less Than K**  
   **Explanation:** Count subarrays with product < k.  
   **Brute-Force:** Check all subarrays.  
   ```cpp
   int numSubarrayProductLessThanK(vector<int>& nums, int k) {
       int count = 0;
       for (int i = 0; i < nums.size(); i++) {
           int prod = 1;
           for (int j = i; j < nums.size(); j++) {
               prod *= nums[j];
               if (prod < k) count++;
               else break;
           }
       }
       return count;
   }
   ```
   Pros: Simple. Cons: O(n²) time.  
   **Optimized:** Sliding window.  
   ```cpp
   int numSubarrayProductLessThanK(vector<int>& nums, int k) {
       if (k <= 1) return 0;
       int prod = 1, count = 0, left = 0;
       for (int right = 0; right < nums.size(); right++) {
           prod *= nums[right];
           while (prod >= k && left <= right) prod /= nums[left++];
           count += right - left + 1;
       }
       return count;
   }
   ```
   Pros: O(n) time, O(1) space. Cons: None.