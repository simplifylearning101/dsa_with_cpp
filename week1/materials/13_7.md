# Hour 13 Additional LeetCode Problems: Advanced STL Algorithms Solutions

This document provides solutions for two LeetCode problems recommended in `13_2.md`: **LeetCode 350: Intersection of Two Arrays II** and **LeetCode 15: 3Sum**. Each solution includes a problem description, coding pattern, optimized solution with commented C++ code using STL algorithms, complexity analysis, and test cases.

## Agenda
- Provide optimized solutions using advanced STL algorithms and containers.  
- Explain coding patterns (e.g., counting, sorting).  
- Analyze complexities and test cases.

## Outcome Expected
Students will:  
- Master STL algorithms for array intersections and tuple problems.  
- Apply functors and lambdas effectively.  
- Handle edge cases for interviews.

---

## 1. LeetCode 350: Intersection of Two Arrays II (Easy)

**Link**: [LeetCode 350](https://leetcode.com/problems/intersection-of-two-arrays-ii/)

**Description**:  
Given two integer arrays `nums1` and `nums2`, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays.

**Constraints**:
- `1 <= nums1.length, nums2.length <= 1000`
- `0 <= nums1[i], nums2[i] <= 1000`

**Example**:
- Input: `nums1 = [1,2,2,1], nums2 = [2,2]`  
  Output: `[2,2]`  
  Explanation: `2` appears twice in both arrays.

**Coding Pattern**: Unordered Multiset with for_each
- Use `unordered_multiset` to count elements.  
- Use `for_each` to collect intersections.

**Optimized Solution**:
```cpp
#include <vector>
#include <unordered_set>
#include <algorithm>
using namespace std;

class Solution {
public:
    vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {
        unordered_multiset<int> ms(nums1.begin(), nums1.end());
        vector<int> result;
        for_each(nums2.begin(), nums2.end(), [&](int x) {
            auto it = ms.find(x);
            if (it != ms.end()) {
                result.push_back(x);
                ms.erase(it);
            }
        });
        return result;
    }
};
```

**Time Complexity**: O(n + m)  
- Building `unordered_multiset`: O(n).  
- `for_each` with `find`/`erase`: O(m) average.

**Space Complexity**: O(n + k)  
- `unordered_multiset`: O(n); result: O(k).

**Explanation**:  
- `unordered_multiset` handles duplicates.  
- `for_each` checks and removes matches.

**Test Cases**:
1. **Typical Case**: `nums1 = [1,2,2,1], nums2 = [2,2]` → Output: `[2,2]`  
2. **No Intersection**: `nums1 = [1,2], nums2 = [3,4]` → Output: `[]`  
3. **Single Element**: `nums1 = [1], nums2 = [1]` → Output: `[1]`  
4. **Duplicates**: `nums1 = [1,1,1], nums2 = [1,1]` → Output: `[1,1]`  
5. **Empty Result**: `nums1 = [1,2], nums2 = [2]` → Output: `[2]`  

---

## 2. LeetCode 15: 3Sum (Medium)

**Link**: [LeetCode 15](https://leetcode.com/problems/3sum/)

**Description**:  
Given an integer array `nums`, return all triplets `[nums[i], nums[j], nums[k]]` such that `i != j != k` and `nums[i] + nums[j] + nums[k] == 0`. The solution set must not contain duplicate triplets.

**Constraints**:
- `0 <= nums.length <= 3000`
- `-10^5 <= nums[i] <= 10^5`

**Example**:
- Input: `nums = [-1,0,1,2,-1,-4]`  
  Output: `[[-1,-1,2],[-1,0,1]]`  
  Explanation: Triplets sum to 0, no duplicates.

**Coding Pattern**: Sort and Two-Pointer with for_each
- Sort array using `sort`.  
- Use `for_each` for first element, two-pointer for others.

**Optimized Solution**:
```cpp
#include <vector>
#include <algorithm>
using namespace std;

class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> result;
        sort(nums.begin(), nums.end());
        for_each(nums.begin(), nums.end() - 2, [&](int num) {
            static int last = INT_MAX;
            if (num == last || num > 0) return;  // Skip duplicates and positive
            last = num;
            int left = &num - &nums[0] + 1, right = nums.size() - 1;
            while (left < right) {
                int sum = num + nums[left] + nums[right];
                if (sum == 0) {
                    result.push_back({num, nums[left], nums[right]});
                    while (left < right && nums[left] == nums[left + 1]) left++;
                    while (left < right && nums[right] == nums[right - 1]) right--;
                    left++; right--;
                } else if (sum < 0) {
                    left++;
                } else {
                    right--;
                }
            }
        });
        return result;
    }
};
```

**Time Complexity**: O(n^2)  
- `sort`: O(n log n).  
- `for_each` with two-pointer: O(n^2).

**Space Complexity**: O(1) excluding output  
- In-place sorting; output size varies.

**Explanation**:  
- `sort` enables two-pointer technique.  
- `for_each` iterates first element, skips duplicates.  
- Two-pointer finds pairs summing to `-num`.

**Test Cases**:
1. **Typical Case**: `nums = [-1,0,1,2,-1,-4]` → Output: `[[-1,-1,2],[-1,0,1]]`  
2. **No Solution**: `nums = [0,1,1]` → Output: `[]`  
3. **All Zeros**: `nums = [0,0,0]` → Output: `[[0,0,0]]`  
4. **Single Triplet**: `nums = [-2,0,2]` → Output: `[[-2,0,2]]`  
5. **Duplicates**: `nums = [-1,-1,-1,0,0,1]` → Output: `[[-1,0,1]]`  

---

## Test Case Implementation
Below is a program to test both solutions.

```cpp
#include <iostream>
#include <vector>
#include <unordered_set>
#include <algorithm>
using namespace std;

// LeetCode 350: Intersection of Two Arrays II
vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {
    unordered_multiset<int> ms(nums1.begin(), nums1.end());
    vector<int> result;
    for_each(nums2.begin(), nums2.end(), [&](int x) {
        auto it = ms.find(x);
        if (it != ms.end()) {
            result.push_back(x);
            ms.erase(it);
        }
    });
    return result;
}

// LeetCode 15: 3Sum
vector<vector<int>> threeSum(vector<int>& nums) {
    vector<vector<int>> result;
    sort(nums.begin(), nums.end());
    for_each(nums.begin(), nums.end() - 2, [&](int num) {
        static int last = INT_MAX;
        if (num == last || num > 0) return;
        last = num;
        int left = &num - &nums[0] + 1, right = nums.size() - 1;
        while (left < right) {
            int sum = num + nums[left] + nums[right];
            if (sum == 0) {
                result.push_back({num, nums[left], nums[right]});
                while (left < right && nums[left] == nums[left + 1]) left++;
                while (left < right && nums[right] == nums[right - 1]) right--;
                left++; right--;
            } else if (sum < 0) {
                left++;
            } else {
                right--;
            }
        }
    });
    return result;
}

void printVector(const vector<int>& v) {
    cout << "[";
    for (int i = 0; i < v.size(); ++i) {
        cout << v[i];
        if (i < v.size() - 1) cout << ",";
    }
    cout << "]";
}

void printVectorOfVectors(const vector<vector<int>>& vv) {
    cout << "[";
    for (int i = 0; i < vv.size(); ++i) {
        printVector(vv[i]);
        if (i < vv.size() - 1) cout << ",";
    }
    cout << "]";
}

int main() {
    // Test LeetCode 350
    cout << "LeetCode 350: Intersection of Two Arrays II\n";
    vector<int> nums1 = {1, 2, 2, 1}, nums2 = {2, 2};
    vector<int> result1 = intersect(nums1, nums2);
    cout << "Test 1: "; printVector(result1);  // [2,2]
    cout << endl;
    
    // Test LeetCode 15
    cout << "\nLeetCode 15: 3Sum\n";
    vector<int> nums3 = {-1, 0, 1, 2, -1, -4};
    vector<vector<int>> result2 = threeSum(nums3);
    cout << "Test 1: "; printVectorOfVectors(result2);  // [[-1,-1,2],[-1,0,1]]
    cout << endl;
    
    return 0;
}
```

**Output**:
```
LeetCode 350: Intersection of Two Arrays II
Test 1: [2,2]

LeetCode 15: 3Sum
Test 1: [[-1,-1,2],[-1,0,1]]
```

## Key Takeaways
- **Intersection**: `unordered_multiset` with `for_each` handles duplicates efficiently.  
- **3Sum**: Sorting with `for_each` and two-pointer avoids duplicates.