# Deep Dive: Advanced Array Problems and Two-Pointer Applications

This deep dive explores complex array problems, advanced sliding window techniques, and interview-focused strategies.

## Complex Topics and Illustrations

### Advanced Sliding Window
Variable-size sliding windows handle constraints like sum, product, or distinct elements.

Example (Smallest Subarray with Sum >= k):
```cpp
#include <iostream>
int smallestSubarray(int arr[], int n, int k) {
    int sum = 0, minLen = n + 1, left = 0;
    for (int right = 0; right < n; right++) {
        sum += arr[right];
        while (sum >= k && left <= right) {
            minLen = std::min(minLen, right - left + 1);
            sum -= arr[left++];
        }
    }
    return minLen > n ? -1 : minLen;
}
int main() {
    int arr[] = {2, 3, 1, 2, 4, 3};
    std::cout << smallestSubarray(arr, 6, 7) << std::endl; // Output: 2
    return 0;
}
```

### Prefix Sum with Hash Map
Combines prefix sums with hash maps for subarray counting.

Example (Subarrays with Sum = k):
```cpp
#include <iostream>
#include <unordered_map>
int subarraySum(int arr[], int n, int k) {
    std::unordered_map<int, int> map;
    map[0] = 1;
    int sum = 0, count = 0;
    for (int i = 0; i < n; i++) {
        sum += arr[i];
        if (map.find(sum - k) != map.end()) count += map[sum - k];
        map[sum]++;
    }
    return count;
}
int main() {
    int arr[] = {1, 1, 1};
    std::cout << subarraySum(arr, 3, 2) << std::endl; // Output: 2
    return 0;
}
```

### Interview Questions and Detailed Answers

1. **Question:** Maximum subarray sum. (Intention: Test Kadane’s efficiency.)  
   **Answer:** Kadane’s algorithm, O(n) time, handles negatives by resetting sum.
   ```cpp
   int maxSubArray(int arr[], int n) {
       int maxSum = arr[0], currSum = arr[0];
       for (int i = 1; i < n; i++) {
           currSum = std::max(arr[i], currSum + arr[i]);
           maxSum = std::max(maxSum, currSum);
       }
       return maxSum;
   }
   ```

2. **Question:** Count subarrays with sum = k. (Intention: Prefix sum and hash map.)  
   **Answer:** Use hash map to store prefix sums, O(n) time.

3. **Question:** Smallest subarray with sum >= k. (Intention: Sliding window optimization.)  
   **Answer:** Variable window, minimize length when sum meets condition.

4. **Question:** Why use prefix sum over brute force? (Intention: Efficiency.)  
   **Answer:** O(n) preprocessing, O(1) queries vs. O(n²) for brute force.

5. **Question:** Handle edge cases in sliding window. (Intention: Robustness.)  
   **Answer:** Check empty arrays, invalid k, or no solution cases.

6. **Question:** Maximum product subarray. (Intention: Handle negatives.)  
   **Answer:** Track max and min products due to negative number flips.

Pitfall: Ensure proper window adjustments, handle edge cases like all negatives.