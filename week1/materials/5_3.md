# Hour 5 Homework Solutions: Queue Practice Problems

Below are solutions to the 12 homework problems, each with fully commented C++ code to help students understand STL `queue` implementation. The solutions are beginner-friendly and emphasize interview-relevant techniques.

1. **Problem**: Create a queue, push 5 integers, and print its size.  
```cpp
#include <iostream>
#include <queue>
using namespace std;

int main() {
    queue<int> q;
    
    // Push 5 integers
    for (int i = 1; i <= 5; ++i) {
        q.push(i);
    }
    
    // Print size
    cout << "Size: " << q.size() << endl; // Output: 5
    
    return 0;
}
```

2. **Problem**: Pop elements and print in order.  
```cpp
#include <iostream>
#include <queue>
using namespace std;

int main() {
    queue<int> q;
    q.push(1); q.push(2); q.push(3);
    
    // Pop and print
    while (!q.empty()) {
        cout << q.front() << " "; // Output: 1 2 3
        q.pop();
    }
    cout << endl;
    
    return 0;
}
```

3. **Problem**: Check if a queue is empty after pushing and popping.  
```cpp
#include <iostream>
#include <queue>
using namespace std;

int main() {
    queue<int> q;
    q.push(1);
    q.pop();
    
    // Check empty
    cout << "Empty: " << (q.empty() ? "Yes" : "No") << endl; // Output: Yes
    
    return 0;
}
```

4. **Problem**: Reverse a queue using a stack.  
```cpp
#include <iostream>
#include <queue>
#include <stack>
using namespace std;

void reverseQueue(queue<int>& q) {
    stack<int> s;
    // Move all elements to stack
    while (!q.empty()) {
        s.push(q.front());
        q.pop();
    }
    // Move back to queue
    while (!s.empty()) {
        q.push(s.top());
        s.pop();
    }
}

int main() {
    queue<int> q;
    q.push(1); q.push(2); q.push(3);
    reverseQueue(q);
    
    // Print reversed queue
    while (!q.empty()) {
        cout << q.front() << " "; // Output: 3 2 1
        q.pop();
    }
    cout << endl;
    
    return 0;
}
```

5. **Problem**: Simulate a ticket counter serving customers.  
```cpp
#include <iostream>
#include <queue>
#include <string>
using namespace std;

void serveCustomers(const vector<string>& customers) {
    queue<string> q;
    for (const string& c : customers) {
        q.push(c);
    }
    
    // Serve customers
    while (!q.empty()) {
        cout << "Served: " << q.front() << endl; // Output: Served: Alice, Served: Bob
        q.pop();
    }
}

int main() {
    vector<string> customers = {"Alice", "Bob"};
    serveCustomers(customers);
    return 0;
}
```

6. **Problem**: Implement a queue using two stacks.  
```cpp
#include <iostream>
#include <stack>
using namespace std;

class MyQueue {
private:
    stack<int> in, out; // in for push, out for pop
public:
    void push(int x) {
        in.push(x);
    }
    void pop() {
        if (out.empty()) {
            while (!in.empty()) {
                out.push(in.top());
                in.pop();
            }
        }
        if (!out.empty()) out.pop();
    }
    int front() {
        if (out.empty()) {
            while (!in.empty()) {
                out.push(in.top());
                in.pop();
            }
        }
        return out.empty() ? -1 : out.top();
    }
    bool empty() {
        return in.empty() && out.empty();
    }
};

int main() {
    MyQueue q;
    q.push(1); q.push(2); q.push(3);
    cout << "Front: " << q.front() << endl; // Output: 1
    q.pop();
    cout << "Front after pop: " << q.front() << endl; // Output: 2
    return 0;
}
```

7. **Problem**: Find first non-repeating character in a stream.  
```cpp
#include <iostream>
#include <queue>
#include <string>
#include <unordered_map>
using namespace std;

void firstNonRepeating(const string& stream) {
    queue<char> q;
    unordered_map<char, int> freq;
    
    // Process stream
    for (char c : stream) {
        freq[c]++;
        q.push(c);
        // Remove repeating chars from front
        while (!q.empty() && freq[q.front()] > 1) {
            q.pop();
        }
        // Print first non-repeating or -1
        cout << (q.empty() ? -1 : q.front()) << " ";
    }
    cout << endl;
}

int main() {
    string stream = "aabbc";
    firstNonRepeating(stream); // Output: a a b b c
    return 0;
}
```

8. **Problem**: Calculate average of last k elements in a stream.  
```cpp
#include <iostream>
#include <queue>
using namespace std;

double movingAverage(const vector<int>& stream, int k) {
    queue<int> q;
    double sum = 0;
    for (int x : stream) {
        q.push(x);
        sum += x;
        // If window size exceeded, remove oldest
        if (q.size() > k) {
            sum -= q.front();
            q.pop();
        }
        // Print average
        cout << "Average: " << sum / min((int)q.size(), k) << endl;
    }
    return sum / min((int)q.size(), k);
}

int main() {
    vector<int> stream = {1, 2, 3};
    int k = 2;
    movingAverage(stream, k); // Output: Average: 1, Average: 1.5, Average: 2.5
    return 0;
}
```

9. **Problem**: Implement a circular queue with fixed size.  
```cpp
#include <iostream>
#include <vector>
using namespace std;

class CircularQueue {
private:
    vector<int> data;
    int front, rear, size, capacity;
public:
    CircularQueue(int k) : capacity(k), size(0), front(0), rear(-1), data(k) {}
    
    bool enQueue(int value) {
        if (isFull()) return false;
        rear = (rear + 1) % capacity;
        data[rear] = value;
        size++;
        return true;
    }
    
    bool deQueue() {
        if (isEmpty()) return false;
        front = (front + 1) % capacity;
        size--;
        return true;
    }
    
    int Front() {
        return isEmpty() ? -1 : data[front];
    }
    
    int Rear() {
        return isEmpty() ? -1 : data[rear];
    }
    
    bool isEmpty() {
        return size == 0;
    }
    
    bool isFull() {
        return size == capacity;
    }
};

int main() {
    CircularQueue q(3);
    q.enQueue(1); q.enQueue(2); q.enQueue(3);
    cout << "Full: " << (q.isFull() ? "Yes" : "No") << endl; // Output: Yes
    cout << "Front: " << q.Front() << endl; // Output: 1
    return 0;
}
```

10. **Problem**: Merge two queues alternately.  
```cpp
#include <iostream>
#include <queue>
using namespace std;

queue<int> mergeQueues(queue<int> q1, queue<int> q2) {
    queue<int> result;
    while (!q1.empty() || !q2.empty()) {
        if (!q1.empty()) {
            result.push(q1.front());
            q1.pop();
        }
        if (!q2.empty()) {
            result.push(q2.front());
            q2.pop();
        }
    }
    return result;
}

int main() {
    queue<int> q1, q2;
    q1.push(1); q1.push(3);
    q2.push(2); q2.push(4);
    queue<int> result = mergeQueues(q1, q2);
    
    // Print merged queue
    while (!result.empty()) {
        cout << result.front() << " "; // Output: 1 2 3 4
        result.pop();
    }
    cout << endl;
    return 0;
}
```

11. **Problem**: Simulate a printer queue with priority.  
```cpp
#include <iostream>
#include <queue>
#include <vector>
using namespace std;

void printJobs(const vector<pair<int, string>>& jobs) {
    // Priority queue for high-priority jobs
    priority_queue<pair<int, string>> pq;
    queue<pair<int, string>> q; // Regular queue for low-priority
    
    // Separate jobs by priority
    for (const auto& job : jobs) {
        if (job.second == "high") pq.push(job);
        else q.push(job);
    }
    
    // Process high-priority first
    while (!pq.empty()) {
        cout << "Printing: " << pq.top().first << endl;
        pq.pop();
    }
    // Then low-priority
    while (!q.empty()) {
        cout << "Printing: " << q.front().first << endl;
        q.pop();
    }
}

int main() {
    vector<pair<int, string>> jobs = {{1, "low"}, {2, "high"}, {3, "low"}};
    printJobs(jobs); // Output: Printing: 2, Printing: 1, Printing: 3
    return 0;
}
```

12. **Problem**: Find time to process tasks with cooldown.  
```cpp
#include <iostream>
#include <queue>
#include <unordered_map>
using namespace std;

int scheduleTasks(const vector<int>& tasks, int cooldown) {
    queue<pair<int, int>> q; // {task, time}
    unordered_map<int, int> last_seen; // Last time task was processed
    int time = 0;
    
    for (int task : tasks) {
        time++;
        if (last_seen.count(task) && time - last_seen[task] <= cooldown) {
            // Wait until cooldown expires
            time = last_seen[task] + cooldown + 1;
        }
        q.push({task, time});
        last_seen[task] = time;
    }
    
    return time;
}

int main() {
    vector<int> tasks = {1, 1, 2};
    int cooldown = 2;
    cout << "Total time: " << scheduleTasks(tasks, cooldown) << endl; // Output: 7
    return 0;
}
```