# Hour 3: Strings in STL

**Agenda**: Introduce students to C++ STL strings, building on their understanding of vectors (Hour 1) and arrays/deques (Hour 2). Use real-world analogies and fully commented programs to simplify concepts. Emphasize practical usage, string manipulation techniques, and preparation for coding interviews.

**Outcome Expected**:  
By the end of this hour, students will:  
- Understand STL `string` as a dynamic, versatile container for text.  
- Master common string operations (e.g., concatenation, substring, searching).  
- Compare STL strings with C-style strings for safety and flexibility.  
- Write C++ programs using strings with proper syntax and error handling.  
- Be ready to solve LeetCode problems involving string manipulation using STL.

## Topics Covered
1. **STL String: Dynamic Text Container**  
   - Declaration, initialization, and basic operations.  
   - Advantages over C-style strings (dynamic sizing, safety).  
   - Real-world analogy: String as a flexible notebook for text.  
2. **String Operations**  
   - Concatenation, substring, find, replace, and more.  
   - Iterator-based traversal and modification.  
   - Real-world analogy: Editing a document with search-and-replace.  
3. **Comparison with Other Containers**  
   - Strings vs. vectors (character storage).  
   - Strings vs. C-style strings (null-terminated arrays).  

## Detailed Explanation of Topics Covered

### 1. STL String: Dynamic Text Container
The STL `string` is a dynamic container for storing and manipulating text, internally managing a character array. Unlike C-style strings, it handles memory automatically and provides a rich set of methods. Think of an STL `string` as a flexible notebook where you can add, remove, or edit text without worrying about size limits.

**Key Features**:  
- **Declaration**: `string s;` (empty string) or `string s = "hello";`.  
- **Initialization**: Literal, copy, substring, or fill constructor.  
- **Operations**: `+=` (concatenation), `substr()`, `find()`, `replace()`, `size()`, `empty()`.  
- **Advantages**: Dynamic resizing, bounds checking, no null-terminator issues.  
- **Limitations**: Slightly slower than C-style strings for raw access due to overhead.

**Example Program**: Basic string operations.

```cpp
#include <iostream>
#include <string> // Include string library
using namespace std;

int main() {
    // Declare and initialize strings
    string notebook = "Hello, World!";
    string empty_notebook;

    // Print size and content
    cout << "Size: " << notebook.size() << endl; // Output: 13
    cout << "Content: " << notebook << endl; // Output: Hello, World!

    // Concatenation
    notebook += " Welcome!"; // Append text
    cout << "After concatenation: " << notebook << endl; // Output: Hello, World! Welcome!

    // Check if empty
    cout << "Is empty_notebook empty? " << (empty_notebook.empty() ? "Yes" : "No") << endl; // Output: Yes

    // Access characters safely
    try {
        cout << "Character at index 5: " << notebook.at(5) << endl; // Output: ,
        // notebook.at(100); // Throws out_of_range
    } catch (const out_of_range& e) {
        cout << "Error: " << e.what() << endl;
    }

    return 0;
}
```

**Explanation**:  
- `#include <string>`: Imports the string library.  
- `size()`: Returns length of the string.  
- `+=`: Concatenates strings efficiently.  
- `at(i)`: Safe access with bounds checking.  

### 2. String Operations
STL `string` provides powerful methods for manipulation, such as finding substrings, replacing text, and extracting portions. Imagine editing a document where you can search, replace, or extract sections of text.

**Key Operations**:  
- `substr(pos, len)`: Extracts a substring.  
- `find(str)`: Returns index of first occurrence or `string::npos`.  
- `replace(pos, len, str)`: Replaces a portion with new text.  
- `push_back(c)`, `pop_back()`: Add/remove characters (like deque).  

**Example Program**: String manipulation.

```cpp
#include <iostream>
#include <string>
using namespace std;

int main() {
    // Initialize string
    string document = "Learning C++ is fun!";

    // Extract substring
    string sub = document.substr(9, 3); // Start at index 9, length 3
    cout << "Substring: " << sub << endl; // Output: C++

    // Find a word
    size_t pos = document.find("is");
    if (pos != string::npos) {
        cout << "'is' found at index: " << pos << endl; // Output: 11
    } else {
        cout << "'is' not found" << endl;
    }

    // Replace text
    document.replace(9, 3, "Python"); // Replace "C++" with "Python"
    cout << "After replace: " << document << endl; // Output: Learning Python is fun!

    // Add and remove characters
    document.push_back('!'); // Add exclamation
    cout << "After push_back: " << document << endl; // Output: Learning Python is fun!!
    document.pop_back(); // Remove last character
    cout << "After pop_back: " << document << endl; // Output: Learning Python is fun!

    return 0;
}
```

**Explanation**:  
- `substr(9, 3)`: Extracts "C++" from index 9.  
- `find("is")`: Returns index 11 where "is" starts.  
- `replace`: Modifies a specific portion.  
- `push_back` and `pop_back`: Treat string like a deque for single characters.

### 3. Comparison with Other Containers
- **String vs. Vector<char>**: Strings are specialized for text (e.g., `find`, `substr`), while `vector<char>` is general-purpose but lacks text-specific methods.  
- **String vs. C-style Strings**: STL strings are dynamic and safe; C-style strings (`char*`) are null-terminated, error-prone, and require manual memory management.

**Example Program**: String vs. C-style string.

```cpp
#include <iostream>
#include <string>
#include <cstring>
using namespace std;

int main() {
    // STL string
    string stl_str = "Hello";
    stl_str += ", World!"; // Safe concatenation
    cout << "STL string: " << stl_str << ", Size: " << stl_str.size() << endl; // Output: Hello, World!, Size: 12

    // C-style string
    char c_str[20] = "Hello";
    strcat(c_str, ", World!"); // Risk of buffer overflow
    cout << "C-style string: " << c_str << ", Length: " << strlen(c_str) << endl; // Output: Hello, World!, Length: 12

    // String iterator
    cout << "STL string chars: ";
    for (char c : stl_str) {
        cout << c << " ";
    }
    cout << endl; // Output: H e l l o ,   W o r l d !

    return 0;
}
```

**Explanation**:  
- STL `string` handles concatenation safely with `+=`.  
- C-style `strcat` risks overflow without bounds checking.  
- String iterators simplify traversal.

## Points to Remember (Interview Preparation)
1. **String vs. C-string**: Prefer STL `string` for safety and ease; know C-strings for legacy code.  
2. **Time Complexities**:  
   - `size()`, `at()`, `[]`: O(1).  
   - `find`, `substr`: O(n) in worst case.  
   - `+=` (concatenation): O(n) amortized.  
3. **Use Cases**: Strings for text processing (e.g., parsing, searching); vectors for raw bytes.  
4. **Safety**: Use `at()` for bounds checking in production; `[]` for performance in interviews.  
5. **Iterator Invalidation**: String resizing (e.g., `+=`) may invalidate iterators.  
6. **Interview Questions**: Be ready to manipulate strings (e.g., reverse, palindrome check) and explain trade-offs.  
7. **Common Errors**: Avoid out-of-bounds access and handle `string::npos` in `find`.