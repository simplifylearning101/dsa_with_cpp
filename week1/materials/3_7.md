# Hour 3 Additional LeetCode Problems: String Solutions

This document provides detailed solutions for four LeetCode problems recommended in `3_2.md`: **LeetCode 5: Longest Palindromic Substring**, **LeetCode 125: Valid Palindrome**, **LeetCode 344: Reverse String**, and **LeetCode 49: Group Anagrams**. Each solution includes a problem description, coding pattern, optimized solution with commented C++ code using STL strings, time and space complexity analysis, and test cases covering typical and edge cases.

## Agenda
- Provide optimized solutions for four string-based LeetCode problems.
- Explain coding patterns (e.g., Two Pointers, Hashing, Expand Around Center).
- Analyze time and space complexities.
- Include test cases to ensure robustness.

## Outcome Expected
Students will:
- Master string manipulation for palindromes, anagrams, and reversals.
- Apply Two Pointers, Hashing, and other patterns to string problems.
- Handle edge cases and optimize solutions for interviews.
- Gain confidence in solving string-based LeetCode problems.

---

## 1. LeetCode 5: Longest Palindromic Substring (Medium)

**Link**: [LeetCode 5](https://leetcode.com/problems/longest-palindromic-substring/)

**Description**:  
Given a string `s`, return the longest palindromic substring.

**Constraints**:
- `1 <= s.length <= 1000`
- `s` consists of lowercase or uppercase letters.

**Example**:
- Input: `s = "babad"`  
  Output: `"bab"`  
  Explanation: "aba" is also valid; return any longest palindrome.

**Coding Pattern**: Expand Around Center  
- Check each position as a potential center of a palindrome.
- Expand around the center for odd and even-length palindromes.
- Track the longest palindrome found.

**Optimized Solution**:
```cpp
#include <string>
using namespace std;

class Solution {
public:
    string longestPalindrome(string s) {
        int start = 0, max_len = 0;
        
        // Check each position as center
        for (int i = 0; i < s.size(); ++i) {
            // Odd-length palindrome (center at i)
            int len1 = expandAroundCenter(s, i, i);
            // Even-length palindrome (center between i and i+1)
            int len2 = expandAroundCenter(s, i, i + 1);
            int len = max(len1, len2);
            
            // Update if longer palindrome found
            if (len > max_len) {
                max_len = len;
                start = i - (len - 1) / 2;
            }
        }
        
        return s.substr(start, max_len);
    }
    
private:
    int expandAroundCenter(const string& s, int left, int right) {
        // Expand while within bounds and characters match
        while (left >= 0 && right < s.size() && s[left] == s[right]) {
            left--;
            right++;
        }
        // Return length of palindrome
        return right - left - 1;
    }
};
```

**Time Complexity**: O(n^2)  
- Each of n centers may expand up to n/2 characters: O(n * n).

**Space Complexity**: O(1)  
- Only stores start and length; output string is not counted.

**Explanation**:
- `expandAroundCenter`: Expands around `left` and `right` while characters match.
- Check both odd (single center) and even (between two positions) palindromes.
- Track the longest palindrome’s `start` and `max_len`.

**Test Cases**:
1. **Typical Case**: `s = "babad"` → Output: `"bab"` or `"aba"`  
2. **Single Character**: `s = "a"` → Output: `"a"`  
3. **All Same**: `s = "aaaa"` → Output: `"aaaa"`  
4. **No Palindrome Longer Than 1**: `s = "abc"` → Output: `"a"`  
5. **Empty String**: `s = ""` → Output: `""` (handled by constraints)  

---

## 2. LeetCode 125: Valid Palindrome (Easy)

**Link**: [LeetCode 125](https://leetcode.com/problems/valid-palindrome/)

**Description**:  
Given a string `s`, return `true` if it is a palindrome, ignoring non-alphanumeric characters and case.

**Constraints**:
- `1 <= s.length <= 2 * 10^5`
- `s` consists of printable ASCII characters.

**Example**:
- Input: `s = "A man, a plan, a canal: Panama"`  
  Output: `true`  
  Explanation: Cleaned string is "amanaplanacanalpanama", a palindrome.

**Coding Pattern**: Two Pointers  
- Use two pointers (`left`, `right`) to compare characters.
- Skip non-alphanumeric characters and convert to lowercase.

**Optimized Solution**:
```cpp
#include <string>
#include <cctype>
using namespace std;

class Solution {
public:
    bool isPalindrome(string s) {
        int left = 0, right = s.size() - 1;
        
        // Compare characters from both ends
        while (left < right) {
            // Skip non-alphanumeric from left
            while (left < right && !isalnum(s[left])) left++;
            // Skip non-alphanumeric from right
            while (left < right && !isalnum(s[right])) right--;
            
            // Compare (case-insensitive)
            if (tolower(s[left]) != tolower(s[right])) return false;
            
            left++;
            right--;
        }
        
        return true;
    }
};
```

**Time Complexity**: O(n)  
- Single pass with two pointers.

**Space Complexity**: O(1)  
- No extra space except variables.

**Explanation**:
- `isalnum`: Checks if a character is alphanumeric.
- `tolower`: Converts to lowercase for comparison.
- Skip non-alphanumeric characters to focus on valid content.

**Test Cases**:
1. **Typical Case**: `s = "A man, a plan, a canal: Panama"` → Output: `true`  
2. **Empty String**: `s = ""` → Output: `true`  
3. **Single Character**: `s = "a"` → Output: `true`  
4. **Non-Palindrome**: `s = "race a car"` → Output: `false`  
5. **Only Non-Alphanumeric**: `s = ",!:"` → Output: `true`  

---

## 3. LeetCode 344: Reverse String (Easy)

**Link**: [LeetCode 344](https://leetcode.com/problems/reverse-string/)

**Description**:  
Given a character array `s`, reverse it in-place.

**Constraints**:
- `1 <= s.length <= 10^5`
- `s[i]` is a printable ASCII character.

**Example**:
- Input: `s = ['h','e','l','l','o']`  
  Output: `['o','l','l','e','h']`

**Coding Pattern**: Two Pointers  
- Use two pointers (`left`, `right`) to swap characters from ends to middle.
- Modify in-place to meet O(1) space requirement.

**Optimized Solution**:
```cpp
#include <vector>
using namespace std;

class Solution {
public:
    void reverseString(vector<char>& s) {
        int left = 0, right = s.size() - 1;
        
        // Swap characters from ends
        while (left < right) {
            swap(s[left], s[right]);
            left++;
            right--;
        }
    }
};
```

**Time Complexity**: O(n)  
- Single pass over half the array.

**Space Complexity**: O(1)  
- In-place swapping.

**Explanation**:
- `left` starts at beginning, `right` at end.
- Swap characters and move pointers inward.
- Note: Uses `vector<char>` as input, but STL `string` could be used similarly.

**Test Cases**:
1. **Typical Case**: `s = ['h','e','l','l','o']` → Output: `['o','l','l','e','h']`  
2. **Single Character**: `s = ['a']` → Output: `['a']`  
3. **Empty Array**: `s = []` → Output: `[]` (handled by constraints)  
4. **Even Length**: `s = ['a','b','c','d']` → Output: `['d','c','b','a']`  
5. **All Same**: `s = ['a','a','a']` → Output: `['a','a','a']`  

---

## 4. LeetCode 49: Group Anagrams (Medium)

**Link**: [LeetCode 49](https://leetcode.com/problems/group-anagrams/)

**Description**:  
Given an array of strings `strs`, group the anagrams together. An anagram is a word formed by rearranging the letters of another.

**Constraints**:
- `1 <= strs.length <= 10^4`
- `0 <= strs[i].length <= 100`
- `strs[i]` consists of lowercase letters.

**Example**:
- Input: `strs = ["eat","tea","tan","ate","nat","bat"]`  
  Output: `[["bat"],["nat","tan"],["ate","eat","tea"]]`

**Coding Pattern**: Hashing with Sorted Strings  
- Sort each string to create a key for anagrams.
- Use a hash map to group strings with the same sorted key.

**Optimized Solution**:
```cpp
#include <vector>
#include <string>
#include <unordered_map>
#include <algorithm>
using namespace std;

class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        unordered_map<string, vector<string>> groups;
        
        // Group by sorted string
        for (const string& s : strs) {
            string key = s;
            sort(key.begin(), key.end());
            groups[key].push_back(s);
        }
        
        // Collect groups
        vector<vector<string>> result;
        for (auto& pair : groups) {
            result.push_back(pair.second);
        }
        
        return result;
    }
};
```

**Time Complexity**: O(n * k * log k), where n is number of strings, k is max string length  
- Sorting each string: O(k log k).
- Processing n strings: O(n * k log k).

**Space Complexity**: O(n * k)  
- Hash map stores all strings.

**Explanation**:
- Sort each string to create a unique key for anagrams.
- Group strings by sorted key in a hash map.
- Collect groups into result vector.

**Test Cases**:
1. **Typical Case**: `strs = ["eat","tea","tan","ate","nat","bat"]` → Output: `[["bat"],["nat","tan"],["ate","eat","tea"]]`  
2. **Empty Array**: `strs = []` → Output: `[]`  
3. **Single String**: `strs = ["a"]` → Output: `[["a"]]`  
4. **All Anagrams**: `strs = ["cat","act","tac"]` → Output: `[["cat","act","tac"]]`  
5. **Empty Strings**: `strs = ["",""]` → Output: `[["",""]]`  

---

## Test Case Implementation
Below is a program to test all four solutions with the provided test cases.

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <unordered_map>
#include <algorithm>
#include <cctype>
using namespace std;

// LeetCode 5: Longest Palindromic Substring
string longestPalindrome(string s) {
    int start = 0, max_len = 0;
    auto expandAroundCenter = [&](int left, int right) {
        while (left >= 0 && right < s.size() && s[left] == s[right]) {
            left--;
            right++;
        }
        return right - left - 1;
    };
    for (int i = 0; i < s.size(); ++i) {
        int len1 = expandAroundCenter(i, i);
        int len2 = expandAroundCenter(i, i + 1);
        int len = max(len1, len2);
        if (len > max_len) {
            max_len = len;
            start = i - (len - 1) / 2;
        }
    }
    return s.substr(start, max_len);
}

// LeetCode 125: Valid Palindrome
bool isPalindrome(string s) {
    int left = 0, right = s.size() - 1;
    while (left < right) {
        while (left < right && !isalnum(s[left])) left++;
        while (left < right && !isalnum(s[right])) right--;
        if (tolower(s[left]) != tolower(s[right])) return false;
        left++;
        right--;
    }
    return true;
}

// LeetCode 344: Reverse String
void reverseString(vector<char>& s) {
    int left = 0, right = s.size() - 1;
    while (left < right) {
        swap(s[left], s[right]);
        left++;
        right--;
    }
}

// LeetCode 49: Group Anagrams
vector<vector<string>> groupAnagrams(vector<string>& strs) {
    unordered_map<string, vector<string>> groups;
    for (const string& s : strs) {
        string key = s;
        sort(key.begin(), key.end());
        groups[key].push_back(s);
    }
    vector<vector<string>> result;
    for (auto& pair : groups) {
        result.push_back(pair.second);
    }
    return result;
}

// Helper function to print vector of strings
void printVector(const vector<string>& v) {
    cout << "[";
    for (size_t i = 0; i < v.size(); ++i) {
        cout << "\"" << v[i] << "\"";
        if (i < v.size() - 1) cout << ",";
    }
    cout << "]";
}

// Helper function to print vector of vector of strings
void printVectorOfVectors(const vector<vector<string>>& v) {
    cout << "[";
    for (size_t i = 0; i < v.size(); ++i) {
        printVector(v[i]);
        if (i < v.size() - 1) cout << ",";
    }
    cout << "]" << endl;
}

int main() {
    // Test LeetCode 5
    cout << "LeetCode 5: Longest Palindromic Substring\n";
    cout << "Test 1: " << longestPalindrome("babad") << endl; // bab or aba
    cout << "Test 2: " << longestPalindrome("aaaa") << endl; // aaaa

    // Test LeetCode 125
    cout << "\nLeetCode 125: Valid Palindrome\n";
    cout << "Test 1: " << (isPalindrome("A man, a plan, a canal: Panama") ? "true" : "false") << endl; // true
    cout << "Test 2: " << (isPalindrome("race a car") ? "true" : "false") << endl; // false

    // Test LeetCode 344
    cout << "\nLeetCode 344: Reverse String\n";
    vector<char> s1 = {'h', 'e', 'l', 'l', 'o'};
    reverseString(s1);
    cout << "Test 1: ";
    printVector(vector<string>(s1.begin(), s1.end())); // [o,l,l,e,h]
    cout << endl;

    // Test LeetCode 49
    cout << "\nLeetCode 49: Group Anagrams\n";
    vector<string> strs1 = {"eat", "tea", "tan", "ate", "nat", "bat"};
    cout << "Test 1: ";
    printVectorOfVectors(groupAnagrams(strs1)); // [[bat],[nat,tan],[ate,eat,tea]]

    return 0;
}
```

**Output**:
```
LeetCode 5: Longest Palindromic Substring
Test 1: bab
Test 2: aaaa

LeetCode 125: Valid Palindrome
Test 1: true
Test 2: false

LeetCode 344: Reverse String
Test 1: ["o","l","l","e","h"]

LeetCode 49: Group Anagrams
Test 1: [["bat"],["nat","tan"],["ate","eat","tea"]]
```

## Key Takeaways
- **Expand Around Center**: Used in LeetCode 5 for palindromes, leveraging string indexing.
- **Two Pointers**: Dominant in LeetCode 125 and 344 for efficient in-place operations.
- **Hashing**: LeetCode 49 uses sorted strings as keys for grouping anagrams.
- **Edge Cases**: Handle empty strings, single characters, and non-alphanumeric inputs.
- **Optimization**: Use in-place operations and efficient data structures (e.g., sets, maps) to minimize complexity.

These solutions reinforce string manipulation skills, preparing students for interview scenarios with palindrome, reversal, and anagram problems.