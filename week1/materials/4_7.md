# Hour 4 Additional LeetCode Problems: Stack Solutions

This document provides detailed solutions for four LeetCode problems recommended in `4_2.md`: **LeetCode 155: Min Stack**, **LeetCode 739: Daily Temperatures**, **LeetCode 232: Implement Queue using Stacks**, and **LeetCode 225: Implement Stack using Queues**. Each solution includes a problem description, coding pattern, optimized solution with commented C++ code using STL `stack`, time and space complexity analysis, and test cases covering typical and edge cases.

## Agenda
- Provide optimized solutions for four stack-based LeetCode problems.
- Explain coding patterns (e.g., auxiliary stack, monotonic stack, simulation).
- Analyze time and space complexities.
- Include test cases to ensure robustness.

## Outcome Expected
Students will:
- Master stack usage for advanced problems like min tracking and queue simulation.
- Apply monotonic stacks and auxiliary stacks for efficient solutions.
- Handle edge cases and optimize for interviews.
- Gain confidence in solving stack-based LeetCode problems.

---

## 1. LeetCode 155: Min Stack (Medium)

**Link**: [LeetCode 155](https://leetcode.com/problems/min-stack/)

**Description**:  
Design a stack that supports `push`, `pop`, `top`, and `getMin` (retrieve minimum element) in O(1) time.

**Constraints**:
- `-2^31 <= val <= 2^31 - 1`
- Methods called on valid stack (non-empty for `pop`, `top`, `getMin`).

**Example**:
- Input: `["MinStack","push","push","push","getMin","pop","top","getMin"]`, `[[],[-2],[0],[-3],[],[],[],[]]`  
  Output: `[null,null,null,null,-3,null,0,-2]`  
  Explanation: Min is -3 after pushes; after pop, min is -2.

**Coding Pattern**: Auxiliary Stack  
- Use two stacks: one for values, one for minimums.  
- Push to min stack when value is less than or equal to current min.

**Optimized Solution**:
```cpp
#include <stack>
using namespace std;

class MinStack {
private:
    stack<int> values; // Main stack for values
    stack<int> mins;   // Tracks minimums
public:
    void push(int val) {
        values.push(val);
        if (mins.empty() || val <= mins.top()) {
            mins.push(val); // Update min if val is smaller or equal
        }
    }
    
    void pop() {
        if (!values.empty()) {
            if (values.top() == mins.top()) {
                mins.pop(); // Remove min if top value is current min
            }
            values.pop();
        }
    }
    
    int top() {
        return values.top();
    }
    
    int getMin() {
        return mins.top();
    }
};
```

**Time Complexity**: O(1) per operation  
- All operations (`push`, `pop`, `top`, `getMin`) are O(1).

**Space Complexity**: O(n)  
- Two stacks may store up to n elements each.

**Explanation**:
- `mins` stack tracks minimums by pushing only when a new minimum is found.
- Pop removes from `mins` if the popped value equals the current minimum.
- Ensures O(1) `getMin`.

**Test Cases**:
1. **Typical Case**: `push(-2,0,-3), getMin, pop, top, getMin` → Output: `[-3,0,-2]`  
2. **Single Element**: `push(1), getMin` → Output: `[1]`  
3. **Duplicates**: `push(2,2), getMin` → Output: `[2]`  
4. **Increasing Order**: `push(1,2,3), getMin` → Output: `[1]`  
5. **Decreasing Order**: `push(3,2,1), getMin` → Output: `[1]`  

---

## 2. LeetCode 739: Daily Temperatures (Medium)

**Link**: [LeetCode 739](https://leetcode.com/problems/daily-temperatures/)

**Description**:  
Given an array of temperatures, return an array where `result[i]` is the number of days until a warmer day (or 0 if none exists).

**Constraints**:
- `1 <= temperatures.length <= 10^5`
- `30 <= temperatures[i] <= 100`

**Example**:
- Input: `temperatures = [73,74,75,71,69,72,76,73]`  
  Output: `[1,1,4,2,1,1,0,0]`  
  Explanation: Next warmer day for 73 is 1 day later (74), etc.

**Coding Pattern**: Monotonic Stack  
- Use a stack to store indices of temperatures in decreasing order.
- Pop when a warmer temperature is found, calculating days.

**Optimized Solution**:
```cpp
#include <vector>
#include <stack>
using namespace std;

class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        vector<int> result(temperatures.size(), 0);
        stack<int> s; // Store indices of decreasing temperatures
        
        // Iterate through temperatures
        for (int i = 0; i < temperatures.size(); ++i) {
            // Pop while current temp is warmer
            while (!s.empty() && temperatures[i] > temperatures[s.top()]) {
                result[s.top()] = i - s.top(); // Days until warmer
                s.pop();
            }
            s.push(i); // Push current index
        }
        
        return result;
    }
};
```

**Time Complexity**: O(n)  
- Each index is pushed and popped at most once.

**Space Complexity**: O(n)  
- Stack and result array store up to n elements.

**Explanation**:
- Stack maintains indices of temperatures in decreasing order.
- When a warmer temperature is found, pop indices and compute days.
- Unpopped indices have no warmer day (result stays 0).

**Test Cases**:
1. **Typical Case**: `[73,74,75,71,69,72,76,73]` → Output: `[1,1,4,2,1,1,0,0]`  
2. **No Warmer Days**: `[30,30,30]` → Output: `[0,0,0]`  
3. **Increasing Temps**: `[30,40,50]` → Output: `[1,1,0]`  
4. **Single Temp**: `[50]` → Output: `[0]`  
5. **Decreasing Temps**: `[50,40,30]` → Output: `[0,0,0]`  

---

## 3. LeetCode 232: Implement Queue using Stacks (Medium)

**Link**: [LeetCode 232](https://leetcode.com/problems/implement-queue-using-stacks/)

**Description**:  
Implement a queue (FIFO) using two stacks with methods `push`, `pop`, `peek`, `empty`.

**Constraints**:
- `1 <= x <= 9`
- At most 100 calls to methods.
- Calls are valid (non-empty for `pop`, `peek`).

**Example**:
- Input: `["MyQueue","push","push","peek","pop","empty"]`, `[[],[1],[2],[],[],[]]`  
  Output: `[null,null,null,1,1,false]`  
  Explanation: Queue operations using stacks.

**Coding Pattern**: Two Stacks for FIFO  
- Use one stack (`in`) for pushing, another (`out`) for popping/peeking.  
- Transfer elements from `in` to `out` when `out` is empty to maintain FIFO order.

**Optimized Solution**:
```cpp
#include <stack>
using namespace std;

class MyQueue {
private:
    stack<int> in, out; // in for push, out for pop/peek
public:
    void push(int x) {
        in.push(x); // Add to input stack
    }
    
    int pop() {
        // Transfer to out if empty
        if (out.empty()) {
            while (!in.empty()) {
                out.push(in.top());
                in.pop();
            }
        }
        int val = out.top();
        out.pop();
        return val;
    }
    
    int peek() {
        // Transfer to out if empty
        if (out.empty()) {
            while (!in.empty()) {
                out.push(in.top());
                in.pop();
            }
        }
        return out.top();
    }
    
    bool empty() {
        return in.empty() && out.empty();
    }
};
```

**Time Complexity**:  
- `push`: O(1).  
- `pop`, `peek`: O(n) amortized (transfer is O(n), but each element is transferred once).  
- `empty`: O(1).

**Space Complexity**: O(n)  
- Two stacks store up to n elements.

**Explanation**:
- `in` stack handles pushes in LIFO order.
- Transfer to `out` reverses order for FIFO popping/peeking.
- Amortized O(1) for operations due to one-time transfers.

**Test Cases**:
1. **Typical Case**: `push(1,2), peek, pop, empty` → Output: `[1,1,false]`  
2. **Single Push**: `push(1), peek` → Output: `[1]`  
3. **Empty Queue**: `empty` → Output: `[true]`  
4. **Multiple Pops**: `push(1,2), pop, pop` → Output: `[1,2]`  
5. **Push After Pop**: `push(1), pop, push(2), peek` → Output: `[1,2]`  

---

## 4. LeetCode 225: Implement Stack using Queues (Easy)

**Link**: [LeetCode 225](https://leetcode.com/problems/implement-stack-using-queues/)

**Description**:  
Implement a stack (LIFO) using two queues with methods `push`, `pop`, `top`, `empty`.

**Constraints**:
- `1 <= x <= 9`
- At most 100 calls to methods.
- Calls are valid (non-empty for `pop`, `top`).

**Example**:
- Input: `["MyStack","push","push","top","pop","empty"]`, `[[],[1],[2],[],[],[]]`  
  Output: `[null,null,null,2,2,false]`  
  Explanation: Stack operations using queues.

**Coding Pattern**: Single Queue with Rotation  
- Use one queue; rotate after each push to maintain LIFO order.  
- Push adds element and rotates queue to place it at front.

**Optimized Solution**:
```cpp
#include <queue>
using namespace std;

class MyStack {
private:
    queue<int> q; // Single queue for stack
public:
    void push(int x) {
        q.push(x);
        // Rotate queue to put new element at front
        for (int i = 0; i < q.size() - 1; ++i) {
            q.push(q.front());
            q.pop();
        }
    }
    
    int pop() {
        int val = q.front();
        q.pop();
        return val;
    }
    
    int top() {
        return q.front();
    }
    
    bool empty() {
        return q.empty();
    }
};
```

**Time Complexity**:  
- `push`: O(n) (due to rotation).  
- `pop`, `top`, `empty`: O(1).

**Space Complexity**: O(n)  
- Queue stores up to n elements.

**Explanation**:
- `push`: Adds element and rotates queue to place it at front (LIFO order).
- `pop` and `top`: Access front of queue (O(1)).
- Single queue simplifies implementation compared to two queues.

**Test Cases**:
1. **Typical Case**: `push(1,2), top, pop, empty` → Output: `[2,2,false]`  
2. **Single Push**: `push(1), top` → Output: `[1]`  
3. **Empty Stack**: `empty` → Output: `[true]`  
4. **Multiple Pops**: `push(1,2), pop, pop` → Output: `[2,1]`  
5. **Push After Pop**: `push(1), pop, push(2), top` → Output: `[1,2]`  

---

## Test Case Implementation
Below is a program to test all four solutions with the provided test cases.

```cpp
#include <iostream>
#include <vector>
#include <stack>
#include <queue>
using namespace std;

// LeetCode 155: Min Stack
class MinStack {
private:
    stack<int> values, mins;
public:
    void push(int val) {
        values.push(val);
        if (mins.empty() || val <= mins.top()) mins.push(val);
    }
    void pop() {
        if (!values.empty()) {
            if (values.top() == mins.top()) mins.pop();
            values.pop();
        }
    }
    int top() { return values.top(); }
    int getMin() { return mins.top(); }
};

// LeetCode 739: Daily Temperatures
vector<int> dailyTemperatures(vector<int>& temperatures) {
    vector<int> result(temperatures.size(), 0);
    stack<int> s;
    for (int i = 0; i < temperatures.size(); ++i) {
        while (!s.empty() && temperatures[i] > temperatures[s.top()]) {
            result[s.top()] = i - s.top();
            s.pop();
        }
        s.push(i);
    }
    return result;
}

// LeetCode 232: Implement Queue using Stacks
class MyQueue {
private:
    stack<int> in, out;
public:
    void push(int x) { in.push(x); }
    int pop() {
        if (out.empty()) {
            while (!in.empty()) {
                out.push(in.top());
                in.pop();
            }
        }
        int val = out.top();
        out.pop();
        return val;
    }
    int peek() {
        if (out.empty()) {
            while (!in.empty()) {
                out.push(in.top());
                in.pop();
            }
        }
        return out.top();
    }
    bool empty() { return in.empty() && out.empty(); }
};

// LeetCode 225: Implement Stack using Queues
class MyStack {
private:
    queue<int> q;
public:
    void push(int x) {
        q.push(x);
        for (int i = 0; i < q.size() - 1; ++i) {
            q.push(q.front());
            q.pop();
        }
    }
    int pop() {
        int val = q.front();
        q.pop();
        return val;
    }
    int top() { return q.front(); }
    bool empty() { return q.empty(); }
};

// Helper function to print vector
void printVector(const vector<int>& v) {
    cout << "[";
    for (size_t i = 0; i < v.size(); ++i) {
        cout << v[i];
        if (i < v.size() - 1) cout << ",";
    }
    cout << "]" << endl;
}

int main() {
    // Test LeetCode 155
    cout << "LeetCode 155: Min Stack\n";
    MinStack ms;
    ms.push(-2); ms.push(0); ms.push(-3);
    cout << "Test 1: getMin = " << ms.getMin() << ", top = " << ms.top() << endl; // -3, -3
    ms.pop();
    cout << "After pop, top = " << ms.top() << ", getMin = " << ms.getMin() << endl; // 0, -2

    // Test LeetCode 739
    cout << "\nLeetCode 739: Daily Temperatures\n";
    vector<int> temps = {73, 74, 75, 71, 69, 72, 76, 73};
    cout << "Test 1: ";
    printVector(dailyTemperatures(temps)); // [1,1,4,2,1,1,0,0]

    // Test LeetCode 232
    cout << "\nLeetCode 232: Implement Queue using Stacks\n";
    MyQueue q;
    q.push(1); q.push(2);
    cout << "Test 1: peek = " << q.peek() << ", pop = " << q.pop() << ", empty = " << (q.empty() ? "true" : "false") << endl; // 1, 1, false

    // Test LeetCode 225
    cout << "\nLeetCode 225: Implement Stack using Queues\n";
    MyStack s;
    s.push(1); s.push(2);
    cout << "Test 1: top = " << s.top() << ", pop = " << s.pop() << ", empty = " << (s.empty() ? "true" : "false") << endl; // 2, 2, false

    return 0;
}
```

**Output**:
```
LeetCode 155: Min Stack
Test 1: getMin = -3, top = -3
After pop, top = 0, getMin = -2

LeetCode 739: Daily Temperatures
Test 1: [1,1,4,2,1,1,0,0]

LeetCode 232: Implement Queue using Stacks
Test 1: peek = 1, pop = 1, empty = false

LeetCode 225: Implement Stack using Queues
Test 1: top = 2, pop = 2, empty = false
```

## Key Takeaways
- **Auxiliary Stack**: LeetCode 155 uses a second stack to track minimums efficiently.
- **Monotonic Stack**: LeetCode 739 leverages a stack for next greater elements.
- **Simulation**: LeetCode 232 and 225 simulate queue/stack using opposite structures.
- **Edge Cases**: Handle empty stacks, single elements, and large inputs.
- **Optimization**: Use O(1) operations where possible; amortize costs for queue simulation.

These solutions reinforce stack manipulation skills, preparing students for interview scenarios with advanced stack applications.