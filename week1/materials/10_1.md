# Hour 10: Unordered Set and Unordered Multiset in STL

**Agenda**: Introduce students to C++ STL `unordered_set` and `unordered_multiset`, building on their understanding of vectors (Hour 1), arrays/deques (Hour 2), strings (Hour 3), stacks (Hour 4), queues (Hour 5), priority queues (Hour 6), sets (Hour 7), maps (Hour 8), and multisets/multimaps (Hour 9). Use real-world analogies and fully commented programs to simplify concepts. Emphasize practical usage, operations, and preparation for coding interviews.

**Outcome Expected**:  
By the end of this hour, students will:  
- Understand STL `unordered_set` (hash-based container for unique elements) and `unordered_multiset` (hash-based, allows duplicates).  
- Master operations like `insert`, `erase`, `find`, `count`.  
- Compare `unordered_set` with `set` and `unordered_multiset` with `multiset`.  
- Write C++ programs using unordered sets and multisets with proper syntax.  
- Be ready to solve LeetCode problems involving fast lookups and membership testing.

## Topics Covered
1. **STL Unordered Set: Hash-Based Container for Unique Elements**  
   - Declaration, initialization, and basic operations.  
   - Underlying structure: Hash table.  
   - Real-world analogy: Unordered set as a guest list with unique names.  
2. **STL Unordered Multiset: Hash-Based Container with Duplicates**  
   - Declaration, initialization, and operations.  
   - Underlying structure: Hash table.  
   - Real-world analogy: Unordered multiset as a log of repeated attendance entries.  
3. **Unordered Set and Multiset Operations**  
   - `insert`, `erase`, `find`, `count`, `size`, `empty`, `clear`.  
   - Iterating over unordered sets and multisets.  
4. **Comparison with Set and Multiset**  
   - Unordered set vs. set (unordered vs. sorted, O(1) vs. O(log n)).  
   - Unordered multiset vs. multiset (duplicates with hashing vs. sorting).  

## Detailed Explanation of Topics Covered

### 1. STL Unordered Set: Hash-Based Container for Unique Elements
The STL `unordered_set` is a container that stores unique elements using a hash table, providing O(1) average-case complexity for operations. Think of an `unordered_set` as a guest list where each name appears once, with fast lookup.

**Key Features**:  
- **Declaration**: `unordered_set<T> us;` (e.g., `unordered_set<int>` for IDs).  
- **Initialization**: Insert elements, duplicates ignored.  
- **Operations**: `insert`, `erase`, `find`, `count`, `size`, `empty`, `clear`.  
- **Advantages**: O(1) average for insert/erase/find; fast membership testing.  
- **Limitations**: Unordered elements; requires hashable types.

**Example Program**: Basic unordered set operations.

```cpp
#include <iostream>
#include <unordered_set>
using namespace std;

int main() {
    // Declare unordered_set
    unordered_set<int> guests;

    // Insert elements (duplicates ignored)
    guests.insert(101); // O(1) average
    guests.insert(102);
    guests.insert(101); // Duplicate ignored
    guests.insert(103);

    // Print size
    cout << "Size: " << guests.size() << endl; // Output: 3

    // Print elements (order not guaranteed)
    cout << "Guests: ";
    for (const int& id : guests) {
        cout << id << " "; // Example output: 103 101 102
    }
    cout << endl;

    // Check if element exists
    cout << "Find 101: " << (guests.find(101) != guests.end() ? "Found" : "Not found") << endl; // Output: Found

    // Count occurrences
    cout << "Count of 101: " << guests.count(101) << endl; // Output: 1 (unique elements)

    // Erase element
    guests.erase(101);
    cout << "After erasing 101, size: " << guests.size() << endl; // Output: 2

    return 0;
}
```

**Explanation**:  
- `#include <unordered_set>`: Imports the unordered set library.  
- `insert`: Adds elements, ignores duplicates (O(1) average).  
- `find`: Returns iterator to element or `end()` (O(1) average).  
- `count`: Returns 0 or 1 for presence (O(1) average).  
- Elements are unordered due to hashing.

### 2. STL Unordered Multiset: Hash-Based Container with Duplicates
The STL `unordered_multiset` stores elements in a hash table, allowing duplicates, with O(1) average-case complexity. Think of it as a log of attendance entries where the same person can appear multiple times.

**Key Features**:  
- **Declaration**: `unordered_multiset<T> ums;` (e.g., `unordered_multiset<int>`).  
- **Operations**: `insert`, `erase`, `find`, `count`, `size`, `empty`, `clear`.  
- **Advantages**: O(1) average for operations; supports duplicates.  
- **Limitations**: Unordered; no random access.

**Example Program**: Unordered multiset operations.

```cpp
#include <iostream>
#include <unordered_set>
using namespace std;

int main() {
    // Declare unordered_multiset
    unordered_multiset<int> log;

    // Insert elements (duplicates allowed)
    log.insert(101); // O(1) average
    log.insert(102);
    log.insert(101); // Duplicate inserted
    log.insert(103);

    // Print size
    cout << "Size: " << log.size() << endl; // Output: 4

    // Print elements (order not guaranteed)
    cout << "Log: ";
    for (const int& entry : log) {
        cout << entry << " "; // Example output: 101 101 102 103
    }
    cout << endl;

    // Count occurrences
    cout << "Count of 101: " << log.count(101) << endl; // Output: 2

    // Find first occurrence
    auto it = log.find(101);
    cout << "Find 101: " << (it != log.end() ? to_string(*it) : "Not found") << endl; // Output: 101

    // Erase one occurrence
    log.erase(log.find(101)); // Erases one 101
    cout << "After erasing one 101, size: " << log.size() << endl; // Output: 3

    return 0;
}
```

**Explanation**:  
- `#include <unordered_set>`: Imports `unordered_multiset`.  
- `count(value)`: Returns number of occurrences (O(1) average).  
- `erase(iterator)`: Removes one occurrence; `erase(value)` removes all.

### 3. Unordered Set and Multiset Operations
Both `unordered_set` and `unordered_multiset` support operations for managing elements with O(1) average-case complexity.

**Key Operations**:  
- `insert(value)`: Adds element (O(1) average).  
- `erase(iterator)` or `erase(value)`: Removes element(s).  
- `find(value)`: Returns iterator to first occurrence or `end()`.  
- `count(value)`: Returns number of occurrences (0 or 1 for `unordered_set`).  
- `size()`: Number of elements.  
- `empty()`: Checks if container is empty.  
- `clear()`: Removes all elements.

**Example Program**: Comparing unordered set and multiset.

```cpp
#include <iostream>
#include <unordered_set>
using namespace std;

int main() {
    // Unordered set
    unordered_set<int> us;
    us.insert(10); us.insert(10); us.insert(20);
    cout << "Unordered set: ";
    for (const int& x : us) {
        cout << x << " "; // Example output: 20 10
    }
    cout << endl;
    cout << "Count of 10: " << us.count(10) << endl; // Output: 1

    // Unordered multiset
    unordered_multiset<int> ums;
    ums.insert(10); ums.insert(10); ums.insert(20);
    cout << "Unordered multiset: ";
    for (const int& x : ums) {
        cout << x << " "; // Example output: 10 10 20
    }
    cout << endl;
    cout << "Count of 10: " << ums.count(10) << endl; // Output: 2

    return 0;
}
```

**Explanation**:  
- `unordered_set` ignores duplicates; `unordered_multiset` allows them.  
- Order of elements is not guaranteed.

### 4. Comparison with Set and Multiset
- **Unordered Set vs. Set**: `unordered_set` uses hash table (O(1) average); `set` uses red-black tree (O(log n), sorted).  
- **Unordered Multiset vs. Multiset**: `unordered_multiset` allows duplicates with hashing; `multiset` sorts duplicates.

**Example Program**: Unordered set vs. set.

```cpp
#include <iostream>
#include <set>
#include <unordered_set>
using namespace std;

int main() {
    // Unordered set
    unordered_set<int> us;
    us.insert(10); us.insert(10); us.insert(20);
    cout << "Unordered set size: " << us.size() << endl; // Output: 2
    cout << "Unordered set: ";
    for (const int& x : us) {
        cout << x << " "; // Example output: 20 10
    }
    cout << endl;

    // Set
    set<int> s;
    s.insert(10); s.insert(10); s.insert(20);
    cout << "Set size: " << s.size() << endl; // Output: 2
    cout << "Set: ";
    for (const int& x : s) {
        cout << x << " "; // Output: 10 20
    }
    cout << endl;

    return 0;
}
```

**Explanation**:  
- `unordered_set`: Unordered, O(1) average.  
- `set`: Sorted, O(log n).

## Points to Remember (Interview Preparation)
1. **Unordered Set**: Hash-based, unique elements, O(1) average operations.  
2. **Unordered Multiset**: Hash-based, allows duplicates, O(1) average operations.  
3. **Time Complexities**:  
   - `insert`, `erase`, `find`, `count`: O(1) average, O(n) worst case (hash collisions).  
4. **Use Cases**: `unordered_set` for fast membership testing; `unordered_multiset` for frequency counting with duplicates.  
5. **Safety**: Check `find` results against `end()`; handle hash collisions.  
6. **Interview Questions**: Be ready for problems like checking duplicates or intersections.  
7. **Common Errors**: Avoid assuming sorted order; ensure types are hashable.