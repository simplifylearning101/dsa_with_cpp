# Quiz: Two-Pointer and Sliding Window for Strings

30 questions: 20 on two-pointer and sliding window for strings, 5 on string basics (Week 3, Hour 1), 5 on advanced array techniques (Week 2, Hour 3).

1. What is the sliding window technique for strings?  
2. How does two-pointer differ for strings vs. arrays?  
3. Write code for longest substring with at most k distinct characters.  
4. What is the time complexity of sliding window for substring problems?  
5. Write code to find all anagrams in a string.  
6. How does frequency array optimize anagram checks?  
7. Write code to reverse words in a string.  
8. What is the minimum window substring problem?  
9. Write code for minimum window substring.  
10. True/False: Sliding window always uses O(1) space for strings.  
11. How to handle non-alphanumeric characters in palindrome checks?  
12. Write code for valid palindrome ignoring non-alphanumeric.  
13. What is the longest repeating character replacement problem?  
14. Write code for longest repeating character replacement.  
15. How to group anagrams efficiently?  
16. Write code to group anagrams.  
17. True/False: Two-pointer can solve substring pattern matching.  
18. Write code to check repeated substring pattern.  
19. What is the longest substring without repeating characters?  
20. Write code for longest substring without repeating characters.  
21. (String Basics) How to check if two strings are anagrams?  
22. (String Basics) Write code to convert a string to lowercase.  
23. (String Basics) What does std::string::find return if not found?  
24. (String Basics) Write code for longest common prefix.  
25. (String Basics) How to remove a character from a string?  
26. (Advanced Arrays) What is Kadaneâ€™s algorithm used for?  
27. (Advanced Arrays) Write code for smallest subarray with sum >= k.  
28. (Advanced Arrays) How does prefix sum optimize range queries?  
29. (Advanced Arrays) Write code for subarrays with sum = k.  
30. (Advanced Arrays) Time complexity of max product subarray?

## Solutions for the Quiz

1. Uses two pointers to maintain a dynamic window for substring problems.  
2. Strings use char access; arrays use numeric indices, but logic is similar.  
3. 
   ```cpp
   int lengthOfLongestSubstringKDistinct(std::string s, int k) {
       std::unordered_map<char, int> map;
       int left = 0, maxLen = 0;
       for (int right = 0; right < s.size(); right++) {
           map[s[right]]++;
           while (map.size() > k) {
               map[s[left]]--;
               if (map[s[left]] == 0) map.erase(s[left]);
               left++;
           }
           maxLen = std::max(maxLen, right - left + 1);
       }
       return maxLen;
   }
   ```
4. O(n) for most sliding window problems.  
5. 
   ```cpp
   std::vector<int> findAnagrams(std::string s, std::string p) {
       std::vector<int> result;
       if (p.size() > s.size()) return result;
       int count[26] = {0}, window[26] = {0};
       for (char c : p) count[c - 'a']++;
       for (int i = 0; i < p.size(); i++) window[s[i] - 'a']++;
       if (std::equal(count, count + 26, window)) result.push_back(0);
       for (int i = p.size(); i < s.size(); i++) {
           window[s[i] - 'a']++;
           window[s[i - p.size()] - 'a']--;
           if (std::equal(count, count + 26, window)) result.push_back(i - p.size() + 1);
       }
       return result;
   }
   ```
6. O(1) space for fixed character sets (e.g., lowercase letters).  
7. 
   ```cpp
   std::string reverseWords(std::string s) {
       int n = s.length(), start = 0;
       for (int i = 0; i <= n; i++) {
           if (i == n || s[i] == ' ') {
               int left = start, right = i - 1;
               while (left < right) std::swap(s[left++], s[right--]);
               start = i + 1;
           }
       }
       return s;
   }
   ```
8. Find smallest substring containing all characters of another string.  
9. 
   ```cpp
   std::string minWindow(std::string s, std::string t) {
       std::unordered_map<char, int> tMap, sMap;
       for (char c : t) tMap[c]++;
       int required = tMap.size(), formed = 0, left = 0, minLen = s.size() + 1, minLeft = 0;
       for (int right = 0; right < s.size(); right++) {
           sMap[s[right]]++;
           if (tMap.count(s[right]) && sMap[s[right]] == tMap[s[right]]) formed++;
           while (formed == required && left <= right) {
               if (right - left + 1 < minLen) {
                   minLen = right - left + 1;
                   minLeft = left;
               }
               sMap[s[left]]--;
               if (tMap.count(s[left]) && sMap[s[left]] < tMap[s[left]]) formed--;
               left++;
           }
       }
       return minLen > s.size() ? "" : s.substr(minLeft, minLen);
   }
   ```
10. False, may use O(k) for hash maps.  
11. Skip non-alphanumeric characters using isalnum().  
12. 
   ```cpp
   bool isValidPalindrome(std::string s) {
       int left = 0, right = s.length() - 1;
       while (left < right) {
           while (left < right && !isalnum(s[left])) left++;
           while (left < right && !isalnum(s[right])) right--;
           if (tolower(s[left++]) != tolower(s[right--])) return false;
       }
       return true;
   }
   ```
13. Find longest substring with k replacements to make all characters same.  
14. 
   ```cpp
   int characterReplacement(std::string s, int k) {
       int count[26] = {0}, maxCount = 0, left = 0, maxLen = 0;
       for (int right = 0; right < s.size(); right++) {
           maxCount = std::max(maxCount, ++count[s[right] - 'A']);
           while (right - left + 1 - maxCount > k) {
               count[s[left] - 'A']--;
               left++;
           }
           maxLen = std::max(maxLen, right - left + 1);
       }
       return maxLen;
   }
   ```
15. Sort strings or use frequency array as key in hash map.  
16. 
   ```cpp
   std::vector<std::vector<std::string>> groupAnagrams(std::vector<std::string>& strs) {
       std::unordered_map<std::string, std::vector<std::string>> map;
       for (std::string s : strs) {
           std::string key = s;
           std::sort(key.begin(), key.end());
           map[key].push_back(s);
       }
       std::vector<std::vector<std::string>> result;
       for (auto& pair : map) result.push_back(pair.second);
       return result;
   }
   ```
17. True, e.g., repeated substring pattern.  
18. 
   ```cpp
   bool repeatedSubstringPattern(std::string s) {
       int n = s.length();
       for (int len = 1; len <= n / 2; len++) {
           if (n % len == 0) {
               std::string pattern = s.substr(0, len);
               bool valid = true;
               for (int i = len; i < n; i += len) {
                   if (s.substr(i, len) != pattern) {
                       valid = false;
                       break;
                   }
               }
               if (valid) return true;
           }
       }
       return false;
   }
   ```
19. Find longest substring with unique characters.  
20. 
   ```cpp
   int lengthOfLongestSubstring(std::string s) {
       std::unordered_map<char, int> map;
       int left = 0, maxLen = 0;
       for (int right = 0; right < s.size(); right++) {
           if (map.find(s[right]) != map.end() && map[s[right]] >= left) {
               left = map[s[right]] + 1;
           }
           map[s[right]] = right;
           maxLen = std::max(maxLen, right - left + 1);
       }
       return maxLen;
   }
   ```
21. Sort or use frequency array.  
22. 
   ```cpp
   std::string toLowerCase(std::string s) {
       for (char& c : s) {
           if (c >= 'A' && c <= 'Z') c += 32;
       }
       return s;
   }
   ```
23. std::string::npos.  
24. 
   ```cpp
   std::string longestCommonPrefix(std::vector<std::string>& strs) {
       if (strs.empty()) return "";
       std::string prefix = strs[0];
       for (int i = 1; i < strs.size(); i++) {
           while (strs[i].find(prefix) != 0) {
               prefix = prefix.substr(0, prefix.length() - 1);
               if (prefix.empty()) return "";
           }
       }
       return prefix;
   }
   ```
25. Filter characters with two-pointer or new string.  
26. Maximum subarray sum.  
27. 
   ```cpp
   int smallestSubarray(int arr[], int n, int k) {
       int sum = 0, minLen = n + 1, left = 0;
       for (int right = 0; right < n; right++) {
           sum += arr[right];
           while (sum >= k && left <= right) {
               minLen = std::min(minLen, right - left + 1);
               sum -= arr[left++];
           }
       }
       return minLen > n ? -1 : minLen;
   }
   ```
28. Precomputes sums for O(1) queries.  
29. 
   ```cpp
   int subarraySum(int arr[], int n, int k) {
       std::unordered_map<int, int> map;
       map[0] = 1;
       int sum = 0, count = 0;
       for (int i = 0; i < n; i++) {
           sum += arr[i];
           if (map.find(sum - k) != map.end()) count += map[sum - k];
           map[sum]++;
       }
       return count;
   }
   ```
30. O(n).