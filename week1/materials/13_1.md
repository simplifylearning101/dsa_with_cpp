# Hour 13: Advanced STL Algorithms and Function Objects

**Agenda**: Introduce students to advanced STL algorithms and function objects (functors) for manipulating containers from Hours 1–11. Use real-world analogies and fully commented programs to simplify concepts. Emphasize practical usage, custom operations, and coding interview preparation.

**Outcome Expected**:  
By the end of this hour, students will:  
- Understand advanced STL algorithms like `for_each`, `transform`, `remove_if`, `partition`.  
- Master function objects and lambda expressions.  
- Apply algorithms and functors to containers (e.g., vectors, sets, maps).  
- Understand iterator invalidation and algorithm constraints.  
- Write C++ programs combining advanced algorithms and containers.  
- Be prepared to solve LeetCode problems using these tools.

## Topics Covered
1. **Advanced STL Algorithms**  
   - Overview of `<algorithm>` library extensions.  
   - Algorithms: `for_each`, `transform`, `remove_if`, `partition`.  
   - Real-world analogy: Algorithms as automated library workers.  
2. **Function Objects and Lambdas**  
   - Functors: Classes with `operator()`.  
   - Lambda expressions for inline functions.  
   - Predefined functors (e.g., `std::plus`, `std::greater`).  
3. **Applying Algorithms to Containers**  
   - Using algorithms with vectors, sets, maps, etc.  
   - Custom predicates and operations.  
4. **Iterator Invalidation and Constraints**  
   - When iterators become invalid.  
   - Algorithm requirements (e.g., iterator types).  

## Detailed Explanation of Topics Covered

### 1. Advanced STL Algorithms
The STL `<algorithm>` library includes powerful algorithms for modifying and processing containers. Advanced algorithms like `for_each`, `transform`, `remove_if`, and `partition` enable complex operations.

**Key Algorithms**:  
- `for_each(begin, end, func)`: O(n) – Applies function to each element.  
- `transform(begin, end, dest, func)`: O(n) – Applies function and stores results.  
- `remove_if(begin, end, pred)`: O(n) – Moves elements satisfying predicate to end.  
- `partition(begin, end, pred)`: O(n) – Partitions range based on predicate.

**Example Program**: Basic usage of advanced algorithms.

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    vector<int> v = {1, 2, 3, 4, 5};
    
    // for_each: Print elements
    for_each(v.begin(), v.end(), [](int x) { cout << x << " "; });
    cout << endl;  // Output: 1 2 3 4 5
    
    // transform: Double elements
    vector<int> result(v.size());
    transform(v.begin(), v.end(), result.begin(), [](int x) { return x * 2; });
    cout << "Doubled: ";
    for (int x : result) cout << x << " ";  // Output: 2 4 6 8 10
    cout << endl;
    
    // remove_if: Remove odd numbers
    auto new_end = remove_if(v.begin(), v.end(), [](int x) { return x % 2 == 1; });
    cout << "After removing odds: ";
    for (auto it = v.begin(); it != new_end; ++it) cout << *it << " ";  // Output: 2 4
    cout << endl;
    
    return 0;
}
```

**Explanation**:  
- `for_each`: Applies lambda to each element.  
- `transform`: Modifies elements, stores in `result`.  
- `remove_if`: Shifts elements (does not erase; use `erase` for actual removal).

### 2. Function Objects and Lambdas
Function objects (functors) are classes with `operator()`. Lambdas provide inline function definitions, and STL offers predefined functors (e.g., `std::plus`).

**Key Concepts**:  
- **Functor**: Struct/class with `operator()`.  
- **Lambda**: `[capture](params){body}` for inline functions.  
- **Predefined Functors**: `<functional>` (e.g., `std::plus`, `std::greater`).

**Example Program**: Functor and lambda usage.

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <functional>
using namespace std;

struct Square {
    int operator()(int x) const { return x * x; }
};

int main() {
    vector<int> v = {1, 2, 3};
    
    // Functor
    Square sq;
    transform(v.begin(), v.end(), v.begin(), sq);  // v = [1, 4, 9]
    cout << "Squared (functor): ";
    for (int x : v) cout << x << " ";  // Output: 1 4 9
    cout << endl;
    
    // Lambda
    transform(v.begin(), v.end(), v.begin(), [](int x) { return x + 1; });  // v = [2, 5, 10]
    cout << "Incremented (lambda): ";
    for (int x : v) cout << x << " ";  // Output: 2 5 10
    cout << endl;
    
    // Predefined functor
    vector<int> v2 = {1, 2};
    transform(v.begin(), v.end(), v2.begin(), v.begin(), plus<int>());
    cout << "Sum with v2: ";
    for (int x : v) cout << x << " ";  // Output: 3 7 10
    cout << endl;
    
    return 0;
}
```

**Explanation**:  
- `Square`: Functor for squaring.  
- Lambda: Inline function for increment.  
- `plus<int>`: Combines two ranges.

### 3. Applying Algorithms to Containers
Advanced algorithms work with all containers supporting iterators.

**Example Program**: Algorithms with set and map.

```cpp
#include <iostream>
#include <set>
#include <map>
#include <algorithm>
using namespace std;

int main() {
    // Set: Count multiples of 3
    set<int> s = {1, 3, 6, 9};
    int count = count_if(s.begin(), s.end(), [](int x) { return x % 3 == 0; });
    cout << "Multiples of 3: " << count << endl;  // Output: 3
    
    // Map: Transform values
    map<string, int> m = {{"a", 1}, {"b", 2}};
    vector<int> values(m.size());
    transform(m.begin(), m.end(), values.begin(), 
              [](const auto& p) { return p.second * 2; });
    cout << "Doubled map values: ";
    for (int x : values) cout << x << " ";  // Output: 2 4
    cout << endl;
    
    return 0;
}
```

**Explanation**:  
- `count_if` works with set’s bidirectional iterators.  
- `transform` extracts and modifies map values.

### 4. Iterator Invalidation and Constraints
- **Invalidation**: Modifying containers (e.g., `vector::push_back`) may invalidate iterators.  
- **Constraints**: `remove_if` requires forward iterators; `partition` requires bidirectional iterators.

**Example Program**: Safe iterator usage.

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    vector<int> v = {1, 2, 3, 4};
    auto new_end = remove_if(v.begin(), v.end(), [](int x) { return x % 2 == 0; });
    v.erase(new_end, v.end());  // Actually remove elements
    cout << "After removing evens: ";
    for (int x : v) cout << x << " ";  // Output: 1 3
    cout << endl;
    
    return 0;
}
```

**Explanation**:  
- `remove_if` shifts elements; `erase` removes them.  
- Avoids iterator invalidation by using `new_end`.

## Points to Remember (Interview Preparation)
1. **Headers**: `<algorithm>` for algorithms, `<functional>` for functors.  
2. **Iterators**: Check invalidation after modifications.  
3. **Time Complexities**: Most algorithms are O(n).  
4. **Use Cases**: `for_each` for side effects, `transform` for modifications, `remove_if` for filtering.  
5. **Common Errors**: Forgetting `erase` after `remove_if`; invalid iterator usage.  
6. **Interview Questions**: Be ready for problems like duplicate detection, array transformations.