# Deep Dive into C++ STL Sets

This document is an advanced exploration of STL `set` and `unordered_set` for students aiming to master set-based algorithms for coding interviews. It covers internals, advanced applications, and interview questions with detailed answers, building on Hours 1–6 (vectors, arrays/deques, strings, stacks, queues, priority queues).

## Agenda
- Deep dive into set and unordered set internals, operations, and optimizations.
- Illustrate complex scenarios with commented programs.
- Prepare for interviews with challenging questions and answers.

## Outcome Expected
Students will:
- Understand `set` (red-black tree) and `unordered_set` (hash table) internals.  
- Master advanced applications (e.g., intersection, duplicate detection, unique element tracking).  
- Optimize performance and handle edge cases.  
- Answer complex set-related interview questions confidently.

## Topics Covered
1. **Set Internals**  
   - Red-black tree structure and balancing.  
   - Performance characteristics (O(log n)).  
   - Real-world analogy: Set as a library catalog.  
2. **Unordered Set Internals**  
   - Hash table structure and collision handling.  
   - Performance characteristics (O(1) average).  
   - Real-world analogy: Unordered set as a quick lookup database.  
3. **Advanced Applications**  
   - Intersection and union of arrays.  
   - Duplicate detection and unique element problems.  
4. **Optimization and Pitfalls**  
   - Choosing `set` vs. `unordered_set`.  
   - Handling hash collisions and large datasets.  

## Detailed Explanation

### 1. Set Internals
STL `set` is implemented as a red-black tree, a self-balancing binary search tree that ensures O(log n) operations for insertion, deletion, and search. Think of it as a library catalog where books are sorted by title, and duplicates are not allowed.

- **Structure**: Nodes with parent-child links, balanced to ensure O(log n).  
- **Performance**: O(log n) for `insert`, `erase`, `find`.  
- **Limitations**: No random access; sorted order required.

**Example Program**: Set with custom comparator.

```cpp
#include <iostream>
#include <set>
using namespace std;

struct Compare {
    bool operator()(const string& a, const string& b) const {
        return a.length() < b.length(); // Sort by string length
    }
};

int main() {
    set<string, Compare> s;
    
    // Insert strings
    s.insert("cat"); s.insert("elephant"); s.insert("dog");
    
    // Print in order of length
    cout << "Strings: ";
    for (const string& x : s) {
        cout << x << " "; // Output: cat dog elephant
    }
    cout << endl;
    
    return 0;
}
```

**Explanation**:  
- Custom comparator sorts by string length.  
- Red-black tree maintains order based on comparator.

### 2. Unordered Set Internals
STL `unordered_set` uses a hash table, mapping elements to buckets via a hash function. Think of it as a quick lookup database where membership is checked instantly, but order is not preserved.

- **Structure**: Buckets with linked lists for collision resolution.  
- **Performance**: O(1) average for `insert`, `erase`, `find`; O(n) worst case for collisions.  
- **Limitations**: No sorting; potential hash collision issues.

**Example Program**: Unordered set with custom hash.

```cpp
#include <iostream>
#include <unordered_set>
#include <string>
using namespace std;

struct CustomHash {
    size_t operator()(const string& s) const {
        return s.length(); // Simple hash based on length
    }
};

int main() {
    unordered_set<string, CustomHash> us;
    us.insert("cat"); us.insert("dog"); us.insert("bird");
    
    // Print elements (order not guaranteed)
    cout << "Elements: ";
    for (const string& x : us) {
        cout << x << " "; // Output: e.g., cat dog bird
    }
    cout << endl;
    
    // Check membership
    cout << "Is 'cat' present? " << (us.count("cat") ? "Yes" : "No") << endl; // Output: Yes
    
    return 0;
}
```

**Explanation**:  
- Custom hash function uses string length (simplified for demonstration).  
- O(1) average time for operations, but poor hash functions cause collisions.

### 3. Advanced Applications
Sets are ideal for problems involving unique elements, intersections, or sorted data, such as finding common elements or detecting duplicates.

**Example Program**: Intersection of two arrays.

```cpp
#include <iostream>
#include <set>
#include <vector>
using namespace std;

vector<int> intersection(const vector<int>& nums1, const vector<int>& nums2) {
    set<int> s(nums1.begin(), nums1.end());
    vector<int> result;
    for (int num : nums2) {
        if (s.count(num)) {
            result.push_back(num);
            s.erase(num); // Avoid duplicates
        }
    }
    return result;
}

int main() {
    vector<int> nums1 = {1, 2, 2, 1};
    vector<int> nums2 = {2, 2};
    vector<int> result = intersection(nums1, nums2);
    for (int x : result) {
        cout << x << " "; // Output: 2
    }
    cout << endl;
    return 0;
}
```

**Explanation**:  
- Convert first array to `set` for O(log n) lookups.  
- Check second array elements against set, erasing to avoid duplicates.

### 4. Optimization and Pitfalls
- **Optimization**: Use `unordered_set` for faster lookups when order isn’t needed.  
- **Pitfalls**: Avoid `unordered_set` with poor hash functions; check `find` results against `end()`.

**Example Program**: Safe set operations.

```cpp
#include <iostream>
#include <set>
using namespace std;

int main() {
    set<int> s;
    s.insert(1); s.insert(2);
    
    // Safe find
    int key = 3;
    auto it = s.find(key);
    cout << key << ": " << (it != s.end() ? "Found" : "Not found") << endl; // Output: Not found
    
    // Safe erase
    if (s.count(1)) {
        s.erase(1);
        cout << "Erased 1, size: " << s.size() << endl; // Output: 1
    }
    
    return 0;
}
```

**Explanation**:  
- Check `find` result against `end()` to avoid invalid iterator access.  
- Use `count` before `erase` for safety.

## Interview Questions and Answers
Below are 15 advanced interview questions on sets.

1. **Question**: What is the primary difference between `set` and `unordered_set`?  
   **Answer**: `set` is sorted (O(log n), red-black tree); `unordered_set` is unordered (O(1) average, hash table).  
   **Interviewer’s Intention**: Tests container understanding.

2. **Question**: Why use a red-black tree for `set`?**  
   **Answer**: Ensures O(log n) operations and sorted order.  
   **Interviewer’s Intention**: Checks internal structure knowledge.

3. **Question**: What is the time complexity of `unordered_set::find`?**  
   **Answer**: O(1) average, O(n) worst case for collisions.  
   **Interviewer’s Intention**: Tests performance awareness.

4. **Question**: Write a program to find array intersection.  
   **Answer**: (See above example.)  
   **Interviewer’s Intention**: Tests set application.

5. **Question**: How do you handle duplicates in a set?**  
   **Answer**: Duplicates are automatically ignored.  
   **Interviewer’s Intention**: Tests uniqueness property.

6. **Question**: What is a hash collision in `unordered_set`?**  
   **Answer**: When multiple elements map to the same bucket, degrading performance.  
   **Interviewer’s Intention**: Tests hash table knowledge.

7. **Question**: Write a program to detect duplicates in an array.  
   **Answer**: (See homework solution 7.)  
   **Interviewer’s Intention**: Tests `unordered_set` usage.

8. **Question**: Why can’t you index into a set?**  
   **Answer**: No random access; elements are stored in a tree or hash table.  
   **Interviewer’s Intention**: Tests container limitations.

9. **Question**: When should you use `set` over `vector`?**  
   **Answer**: Use `set` for sorted unique elements; `vector` for random access or duplicates.  
   **Interviewer’s Intention**: Tests container selection.

10. **Question**: Write a program to simulate a unique ID generator.  
    **Answer**: (See homework solution 10.)  
    **Interviewer’s Intention**: Tests practical application.

11. **Question**: What is the space complexity of `set`?**  
    **Answer**: O(n) for n elements.  
    **Interviewer’s Intention**: Tests complexity awareness.

12. **Question**: Write a program to find the first unique character.  
    **Answer**: (See homework solution 11.)  
    **Interviewer’s Intention**: Tests frequency-based problems.

13. **Question**: Why use `unordered_set` for duplicate detection?**  
    **Answer**: O(1) average lookups make it efficient.  
    **Interviewer’s Intention**: Tests optimization knowledge.

14. **Question**: How do you create a set with a custom comparator?**  
    **Answer**: Define a comparator struct (see custom comparator example).  
    **Interviewer’s Intention**: Tests advanced usage.

15. **Question**: Write a program to find common elements in three arrays.  
    **Answer**: (See homework solution 12.)  
    **Interviewer’s Intention**: Tests multi-set operations.

## Practice Recommendations
- Solve LeetCode problems like **Intersection of Two Arrays** and **Contains Duplicate**.  
- Experiment with custom comparators and hash functions.  
- Practice safe set operations with `find` and `count` checks.