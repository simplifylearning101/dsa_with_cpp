# Solutions to Homework Problems

1. **KMP Pattern Search**
```cpp
#include <iostream>
#include <vector>
#include <string>
std::vector<int> computeLPS(std::string pattern) {
    int m = pattern.length();
    std::vector<int> lps(m, 0);
    int len = 0, i = 1;
    while (i < m) {
        if (pattern[i] == pattern[len]) {
            lps[i++] = ++len;
        } else if (len != 0) {
            len = lps[len - 1];
        } else {
            lps[i++] = 0;
        }
    }
    return lps;
}
int KMPSearch(std::string text, std::string pattern) {
    int n = text.length(), m = pattern.length();
    std::vector<int> lps = computeLPS(pattern);
    int i = 0, j = 0;
    while (i < n) {
        if (text[i] == pattern[j]) {
            i++;
            j++;
        }
        if (j == m) return i - j;
        if (i < n && text[i] != pattern[j]) {
            if (j != 0) j = lps[j - 1];
            else i++;
        }
    }
    return -1;
}
int main() {
    std::string text = "ABABDABACDABABCABAB", pattern = "ABABCABAB";
    std::cout << KMPSearch(text, pattern) << std::endl; // Output: 10
    return 0;
}
```

2. **Rabin-Karp Substring Search**
```cpp
#include <iostream>
#include <string>
#define d 256
int RabinKarp(std::string text, std::string pattern, int q) {
    int n = text.length(), m = pattern.length(), p = 0, t = 0, h = 1;
    for (int i = 0; i < m - 1; i++) h = (h * d) % q;
    for (int i = 0; i < m; i++) {
        p = (d * p + pattern[i]) % q;
        t = (d * t + text[i]) % q;
    }
    for (int i = 0; i <= n - m; i++) {
        if (p == t) {
            bool match = true;
            for (int j = 0; j < m; j++) {
                if (text[i + j] != pattern[j]) {
                    match = false;
                    break;
                }
            }
            if (match) return i;
        }
        if (i < n - m) {
            t = (d * (t - text[i] * h) + text[i + m]) % q;
            if (t < 0) t += q;
        }
    }
    return -1;
}
int main() {
    std::string text = "GEEKSFORGEEKS", pattern = "GEEK";
    std::cout << RabinKarp(text, pattern, 101) << std::endl; // Output: 0
    return 0;
}
```

3. **All Occurrences with KMP**
```cpp
#include <iostream>
#include <vector>
#include <string>
std::vector<int> computeLPS(std::string pattern) {
    int m = pattern.length();
    std::vector<int> lps(m, 0);
    int len = 0, i = 1;
    while (i < m) {
        if (pattern[i] == pattern[len]) {
            lps[i++] = ++len;
        } else if (len != 0) {
            len = lps[len - 1];
        } else {
            lps[i++] = 0;
        }
    }
    return lps;
}
std::vector<int> findAllOccurrences(std::string text, std::string pattern) {
    std::vector<int> result;
    int n = text.length(), m = pattern.length();
    std::vector<int> lps = computeLPS(pattern);
    int i = 0, j = 0;
    while (i < n) {
        if (text[i] == pattern[j]) {
            i++;
            j++;
        }
        if (j == m) {
            result.push_back(i - j);
            j = lps[j - 1];
        }
        if (i < n && text[i] != pattern[j]) {
            if (j != 0) j = lps[j - 1];
            else i++;
        }
    }
    return result;
}
int main() {
    std::string text = "AABAACAADAABAAABAA", pattern = "AABA";
    auto res = findAllOccurrences(text, pattern);
    for (int x : res) std::cout << x << " "; // Output: 0 9 13
    std::cout << std::endl;
    return 0;
}
```

4. **Longest Palindromic Substring**
```cpp
#include <iostream>
#include <string>
std::string longestPalindrome(std::string s) {
    int n = s.length(), start = 0, maxLen = 1;
    for (int i = 0; i < n; i++) {
        // Odd length palindromes
        int left = i, right = i;
        while (left >= 0 && right < n && s[left] == s[right]) {
            if (right - left + 1 > maxLen) {
                start = left;
                maxLen = right - left + 1;
            }
            left--;
            right++;
        }
        // Even length palindromes
        left = i;
        right = i + 1;
        while (left >= 0 && right < n && s[left] == s[right]) {
            if (right - left + 1 > maxLen) {
                start = left;
                maxLen = right - left + 1;
            }
            left--;
            right++;
        }
    }
    return s.substr(start, maxLen);
}
int main() {
    std::string s = "babad";
    std::cout << longestPalindrome(s) << std::endl; // Output: bab
    return 0;
}
```

5. **Check String Rotation**
```cpp
#include <iostream>
#include <string>
bool isRotation(std::string s1, std::string s2) {
    if (s1.length() != s2.length()) return false;
    std::string concat = s1 + s1;
    return concat.find(s2) != std::string::npos;
}
int main() {
    std::string s1 = "waterbottle", s2 = "erbottlewat";
    std::cout << (isRotation(s1, s2) ? "Yes" : "No") << std::endl; // Output: Yes
    return 0;
}
```

6. **Minimum Window Substring**
```cpp
#include <iostream>
#include <string>
#include <unordered_map>
std::string minWindow(std::string s, std::string t) {
    std::unordered_map<char, int> tMap, sMap;
    for (char c : t) tMap[c]++;
    int required = tMap.size(), formed = 0, left = 0, minLen = s.size() + 1, minLeft = 0;
    for (int right = 0; right < s.size(); right++) {
        sMap[s[right]]++;
        if (tMap.count(s[right]) && sMap[s[right]] == tMap[s[right]]) formed++;
        while (formed == required && left <= right) {
            if (right - left + 1 < minLen) {
                minLen = right - left + 1;
                minLeft = left;
            }
            sMap[s[left]]--;
            if (tMap.count(s[left]) && sMap[s[left]] < tMap[s[left]]) formed--;
            left++;
        }
    }
    return minLen > s.size() ? "" : s.substr(minLeft, minLen);
}
int main() {
    std::string s = "ADOBECODEBANC", t = "ABC";
    std::cout << minWindow(s, t) << std::endl; // Output: BANC
    return 0;
}
```

7. **Longest Common Substring**
```cpp
#include <iostream>
#include <string>
std::string longestCommonSubstring(std::string s1, std::string s2) {
    int m = s1.length(), n = s2.length(), maxLen = 0, end = 0;
    std::vector<std::vector<int>> dp(m + 1, std::vector<int>(n + 1, 0));
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (s1[i - 1] == s2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
                if (dp[i][j] > maxLen) {
                    maxLen = dp[i][j];
                    end = i - 1;
                }
            }
        }
    }
    return s1.substr(end - maxLen + 1, maxLen);
}
int main() {
    std::string s1 = "ABABC", s2 = "BABCA";
    std::cout << longestCommonSubstring(s1, s2) << std::endl; // Output: BABC
    return 0;
}
```

8. **Shortest Superstring**
```cpp
#include <iostream>
#include <vector>
#include <string>
std::string shortestSuperstring(std::vector<std::string>& A) {
    int n = A.size();
    std::vector<std::vector<int>> overlap(n, std::vector<int>(n, 0));
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (i != j) {
                for (int k = std::min(A[i].size(), A[j].size()); k >= 0; k--) {
                    if (A[i].substr(A[i].size() - k) == A[j].substr(0, k)) {
                        overlap[i][j] = k;
                        break;
                    }
                }
            }
        }
    }
    std::vector<int> path;
    std::string result = A[0];
    // Simplified greedy approach for demonstration
    for (int i = 1; i < n; i++) {
        int maxOverlap = 0, bestJ = -1;
        for (int j = 0; j < n; j++) {
            if (std::find(path.begin(), path.end(), j) == path.end() && overlap[i - 1][j] > maxOverlap) {
                maxOverlap = overlap[i - 1][j];
                bestJ = j;
            }
        }
        path.push_back(bestJ);
        result += A[bestJ].substr(maxOverlap);
    }
    return result;
}
int main() {
    std::vector<std::string> A = {"catg", "ctaagt", "gcta", "ttca", "atgcat"};
    std::cout << shortestSuperstring(A) << std::endl; // Output: gctaagttcatgcat
    return 0;
}
```

9. **Interleaving String**
```cpp
#include <iostream>
#include <string>
#include <vector>
bool isInterleave(std::string s1, std::string s2, std::string s3) {
    if (s1.length() + s2.length() != s3.length()) return false;
    std::vector<std::vector<bool>> dp(s1.length() + 1, std::vector<bool>(s2.length() + 1, false));
    dp[0][0] = true;
    for (int i = 0; i <= s1.length(); i++) {
        for (int j = 0; j <= s2.length(); j++) {
            if (i > 0 && s1[i - 1] == s3[i + j - 1]) dp[i][j] |= dp[i - 1][j];
            if (j > 0 && s2[j - 1] == s3[i + j - 1]) dp[i][j] |= dp[i][j - 1];
        }
    }
    return dp[s1.length()][s2.length()];
}
int main() {
    std::string s1 = "aabcc", s2 = "dbbca", s3 = "aadbbcbcac";
    std::cout << (isInterleave(s1, s2, s3) ? "Yes" : "No") << std::endl; // Output: Yes
    return 0;
}
```

10. **Distinct Subsequences**
```cpp
#include <iostream>
#include <string>
#include <vector>
int numDistinct(std::string s, std::string t) {
    int m = s.length(), n = t.length();
    std::vector<std::vector<long>> dp(m + 1, std::vector<long>(n + 1, 0));
    for (int i = 0; i <= m; i++) dp[i][0] = 1;
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            dp[i][j] = dp[i - 1][j];
            if (s[i - 1] == t[j - 1]) dp[i][j] += dp[i - 1][j - 1];
        }
    }
    return dp[m][n];
}
int main() {
    std::string s = "rabbbit", t = "rabbit";
    std::cout << numDistinct(s, t) << std::endl; // Output: 3
    return 0;
}
```