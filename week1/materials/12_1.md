# Hour 12: STL Algorithms with Containers

**Agenda**: Introduce students to C++ STL algorithms that operate on containers from Hours 1–11 (vectors, arrays, deques, strings, stacks, queues, priority queues, sets, maps, multisets, multimaps, unordered sets, unordered maps, unordered multimaps). Use real-world analogies and fully commented programs to simplify concepts. Emphasize practical usage, integration with containers, and preparation for coding interviews.

**Outcome Expected**:  
By the end of this hour, students will:  
- Understand STL algorithms like `sort`, `find`, `count`, `accumulate`, `min_element`, `max_element`, and `binary_search`.  
- Apply algorithms to containers (e.g., vectors, sets, maps).  
- Master iterator usage for algorithm operations.  
- Compare algorithm complexities and use cases.  
- Write C++ programs combining containers and algorithms.  
- Be ready to solve LeetCode problems using STL algorithms.

## Topics Covered
1. **Introduction to STL Algorithms**  
   - Overview of `<algorithm>` library.  
   - Iterator-based operations.  
   - Real-world analogy: Algorithms as tools organizing a library.  
2. **Common STL Algorithms**  
   - Sorting: `sort`, `stable_sort`.  
   - Searching: `find`, `binary_search`.  
   - Counting: `count`, `count_if`.  
   - Aggregation: `accumulate`.  
   - Extremes: `min_element`, `max_element`.  
3. **Using Algorithms with Containers**  
   - Applying algorithms to vectors, arrays, deques, sets, maps.  
   - Custom comparators and predicates.  
4. **Iterator Concepts**  
   - Types: Input, output, forward, bidirectional, random-access.  
   - Using `begin()`, `end()`, and range-based loops.  

## Detailed Explanation of Topics Covered

### 1. Introduction to STL Algorithms
The STL `<algorithm>` library provides functions to manipulate containers efficiently. Algorithms operate on ranges defined by iterators, making them versatile for vectors, arrays, deques, sets, and more. Think of algorithms as tools organizing a library of books (elements).

**Key Features**:  
- **Header**: `#include <algorithm>`  
- **Range-Based**: Operate on `[begin, end)` ranges.  
- **Categories**: Sorting, searching, counting, modifying, etc.  
- **Advantages**: Reusable, efficient, and standardized.

### 2. Common STL Algorithms
STL algorithms are categorized by purpose. Below are key algorithms for interviews.

**Sorting Algorithms**:  
- `sort(begin, end)`: O(n log n) – Sorts range in ascending order.  
- `sort(begin, end, comp)`: O(n log n) – Sorts with custom comparator.  
- `stable_sort(begin, end)`: O(n log n) – Maintains relative order of equal elements.

**Searching Algorithms**:  
- `find(begin, end, value)`: O(n) – Returns iterator to first occurrence or `end()`.  
- `binary_search(begin, end, value)`: O(log n) – Checks if value exists in sorted range.  

**Counting Algorithms**:  
- `count(begin, end, value)`: O(n) – Counts occurrences.  
- `count_if(begin, end, pred)`: O(n) – Counts elements satisfying predicate.  

**Aggregation**:  
- `accumulate(begin, end, init)`: O(n) – Sums range starting from `init`.  

**Extremes**:  
- `min_element(begin, end)`: O(n) – Returns iterator to smallest element.  
- `max_element(begin, end)`: O(n) – Returns iterator to largest element.

**Example Program**: Basic STL algorithm usage with vector.

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    vector<int> v = {4, 2, 5, 1, 3};
    
    // Sort
    sort(v.begin(), v.end());  // v = [1, 2, 3, 4, 5]
    cout << "Sorted: ";
    for (int x : v) cout << x << " ";  // Output: 1 2 3 4 5
    cout << endl;
    
    // Find
    auto it = find(v.begin(), v.end(), 3);
    cout << "Find 3: " << (it != v.end() ? "Found" : "Not found") << endl;  // Output: Found
    
    // Count
    cout << "Count of 3: " << count(v.begin(), v.end(), 3) << endl;  // Output: 1
    
    // Sum
    cout << "Sum: " << accumulate(v.begin(), v.end(), 0) << endl;  // Output: 15
    
    // Min and Max
    cout << "Min: " << *min_element(v.begin(), v.end()) << endl;  // Output: 1
    cout << "Max: " << *max_element(v.begin(), v.end()) << endl;  // Output: 5
    
    return 0;
}
```

**Explanation**:  
- `#include <algorithm>`: Imports STL algorithms.  
- `sort`: Rearranges elements in ascending order.  
- `find`: Linear search for value.  
- `accumulate`: Computes sum of range.  
- `min_element`, `max_element`: Find extremes.

### 3. Using Algorithms with Containers
STL algorithms work with any container supporting iterators (e.g., vector, array, deque, set, map).

**Example Program**: Algorithms with different containers.

```cpp
#include <iostream>
#include <vector>
#include <set>
#include <unordered_map>
#include <algorithm>
using namespace std;

int main() {
    // Vector
    vector<int> v = {4, 2, 5, 1};
    sort(v.begin(), v.end());  // v = [1, 2, 4, 5]
    cout << "Sorted vector: ";
    for (int x : v) cout << x << " ";  // Output: 1 2 4 5
    cout << endl;
    
    // Set (already sorted)
    set<int> s = {4, 2, 1};
    cout << "Count of 2 in set: " << count(s.begin(), s.end(), 2) << endl;  // Output: 1
    
    // Unordered map (iterate over pairs)
    unordered_map<string, int> um = {{"apple", 5}, {"banana", 3}};
    auto max_pair = max_element(um.begin(), um.end(), 
        [](const auto& a, const auto& b) { return a.second < b.second; });
    cout << "Max value pair: " << max_pair->first << ":" << max_pair->second << endl;  // Output: apple:5
    
    return 0;
}
```

**Explanation**:  
- Algorithms work with `begin()` and `end()` iterators.  
- Sets are sorted, so `sort` is unnecessary.  
- Maps require pair-based comparison (e.g., compare `second` for values).

### 4. Iterator Concepts
Iterators are pointers to container elements, enabling algorithms to traverse ranges.

**Types**:  
- **Input**: Read-only, forward movement.  
- **Output**: Write-only, forward movement.  
- **Forward**: Read/write, single direction.  
- **Bidirectional**: Read/write, forward/backward (e.g., set, map).  
- **Random-Access**: Read/write, direct access (e.g., vector, deque).  

**Example Program**: Iterator usage.

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    vector<int> v = {1, 2, 3};
    
    // Iterator-based loop
    for (auto it = v.begin(); it != v.end(); ++it) {
        cout << *it << " ";  // Output: 1 2 3
    }
    cout << endl;
    
    // Modify with iterator
    auto it = find(v.begin(), v.end(), 2);
    if (it != v.end()) *it = 10;  // v = [1, 10, 3]
    
    cout << "Modified: ";
    for (int x : v) cout << x << " ";  // Output: 1 10 3
    cout << endl;
    
    return 0;
}
```

**Explanation**:  
- `begin()`, `end()`: Define range.  
- Dereference (`*it`) accesses/modifies elements.  
- Random-access iterators (vector) support `it + n`.

## Points to Remember (Interview Preparation)
1. **Header**: Use `<algorithm>` for most algorithms.  
2. **Iterators**: Use `begin()`, `end()` for ranges; check `end()` for `find`.  
3. **Time Complexities**:  
   - `sort`: O(n log n).  
   - `find`, `count`, `accumulate`: O(n).  
   - `binary_search`: O(log n) (sorted range).  
4. **Use Cases**: Sorting for ordered data, searching for lookups, aggregation for sums.  
5. **Custom Comparators**: Use lambda or function for custom sorting/counting.  
6. **Common Errors**: Ensure range is valid; use `binary_search` only on sorted data.  
7. **Interview Questions**: Be ready for problems like sorting arrays, finding missing numbers, or merging intervals.