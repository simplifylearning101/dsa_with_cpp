# Quiz: Array Optimization and Interview Problems

30 questions: 20 on array optimization and interview problems, 5 on advanced array techniques (Week 2, Hour 3), 5 on two-pointer basics (Week 2, Hour 2).

1. What is the key to optimizing array problems?  
2. How does the two-pointer technique optimize Trapping Rain Water?  
3. Write code for Trapping Rain Water.  
4. What is the role of prefix sum in subarray sum problems?  
5. Write code to find a subarray with a given sum.  
6. How to handle edge cases in array problems?  
7. Write code for Longest Valid Parentheses.  
8. What is the time complexity of Container With Most Water?  
9. Write code for Container With Most Water.  
10. How to optimize maximum sum circular subarray?  
11. Write code for maximum sum circular subarray.  
12. True/False: Prefix sum always uses O(n) space.  
13. How to find subarrays with equal 0s and 1s?  
14. Write code for subarray with equal 0s and 1s.  
15. What is the sliding window approach in Maximum Points from Cards?  
16. Write code for Maximum Points from Cards.  
17. Common pitfall in optimizing array problems?  
18. True/False: Kadane’s algorithm works for circular arrays directly.  
19. How to find max sum of non-overlapping subarrays?  
20. Write code for max sum of two non-overlapping subarrays.  
21. (Advanced Arrays) What is Kadane’s algorithm used for?  
22. (Advanced Arrays) Write code for smallest subarray with sum >= k.  
23. (Advanced Arrays) How does prefix sum optimize range queries?  
24. (Advanced Arrays) Write code for subarrays with sum = k.  
25. (Advanced Arrays) Time complexity of max product subarray?  
26. (Two-Pointer) What are two types of two-pointer techniques?  
27. (Two-Pointer) Write code to remove duplicates from a sorted array.  
28. (Two-Pointer) Time complexity of pair sum in sorted array?  
29. (Two-Pointer) Write code to move zeros to the end.  
30. (Two-Pointer) Common error in two-pointer logic?

## Solutions for the Quiz

1. Reducing time/space complexity using techniques like two-pointer, prefix sum.  
2. Uses two pointers to track max heights, avoiding O(n) space arrays.  
3. 
   ```cpp
   int trapRainWater(int height[], int n) {
       int left = 0, right = n - 1, leftMax = 0, rightMax = 0, water = 0;
       while (left < right) {
           if (height[left] < height[right]) {
               if (height[left] >= leftMax) leftMax = height[left];
               else water += leftMax - height[left];
               left++;
           } else {
               if (height[right] >= rightMax) rightMax = height[right];
               else water += rightMax - height[right];
               right--;
           }
       }
       return water;
   }
   ```
4. Stores cumulative sums for O(1) range queries or subarray sums.  
5. 
   ```cpp
   std::vector<int> subarraySum(int arr[], int n, int k) {
       std::unordered_map<int, int> map;
       map[0] = -1;
       int sum = 0;
       for (int i = 0; i < n; i++) {
           sum += arr[i];
           if (map.find(sum - k) != map.end()) return {map[sum - k] + 1, i};
           map[sum] = i;
       }
       return {};
   }
   ```
6. Check empty arrays, single elements, negatives, invalid inputs.  
7. 
   ```cpp
   int longestValidParentheses(std::string s) {
       std::stack<int> stack;
       stack.push(-1);
       int maxLen = 0;
       for (int i = 0; i < s.size(); i++) {
           if (s[i] == '(') stack.push(i);
           else {
               stack.pop();
               if (stack.empty()) stack.push(i);
               else maxLen = std::max(maxLen, i - stack.top());
           }
       }
       return maxLen;
   }
   ```
8. O(n).  
9. 
   ```cpp
   int maxArea(int height[], int n) {
       int maxWater = 0, left = 0, right = n - 1;
       while (left < right) {
           int water = std::min(height[left], height[right]) * (right - left);
           maxWater = std::max(maxWater, water);
           if (height[left] < height[right]) left++;
           else right--;
       }
       return maxWater;
   }
   ```
10. Use Kadane’s for straight max, subtract min subarray sum for circular case.  
11. 
   ```cpp
   int maxSubarraySumCircular(int arr[], int n) {
       int maxStraight = arr[0], currMax = arr[0];
       int minStraight = arr[0], currMin = arr[0], total = arr[0];
       for (int i = 1; i < n; i++) {
           currMax = std::max(arr[i], currMax + arr[i]);
           maxStraight = std::max(maxStraight, currMax);
           currMin = std::min(arr[i], currMin + arr[i]);
           minStraight = std::min(minStraight, currMin);
           total += arr[i];
       }
       if (maxStraight < 0) return maxStraight;
       return std::max(maxStraight, total - minStraight);
   }
   ```
12. True.  
13. Treat 0 as -1, use prefix sum to find equal sums.  
14. 
   ```cpp
   int findMaxLength(int arr[], int n) {
       std::unordered_map<int, int> map;
       map[0] = -1;
       int sum = 0, maxLen = 0;
       for (int i = 0; i < n; i++) {
           sum += (arr[i] == 0 ? -1 : 1);
           if (map.find(sum) != map.end()) maxLen = std::max(maxLen, i - map[sum]);
           else map[sum] = i;
       }
       return maxLen;
   }
   ```
15. Fixed-size window sliding from front to back.  
16. 
   ```cpp
   int maxScore(int arr[], int n, int k) {
       int sum = 0;
       for (int i = 0; i < k; i++) sum += arr[i];
       int maxSum = sum;
       for (int i = 0; i < k; i++) {
           sum = sum - arr[k - 1 - i] + arr[n - 1 - i];
           maxSum = std::max(maxSum, sum);
       }
       return maxSum;
   }
   ```
17. Missing edge cases or incorrect pointer updates.  
18. False, needs modification for circular case.  
19. Use prefix sums and Kadane’s to find max sums independently.  
20. 
   ```cpp
   int maxSumTwoNoOverlap(int arr[], int n, int firstLen, int secondLen) {
       std::vector<int> prefix(n + 1, 0);
       for (int i = 0; i < n; i++) prefix[i + 1] = prefix[i] + arr[i];
       int maxSum = 0;
       for (int i = firstLen; i <= n; i++) {
           int first = prefix[i] - prefix[i - firstLen];
           for (int j = secondLen; j <= n; j++) {
               if (j <= i - firstLen || j >= i + secondLen) {
                   int second = prefix[j] - prefix[j - secondLen];
                   maxSum = std::max(maxSum, first + second);
               }
           }
       }
       return maxSum;
   }
   ```
21. Maximum subarray sum.  
22. 
   ```cpp
   int smallestSubarray(int arr[], int n, int k) {
       int sum = 0, minLen = n + 1, left = 0;
       for (int right = 0; right < n; right++) {
           sum += arr[right];
           while (sum >= k && left <= right) {
               minLen = std::min(minLen, right - left + 1);
               sum -= arr[left++];
           }
       }
       return minLen > n ? -1 : minLen;
   }
   ```
23. Precomputes sums for O(1) queries.  
24. 
   ```cpp
   int subarraySum(int arr[], int n, int k) {
       std::unordered_map<int, int> map;
       map[0] = 1;
       int sum = 0, count = 0;
       for (int i = 0; i < n; i++) {
           sum += arr[i];
           if (map.find(sum - k) != map.end()) count += map[sum - k];
           map[sum]++;
       }
       return count;
   }
   ```
25. O(n).  
26. Opposite ends, same direction.  
27. 
   ```cpp
   int removeDuplicates(int arr[], int n) {
       if (n <= 1) return n;
       int i = 0;
       for (int j = 1; j < n; j++) {
           if (arr[j] != arr[i]) arr[++i] = arr[j];
       }
       return i + 1;
   }
   ```
28. O(n) after O(n log n) sort.  
29. 
   ```cpp
   void moveZeroes(int arr[], int n) {
       int nonZeroPos = 0;
       for (int i = 0; i < n; i++) {
           if (arr[i] != 0) arr[nonZeroPos++] = arr[i];
       }
       while (nonZeroPos < n) arr[nonZeroPos++] = 0;
   }
   ```
30. Incorrect pointer updates or bounds checking.