# Agenda: Introduction to Two-Pointer Technique in Arrays

## Outcome Expected:
By the end of this hour, students will understand the two-pointer technique, apply it to solve common array problems, and recognize its efficiency in reducing time complexity. Students will be able to implement solutions for problems like finding pairs, removing duplicates, and partitioning arrays, preparing them for related interview questions.

## Topics Covered
1. What is the Two-Pointer Technique?  
2. Types of Two-Pointer Approaches (Opposite Ends vs. Same Direction).  
3. Applications in Arrays (Pair Sum, Remove Duplicates, Partitioning).  
4. Advantages and Limitations.  
5. Common Patterns and Examples.  

## Detailed Explanation of Topics Covered

### 1. What is the Two-Pointer Technique?
The two-pointer technique uses two indices (pointers) to traverse an array, often to reduce time complexity from O(n²) to O(n). It's particularly useful for sorted arrays or problems involving pairs or subarrays.

Simple Example (Check if array is palindrome):
```cpp
#include <iostream>
bool isPalindrome(int arr[], int n) {
    int left = 0, right = n - 1;
    while (left < right) {
        if (arr[left] != arr[right]) return false;
        left++;
        right--;
    }
    return true;
}
int main() {
    int arr[] = {1, 2, 2, 1};
    std::cout << (isPalindrome(arr, 4) ? "Yes" : "No") << std::endl; // Output: Yes
    return 0;
}
```

### 2. Types of Two-Pointer Approaches
- **Opposite Ends (Converging Pointers):** Two pointers start from opposite ends and move toward each other (e.g., palindrome check, pair sum in sorted array).
- **Same Direction (Fast and Slow Pointers):** Two pointers move in the same direction at different speeds or with specific conditions (e.g., remove duplicates).

Example (Opposite Ends for Pair Sum):
```cpp
#include <iostream>
#include <algorithm> // For sort
bool findPairSum(int arr[], int n, int target) {
    std::sort(arr, arr + n); // Sort first
    int left = 0, right = n - 1;
    while (left < right) {
        int sum = arr[left] + arr[right];
        if (sum == target) return true;
        else if (sum < target) left++;
        else right--;
    }
    return false;
}
int main() {
    int arr[] = {2, 7, 11, 15};
    std::cout << findPairSum(arr, 4, 9) << std::endl; // Output: 1 (true)
    return 0;
}
```

### 3. Applications in Arrays
- **Pair Sum:** Find two elements summing to a target.
- **Remove Duplicates:** In a sorted array, keep unique elements.
- **Partitioning:** Rearrange elements based on a condition (e.g., move zeros).

Example (Remove Duplicates):
```cpp
#include <iostream>
int removeDuplicates(int arr[], int n) {
    if (n <= 1) return n;
    int i = 0; // Slow pointer for next unique element
    for (int j = 1; j < n; j++) { // Fast pointer
        if (arr[j] != arr[i]) {
            arr[++i] = arr[j];
        }
    }
    return i + 1; // Length of unique elements
}
int main() {
    int arr[] = {1, 1, 2, 2, 3};
    int len = removeDuplicates(arr, 5);
    for (int i = 0; i < len; i++) {
        std::cout << arr[i] << " "; // Output: 1 2 3
    }
    std::cout << std::endl;
    return 0;
}
```

### 4. Advantages and Limitations
**Advantages:**
- Reduces time complexity (e.g., O(n²) to O(n)).
- Often in-place, saving space.
- Common in interview problems.

**Limitations:**
- Often requires sorted arrays.
- Not applicable to all array problems.
- Requires careful pointer management.

### 5. Common Patterns and Examples
- **Pattern 1: Pair Sum in Sorted Array** (above example).
- **Pattern 2: Partitioning (e.g., Move Zeros):**
```cpp
#include <iostream>
void moveZeroes(int arr[], int n) {
    int nonZeroPos = 0; // Slow pointer for non-zero elements
    for (int i = 0; i < n; i++) { // Fast pointer
        if (arr[i] != 0) {
            arr[nonZeroPos++] = arr[i];
        }
    }
    while (nonZeroPos < n) {
        arr[nonZeroPos++] = 0;
    }
}
int main() {
    int arr[] = {0, 1, 0, 3, 12};
    moveZeroes(arr, 5);
    for (int i = 0; i < 5; i++) {
        std::cout << arr[i] << " "; // Output: 1 3 12 0 0
    }
    std::cout << std::endl;
    return 0;
}
```
**Cheatsheet for Two-Pointer Patterns:**
| Pattern | Use Case | Time Complexity | Space Complexity |
|---------|----------|-----------------|------------------|
| Opposite Ends | Pair sum, palindrome | O(n) or O(n log n) if sorting | O(1) |
| Same Direction | Remove duplicates, partitioning | O(n) | O(1) |

## Points to Remember
- Two-pointer reduces nested loops in many cases.
- Opposite ends work well for sorted arrays; same direction for in-place updates.
- Always check pointer bounds to avoid out-of-bounds errors.
- Sorting may be needed (O(n log n)), impacting total complexity.
- Common interview questions: Pair sum, remove duplicates, partition arrays.
- Practice pointer initialization and movement logic.
- Use `std::vector` for dynamic arrays (Week 1) when size changes.
- Debug tip: Print pointer positions to trace logic.
- Time complexity: O(n) for traversal, O(n log n) if sorting required.
- Space complexity: Usually O(1) for in-place operations.