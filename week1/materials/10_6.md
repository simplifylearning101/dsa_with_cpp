# Hour 10 LeetCode Problem: Contains Duplicate

This document illustrates **LeetCode 217: Contains Duplicate**, an easy problem that leverages STL `unordered_set` for efficient duplicate detection. It includes the problem description, coding pattern, solution, complexity analysis, and test cases.

## Problem Statement: LeetCode 217 - Contains Duplicate
**Link**: [LeetCode 217](https://leetcode.com/problems/contains-duplicate/)

**Description**:  
Given an integer array `nums`, return `true` if any value appears at least twice in the array, and `false` if every element is distinct.

**Constraints**:
- `1 <= nums.length <= 10^5`
- `-10^9 <= nums[i] <= 10^9`

**Example**:
- Input: `nums = [1,2,3,1]`  
  Output: `true`  
  Explanation: `1` appears twice.

**Real-World Analogy**: Checking if a guest list has duplicate names.

## Coding Pattern: Unordered Set for Duplicate Detection
- Use `unordered_set` to track seen elements.  
- For each element, check if it exists in the set.  
- If found, return `true`; otherwise, insert and continue.

## Solution
**Algorithm**:
1. Initialize an `unordered_set`.  
2. Iterate through `nums`.  
3. For each element, check if it’s in the set. If yes, return `true`.  
4. Insert element into the set.  
5. Return `false` if no duplicates found.

**Code**:
```cpp
#include <unordered_set>
#include <vector>
using namespace std;

class Solution {
public:
    bool containsDuplicate(vector<int>& nums) {
        unordered_set<int> us;
        for (int num : nums) {
            if (us.find(num) != us.end()) {
                return true; // Duplicate found
            }
            us.insert(num); // Add to set
        }
        return false; // No duplicates
    }
};
```

**Time Complexity**: O(n)  
- Each `find` and `insert` is O(1) average, for n elements.

**Space Complexity**: O(n)  
- Stores up to n elements in the set.

**Explanation**:  
- `unordered_set` provides O(1) average lookups.  
- Early return on duplicate detection optimizes performance.

## Test Cases
1. **Typical Case**: `nums = [1,2,3,1]` → Output: `true`  
2. **No Duplicates**: `nums = [1,2,3,4]` → Output: `false`  
3. **Single Element**: `nums = [1]` → Output: `false`  
4. **All Same**: `nums = [1,1,1]` → Output: `true`  
5. **Empty Array**: `nums = []` → Output: `false`  

**Test Case Implementation**:
```cpp
#include <iostream>
#include <unordered_set>
#include <vector>
using namespace std;

bool containsDuplicate(vector<int>& nums) {
    unordered_set<int> us;
    for (int num : nums) {
        if (us.find(num) != us.end()) {
            return true;
        }
        us.insert(num);
    }
    return false;
}

int main() {
    // Test cases
    vector<int> nums1 = {1, 2, 3, 1};
    cout << "Test 1: " << (containsDuplicate(nums1) ? "true" : "false") << endl; // true
    
    vector<int> nums2 = {1, 2, 3, 4};
    cout << "Test 2: " << (containsDuplicate(nums2) ? "true" : "false") << endl; // false
    
    vector<int> nums3 = {1};
    cout << "Test 3: " << (containsDuplicate(nums3) ? "true" : "false") << endl; // false
    
    vector<int> nums4 = {1, 1, 1};
    cout << "Test 4: " << (containsDuplicate(nums4) ? "true" : "false") << endl; // true
    
    vector<int> nums5 = {};
    cout << "Test 5: " << (containsDuplicate(nums5) ? "true" : "false") << endl; // false
    
    return 0;
}
```

**Output**:
```
Test 1: true
Test 2: false
Test 3: false
Test 4: true
Test 5: false
```

## Optimization Mindset
- **Efficiency**: `unordered_set` ensures O(n) average time.  
- **Key Insight**: Early return on duplicate detection.  
- **Edge Cases**: Handle empty arrays and single elements.