# Hour 6 Homework Solutions: Priority Queue Practice Problems

Below are solutions to the 12 homework problems, each with fully commented C++ code to help students understand STL `priority_queue` implementation. The solutions are beginner-friendly and emphasize interview-relevant techniques.

1. **Problem**: Create a max-heap, push 5 integers, and print its size.  
```cpp
#include <iostream>
#include <queue>
using namespace std;

int main() {
    priority_queue<int> pq;
    
    // Push 5 integers
    for (int i = 1; i <= 5; ++i) {
        pq.push(i);
    }
    
    // Print size
    cout << "Size: " << pq.size() << endl; // Output: 5
    
    return 0;
}
```

2. **Problem**: Pop elements and print in order.  
```cpp
#include <iostream>
#include <queue>
using namespace std;

int main() {
    priority_queue<int> pq;
    pq.push(5); pq.push(4); pq.push(3);
    
    // Pop and print
    while (!pq.empty()) {
        cout << pq.top() << " "; // Output: 5 4 3
        pq.pop();
    }
    cout << endl;
    
    return 0;
}
```

3. **Problem**: Check if a priority queue is empty after pushing and popping.  
```cpp
#include <iostream>
#include <queue>
using namespace std;

int main() {
    priority_queue<int> pq;
    pq.push(1);
    pq.pop();
    
    // Check empty
    cout << "Empty: " << (pq.empty() ? "Yes" : "No") << endl; // Output: Yes
    
    return 0;
}
```

4. **Problem**: Implement a min-heap using a custom comparator.  
```cpp
#include <iostream>
#include <queue>
using namespace std;

int main() {
    // Min-heap
    priority_queue<int, vector<int>, greater<int>> pq;
    pq.push(3); pq.push(1); pq.push(5);
    
    // Print in ascending order
    while (!pq.empty()) {
        cout << pq.top() << " "; // Output: 1 3 5
        pq.pop();
    }
    cout << endl;
    
    return 0;
}
```

5. **Problem**: Simulate a hospital triage system.  
```cpp
#include <iostream>
#include <queue>
#include <vector>
using namespace std;

void triagePatients(const vector<pair<int, string>>& patients) {
    priority_queue<pair<int, int>> pq;
    // Push patients with index for tie-breaking
    for (int i = 0; i < patients.size(); ++i) {
        int priority = (patients[i].second == "high" ? 3 : (patients[i].second == "medium" ? 2 : 1));
        pq.push({priority, -i}); // Negative index for FIFO within same priority
    }
    
    // Process patients
    while (!pq.empty()) {
        int idx = -pq.top().second;
        cout << "Treating patient: " << patients[idx].first << endl;
        pq.pop();
    }
}

int main() {
    vector<pair<int, string>> patients = {{1, "low"}, {3, "high"}, {2, "medium"}};
    triagePatients(patients); // Output: Treating patient: 3, Treating patient: 2, Treating patient: 1
    return 0;
}
```

6. **Problem**: Find the kth largest element in an array.  
```cpp
#include <iostream>
#include <queue>
#include <vector>
using namespace std;

int findKthLargest(const vector<int>& nums, int k) {
    priority_queue<int, vector<int>, greater<int>> pq; // Min-heap
    for (int num : nums) {
        pq.push(num);
        if (pq.size() > k) {
            pq.pop(); // Keep only k largest
        }
    }
    return pq.top();
}

int main() {
    vector<int> nums = {3, 2, 1, 5, 6, 4};
    int k = 2;
    cout << "Kth largest: " << findKthLargest(nums, k) << endl; // Output: 5
    return 0;
}
```

7. **Problem**: Merge k sorted arrays.  
```cpp
#include <iostream>
#include <queue>
#include <vector>
using namespace std;

vector<int> mergeKSorted(const vector<vector<int>>& arrays) {
    priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<>> pq; // Min-heap
    vector<int> result;
    
    // Push first element of each array
    for (int i = 0; i < arrays.size(); ++i) {
        if (!arrays[i].empty()) {
            pq.push({arrays[i][0], i, 0});
        }
    }
    
    // Merge arrays
    while (!pq.empty()) {
        auto [val, arr_idx, elem_idx] = pq.top();
        pq.pop();
        result.push_back(val);
        if (elem_idx + 1 < arrays[arr_idx].size()) {
            pq.push({arrays[arr_idx][elem_idx + 1], arr_idx, elem_idx + 1});
        }
    }
    
    return result;
}

int main() {
    vector<vector<int>> arrays = {{1, 4}, {2, 5}, {3, 6}};
    vector<int> result = mergeKSorted(arrays);
    for (int x : result) {
        cout << x << " "; // Output: 1 2 3 4 5 6
    }
    cout << endl;
    return 0;
}
```

8. **Problem**: Implement a task scheduler with priority and cooldown.  
```cpp
#include <iostream>
#include <queue>
#include <vector>
#include <unordered_map>
using namespace std;

int scheduleTasks(const vector<int>& tasks, int cooldown) {
    priority_queue<pair<int, int>> pq; // {count, task}
    unordered_map<int, int> last_seen; // Last time task was processed
    unordered_map<int, int> freq;
    int time = 0;
    
    // Count frequencies
    for (int task : tasks) {
        freq[task]++;
    }
    for (const auto& p : freq) {
        pq.push({p.second, p.first});
    }
    
    // Process tasks
    while (!pq.empty()) {
        vector<pair<int, int>> temp;
        time++;
        if (!pq.empty()) {
            auto [count, task] = pq.top();
            pq.pop();
            if (last_seen.count(task) && time - last_seen[task] <= cooldown) {
                time = last_seen[task] + cooldown + 1;
            }
            last_seen[task] = time;
            if (count - 1 > 0) {
                temp.push_back({count - 1, task});
            }
        }
        for (const auto& p : temp) {
            pq.push(p);
        }
    }
    
    return time;
}

int main() {
    vector<int> tasks = {1, 1, 2};
    int cooldown = 2;
    cout << "Total time: " << scheduleTasks(tasks, cooldown) << endl; // Output: 7
    return 0;
}
```

9. **Problem**: Find the top k frequent elements.  
```cpp
#include <iostream>
#include <queue>
#include <vector>
#include <unordered_map>
using namespace std;

vector<int> topKFrequent(const vector<int>& nums, int k) {
    unordered_map<int, int> freq;
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq; // Min-heap
    vector<int> result;
    
    // Count frequencies
    for (int num : nums) {
        freq[num]++;
    }
    
    // Keep k elements in min-heap
    for (const auto& p : freq) {
        pq.push({p.second, p.first});
        if (pq.size() > k) {
            pq.pop();
        }
    }
    
    // Extract results
    while (!pq.empty()) {
        result.push_back(pq.top().second);
        pq.pop();
    }
    
    return result;
}

int main() {
    vector<int> nums = {1, 1, 1, 2, 2, 3};
    int k = 2;
    vector<int> result = topKFrequent(nums, k);
    for (int x : result) {
        cout << x << " "; // Output: 1 2
    }
    cout << endl;
    return 0;
}
```

10. **Problem**: Implement a stream median finder.  
```cpp
#include <iostream>
#include <queue>
using namespace std;

class MedianFinder {
private:
    priority_queue<int> max_heap; // Lower half
    priority_queue<int, vector<int>, greater<int>> min_heap; // Upper half
public:
    void addNum(int num) {
        if (max_heap.empty() || num < max_heap.top()) {
            max_heap.push(num);
        } else {
            min_heap.push(num);
        }
        // Balance heaps
        if (max_heap.size() > min_heap.size() + 1) {
            min_heap.push(max_heap.top());
            max_heap.pop();
        } else if (min_heap.size() > max_heap.size()) {
            max_heap.push(min_heap.top());
            min_heap.pop();
        }
    }
    
    double findMedian() {
        if (max_heap.size() == min_heap.size()) {
            return (max_heap.top() + min_heap.top()) / 2.0;
        }
        return max_heap.top();
    }
};

int main() {
    MedianFinder mf;
    mf.addNum(2); cout << mf.findMedian() << endl; // Output: 2
    mf.addNum(3); cout << mf.findMedian() << endl; // Output: 2.5
    mf.addNum(4); cout << mf.findMedian() << endl; // Output: 3
    return 0;
}
```

11. **Problem**: Simulate a priority-based job queue with weights.  
```cpp
#include <iostream>
#include <queue>
#include <vector>
using namespace std;

void processJobs(const vector<pair<int, int>>& jobs) {
    priority_queue<pair<int, int>> pq;
    for (int i = 0; i < jobs.size(); ++i) {
        pq.push({jobs[i].second, -i}); // Weight, negative index for tie-breaking
    }
    
    // Process jobs
    while (!pq.empty()) {
        int idx = -pq.top().second;
        cout << "Processing job: " << jobs[idx].first << endl;
        pq.pop();
    }
}

int main() {
    vector<pair<int, int>> jobs = {{1, 10}, {2, 5}, {3, 15}};
    processJobs(jobs); // Output: Processing job: 3, Processing job: 1, Processing job: 2
    return 0;
}
```

12. **Problem**: Find the k closest points to origin.  
```cpp
#include <iostream>
#include <queue>
#include <vector>
using namespace std;

vector<vector<int>> kClosest(const vector<vector<int>>& points, int k) {
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq; // Min-heap
    vector<vector<int>> result;
    
    // Push distances
    for (int i = 0; i < points.size(); ++i) {
        int dist = points[i][0] * points[i][0] + points[i][1] * points[i][1];
        pq.push({dist, i});
    }
    
    // Extract k closest
    for (int i = 0; i < k && !pq.empty(); ++i) {
        int idx = pq.top().second;
        result.push_back(points[idx]);
        pq.pop();
    }
    
    return result;
}

int main() {
    vector<vector<int>> points = {{1, 1}, {2, 2}, {0, 0}};
    int k = 2;
    vector<vector<int>> result = kClosest(points, k);
    for (const auto& p : result) {
        cout << "[" << p[0] << "," << p[1] << "] "; // Output: [0,0] [1,1]
    }
    cout << endl;
    return 0;
}
```