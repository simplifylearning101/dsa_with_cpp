# Solutions for Leetcode Problems

1. **Valid Palindrome**  
   **Explanation:** Check palindrome ignoring non-alphanumeric.  
   **Brute-Force:** Preprocess and compare.  
   ```cpp
   bool isValidPalindrome(string s) {
       string clean;
       for (char c : s) {
           if (isalnum(c)) clean += tolower(c);
       }
       for (int i = 0; i < clean.length() / 2; i++) {
           if (clean[i] != clean[clean.length() - 1 - i]) return false;
       }
       return true;
   }
   ```
   Pros: Simple. Cons: O(n) space.  
   **Optimized:** Two-pointer.  
   ```cpp
   bool isValidPalindrome(string s) {
       int left = 0, right = s.length() - 1;
       while (left < right) {
           while (left < right && !isalnum(s[left])) left++;
           while (left < right && !isalnum(s[right])) right--;
           if (tolower(s[left++]) != tolower(s[right--])) return false;
       }
       return true;
   }
   ```
   Pros: O(n) time, O(1) space. Cons: None.

2. **Reverse String**  
   **Explanation:** Reverse string in-place.  
   **Brute-Force:** Create new string.  
   ```cpp
   void reverseString(vector<char>& s) {
       vector<char> temp;
       for (int i = s.size() - 1; i >= 0; i--) temp.push_back(s[i]);
       s = temp;
   }
   ```
   Pros: Easy. Cons: O(n) space.  
   **Optimized:** Two-pointer.  
   ```cpp
   void reverseString(vector<char>& s) {
       int left = 0, right = s.size() - 1;
       while (left < right) swap(s[left++], s[right--]);
   }
   ```
   Pros: O(n) time, O(1) space. Cons: None.

3. **Valid Anagram**  
   **Explanation:** Check if strings are anagrams.  
   **Brute-Force:** Sort strings.  
   ```cpp
   bool isAnagram(string s, string t) {
       sort(s.begin(), s.end());
       sort(t.begin(), t.end());
       return s == t;
   }
   ```
   Pros: Simple. Cons: O(n log n) time.  
   **Optimized:** Frequency array.  
   ```cpp
   bool isAnagram(string s, string t) {
       if (s.length() != t.length()) return false;
       int count[26] = {0};
       for (int i = 0; i < s.length(); i++) {
           count[s[i] - 'a']++;
           count[t[i] - 'a']--;
       }
       for (int x : count) if (x != 0) return false;
       return true;
   }
   ```
   Pros: O(n) time, O(1) space. Cons: Limited to lowercase letters.

4. **String to Integer (atoi)**  
   **Explanation:** Convert string to integer with edge cases.  
   **Brute-Force:** Manual parsing.  
   ```cpp
   int myAtoi(string s) {
       long result = 0;
       int sign = 1, i = 0;
       while (i < s.length() && s[i] == ' ') i++;
       if (i < s.length() && (s[i] == '+' || s[i] == '-')) {
           sign = (s[i++] == '-') ? -1 : 1;
       }
       while (i < s.length() && isdigit(s[i])) {
           result = result * 10 + (s[i++] - '0');
           if (result * sign > INT_MAX) return INT_MAX;
           if (result * sign < INT_MIN) return INT_MIN;
       }
       return result * sign;
   }
   ```
   Pros: Handles edge cases. Cons: Complex logic.  
   **Optimized:** Same as above, no simpler solution.

5. **Longest Common Prefix**  
   **Explanation:** Find common prefix in string array.  
   **Brute-Force:** Compare all characters.  
   ```cpp
   string longestCommonPrefix(vector<string>& strs) {
       if (strs.empty()) return "";
       for (int i = 0; i < strs[0].length(); i++) {
           char c = strs[0][i];
           for (int j = 1; j < strs.size(); j++) {
               if (i >= strs[j].length() || strs[j][i] != c) {
                   return strs[0].substr(0, i);
               }
           }
       }
       return strs[0];
   }
   ```
   Pros: Simple. Cons: O(n*m) time (n=strings, m=min length).  
   **Optimized:** Use first string as prefix.  
   ```cpp
   string longestCommonPrefix(vector<string>& strs) {
       if (strs.empty()) return "";
       string prefix = strs[0];
       for (int i = 1; i < strs.size(); i++) {
           while (strs[i].find(prefix) != 0) {
               prefix = prefix.substr(0, prefix.length() - 1);
               if (prefix.empty()) return "";
           }
       }
       return prefix;
   }
   ```
   Pros: O(n*m) time, cleaner logic. Cons: Still O(n*m).