# Hour 2 Quiz: Arrays and Deques in STL

Below are 30 questions to test understanding of STL arrays, deques, and foundational concepts from Hour 1 (vectors). The questions are designed for interview preparation, covering key operations and concepts.

## Quiz Questions

1. **What is the main difference between STL `array` and `vector`?**  
   a) Array is dynamic, vector is fixed  
   b) Array is fixed-size, vector is dynamic  
   c) Array supports iterators, vector does not  
   d) Vector is stack-allocated, array is heap-allocated  
   **Answer**: b) Array is fixed-size, vector is dynamic  
   **Explanation**: STL `array` has a compile-time fixed size, while `vector` can resize dynamically.

2. **Which header is required for STL `array`?**  
   a) `<vector>`  
   b) `<array>`  
   c) `<deque>`  
   d) `<list>`  
   **Answer**: b) `<array>`  
   **Explanation**: The `<array>` header provides the STL array container.

3. **What is the time complexity of `push_front` in a deque?**  
   a) O(n)  
   b) O(1)  
   c) O(log n)  
   d) O(n log n)  
   **Answer**: b) O(1)  
   **Explanation**: Deque supports O(1) insertions at both ends.

4. **How do you declare an STL array of 3 doubles?**  
   a) `array<double, 3> arr;`  
   b) `double array<3> arr;`  
   c) `array<3, double> arr;`  
   d) `array arr<double, 3>;`  
   **Answer**: a) `array<double, 3> arr;`  
   **Explanation**: Correct syntax for a fixed-size array of 3 doubles.

5. **What does `array<int, 5> arr = {1, 2};` initialize?**  
   a) First two elements to 1, 2; rest undefined  
   b) First two elements to 1, 2; rest to 0  
   c) All elements to 1  
   d) Throws compilation error  
   **Answer**: b) First two elements to 1, 2; rest to 0  
   **Explanation**: Unspecified elements are initialized to 0.

6. **Which deque operation is NOT O(1)?**  
   a) `push_front`  
   b) `push_back`  
   c) `insert` (middle)  
   d) `pop_front`  
   **Answer**: c) `insert` (middle)  
   **Explanation**: Middle insertions require shifting elements, taking O(n).

7. **What happens if you access `arr.at(5)` in an `array<int, 5>`?**  
   a) Returns 0  
   b) Undefined behavior  
   c) Throws out_of_range exception  
   d) Returns garbage value  
   **Answer**: c) Throws out_of_range exception  
   **Explanation**: `at()` performs bounds checking.

8. **What is the main advantage of STL `array` over C-style arrays?**  
   a) Dynamic resizing  
   b) Bounds checking and size awareness  
   c) O(1) insertions  
   d) Non-contiguous memory  
   **Answer**: b) Bounds checking and size awareness  
   **Explanation**: STL `array` provides `at()`, `size()`, and iterator support.

9. **What does `deque<int> dq;` create?**  
   a) Fixed-size array  
   b) Empty double-ended queue  
   c) Dynamic vector  
   d) Linked list  
   **Answer**: b) Empty double-ended queue  
   **Explanation**: Deque is a dynamic container for front/back operations.

10. **What is the output of `array<int, 3> arr; cout << arr.size();`?**  
    a) 0  
    b) 3  
    c) Undefined  
    d) Garbage value  
    **Answer**: b) 3  
    **Explanation**: `size()` returns the fixed size of the array.

11. **Which container is best for frequent front insertions?**  
    a) Vector  
    b) Array  
    c) Deque  
    d) C-style array  
    **Answer**: c) Deque  
    **Explanation**: Deque supports O(1) `push_front`.

12. **What does `dq.pop_back()` do?**  
    a) Removes first element  
    b) Removes last element  
    c) Clears deque  
    d) Reduces size to 0  
    **Answer**: b) Removes last element  
    **Explanation**: `pop_back` removes the last element in O(1).

13. **How do you initialize a deque with 3 elements?**  
    a) `deque<int> dq = {1, 2, 3};`  
    b) `deque<int> dq(3, 1);`  
    c) Both a and b  
    d) `deque<int> dq[3] = {1, 2, 3};`  
    **Answer**: c) Both a and b  
    **Explanation**: Both initializer list and constructor work.

14. **What is the time complexity of accessing `dq[5]` in a deque?**  
    a) O(1)  
    b) O(n)  
    c) O(log n)  
    d) O(n log n)  
    **Answer**: a) O(1)  
    **Explanation**: Deque supports random access, though slower than vectors.

15. **What is the output of `deque<int> dq; dq.push_back(1); cout << dq.front();`?**  
    a) 0  
    b) 1  
    c) Undefined  
    d) Throws exception  
    **Answer**: b) 1  
    **Explanation**: `front()` returns the first element.

16. **What happens if you dereference `dq.end()`?**  
    a) Returns last element  
    b) Undefined behavior  
    c) Returns 0  
    d) Throws exception  
    **Answer**: b) Undefined behavior  
    **Explanation**: `end()` points past the last element.

17. **Which is NOT a feature of STL `array`?**  
    a) Bounds checking  
    b) Dynamic resizing  
    c) Iterator support  
    d) Fixed size  
    **Answer**: b) Dynamic resizing  
    **Explanation**: Arrays have a fixed size.

18. **What does `dq.push_front(5)` do?**  
    a) Adds 5 to the back  
    b) Adds 5 to the front  
    c) Replaces first element  
    d) Clears deque  
    **Answer**: b) Adds 5 to the front  
    **Explanation**: `push_front` adds to the front in O(1).

19. **How do you check if an array is empty?**  
    a) `arr.empty()`  
    b) `arr.size() == 0`  
    c) Both a and b  
    d) Arrays are never empty  
    **Answer**: d) Arrays are never empty  
    **Explanation**: STL arrays have a fixed size, so `empty()` always returns false.

20. **What is the output of `deque<int> dq = {1, 2, 3}; dq.pop_front(); cout << dq.size();`?**  
    a) 2  
    b) 3  
    c) 1  
    d) 0  
    **Answer**: a) 2  
    **Explanation**: `pop_front` reduces size by 1.

21. **Can a deque store strings?**  
    a) Yes  
    b) No  
    c) Only integers  
    d) Only with custom classes  
    **Answer**: a) Yes  
    **Explanation**: Deque is a template container.

22. **What is the underlying structure of a deque?**  
    a) Contiguous array  
    b) Linked list  
    c) Array of fixed-size blocks  
    d) Binary tree  
    **Answer**: c) Array of fixed-size blocks  
    **Explanation**: Deque uses blocks for O(1) front/back access.

23. **Which loop is modern for iterating over a deque?**  
    a) `for (int i = 0; i < dq.size(); i++)`  
    b) `for (auto it = dq.begin(); it != dq.end(); ++it)`  
    c) `for (int x : dq)`  
    d) All of the above  
    **Answer**: c) `for (int x : dq)`  
    **Explanation**: Range-based for loop is modern and readable.

24. **What happens if you access `arr[5]` in an `array<int, 5>`?**  
    a) Returns 0  
    b) Undefined behavior  
    c) Throws exception  
    d) Returns garbage value  
    **Answer**: b) Undefined behavior  
    **Explanation**: `operator[]` doesnâ€™t check bounds.

25. **What is the time complexity of `pop_front` in a deque?**  
    a) O(1)  
    b) O(n)  
    c) O(log n)  
    d) O(n log n)  
    **Answer**: a) O(1)  
    **Explanation**: Deque supports O(1) front removals.

26. **How do you initialize an array with 4 zeros?**  
    a) `array<int, 4> arr = {0};`  
    b) `array<int, 4> arr(0);`  
    c) `array<int, 4> arr;`  
    d) Both a and c  
    **Answer**: d) Both a and c  
    **Explanation**: Uninitialized elements default to 0.

27. **What is the output of `array<int, 3> arr = {1, 2, 3}; cout << arr.back();`?**  
    a) 1  
    b) 2  
    c) 3  
    d) Undefined  
    **Answer**: c) 3  
    **Explanation**: `back()` returns the last element.

28. **When should you use a deque over a vector?**  
    a) Random access  
    b) Frequent front insertions  
    c) Fixed-size data  
    d) Cache-friendly access  
    **Answer**: b) Frequent front insertions  
    **Explanation**: Deque is optimized for front/back operations.

29. **What does `#include <deque>` do?**  
    a) Includes all STL containers  
    b) Provides deque class  
    c) Enables algorithms  
    d) Defines iterators  
    **Answer**: b) Provides deque class  
    **Explanation**: It includes the deque container.

30. **What happens to deque iterators after `push_front`?**  
    a) Always valid  
    b) May be invalidated  
    c) Point to new elements  
    d) Cause compilation error  
    **Answer**: b) May be invalidated  
    **Explanation**: Front/back operations may invalidate iterators due to block reallocation.