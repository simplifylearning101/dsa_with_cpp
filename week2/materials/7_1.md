# Agenda: Advanced String Algorithms

## Outcome Expected:
By the end of this hour, students will master advanced string algorithms like KMP and Rabin-Karp, applying them to pattern matching and substring search problems. Students will combine these with array-based techniques (Week 2) and two-pointer/sliding window methods (Week 3, Hour 2) to solve complex interview problems efficiently, optimizing for time and space complexity.

## Topics Covered
1. KMP (Knuth-Morris-Pratt) Algorithm for Pattern Matching.  
2. Rabin-Karp Algorithm for Substring Search.  
3. Applications of Advanced String Algorithms in Interviews.  
4. Combining Array and String Techniques (e.g., Frequency Arrays with KMP).  
5. Edge Cases and Optimization Strategies.

## Detailed Explanation of Topics Covered

### 1. KMP (Knuth-Morris-Pratt) Algorithm
The KMP algorithm optimizes substring search by avoiding redundant comparisons using a prefix table (LPS - Longest Prefix Suffix).

Example (KMP Pattern Search):
```cpp
#include <iostream>
#include <vector>
#include <string>
std::vector<int> computeLPS(std::string pattern) {
    int m = pattern.length();
    std::vector<int> lps(m, 0);
    int len = 0, i = 1;
    while (i < m) {
        if (pattern[i] == pattern[len]) {
            lps[i++] = ++len;
        } else if (len != 0) {
            len = lps[len - 1];
        } else {
            lps[i++] = 0;
        }
    }
    return lps;
}
int KMPSearch(std::string text, std::string pattern) {
    int n = text.length(), m = pattern.length();
    std::vector<int> lps = computeLPS(pattern);
    int i = 0, j = 0;
    while (i < n) {
        if (text[i] == pattern[j]) {
            i++;
            j++;
        }
        if (j == m) return i - j;
        if (i < n && text[i] != pattern[j]) {
            if (j != 0) j = lps[j - 1];
            else i++;
        }
    }
    return -1;
}
int main() {
    std::string text = "ABABDABACDABABCABAB", pattern = "ABABCABAB";
    std::cout << KMPSearch(text, pattern) << std::endl; // Output: 10
    return 0;
}
```

### 2. Rabin-Karp Algorithm
Rabin-Karp uses rolling hash to find substrings, reducing comparison time for large texts.

Example (Rabin-Karp Substring Search):
```cpp
#include <iostream>
#include <string>
#define d 256 // Number of characters in input alphabet
int RabinKarp(std::string text, std::string pattern, int q) {
    int n = text.length(), m = pattern.length(), p = 0, t = 0, h = 1;
    for (int i = 0; i < m - 1; i++) h = (h * d) % q;
    for (int i = 0; i < m; i++) {
        p = (d * p + pattern[i]) % q;
        t = (d * t + text[i]) % q;
    }
    for (int i = 0; i <= n - m; i++) {
        if (p == t) {
            bool match = true;
            for (int j = 0; j < m; j++) {
                if (text[i + j] != pattern[j]) {
                    match = false;
                    break;
                }
            }
            if (match) return i;
        }
        if (i < n - m) {
            t = (d * (t - text[i] * h) + text[i + m]) % q;
            if (t < 0) t += q;
        }
    }
    return -1;
}
int main() {
    std::string text = "GEEKSFORGEEKS", pattern = "GEEK";
    std::cout << RabinKarp(text, pattern, 101) << std::endl; // Output: 0
    return 0;
}
```

### 3. Applications in Interviews
- **Substring Search**: KMP or Rabin-Karp for efficient matching.
- **Repeated Patterns**: Find repeated substrings or palindromes.
- **Anagram Substrings**: Combine with sliding window (Week 3, Hour 2).

### 4. Combining Array and String Techniques
Use frequency arrays or prefix sums (Week 2) with KMP for hybrid problems.

Example (Check Anagram Substrings with Sliding Window + KMP):
```cpp
#include <iostream>
#include <vector>
#include <string>
std::vector<int> findAnagrams(std::string s, std::string p) {
    std::vector<int> result;
    if (p.size() > s.size()) return result;
    int count[26] = {0}, window[26] = {0};
    for (char c : p) count[c - 'a']++;
    for (int i = 0; i < p.size(); i++) window[s[i] - 'a']++;
    if (std::equal(count, count + 26, window)) result.push_back(0);
    for (int i = p.size(); i < s.size(); i++) {
        window[s[i] - 'a']++;
        window[s[i - p.size()] - 'a']--;
        if (std::equal(count, count + 26, window)) result.push_back(i - p.size() + 1);
    }
    return result;
}
int main() {
    std::string s = "cbaebabacd", p = "abc";
    auto res = findAnagrams(s, p);
    for (int x : res) std::cout << x << " "; // Output: 0 6
    std::cout << std::endl;
    return 0;
}
```

### 5. Edge Cases and Optimization Strategies
- **Edge Cases**: Empty strings, single characters, no matches, or large patterns.
- **Optimizations**: Use KMP for O(n+m) time; Rabin-Karp for average-case efficiency.

**Cheatsheet:**
| Algorithm | Use Case | Time Complexity | Space Complexity |
|-----------|----------|-----------------|------------------|
| KMP | Substring Search | O(n+m) | O(m) |
| Rabin-Karp | Substring Search | O(n+m) avg, O(nm) worst | O(1) |
| Sliding Window + Frequency | Anagram Substrings | O(n) | O(1) |

## Points to Remember
- KMP uses LPS array to skip redundant comparisons, achieving O(n+m).
- Rabin-Karp uses rolling hash, effective for multiple pattern searches.
- Combine sliding window (Week 3, Hour 2) with KMP for hybrid problems.
- Time complexity: O(n+m) for KMP/Rabin-Karp; O(n) for sliding window.
- Space complexity: O(m) for KMP (LPS array); O(1) for Rabin-Karp.
- Common errors: Incorrect LPS computation, hash collisions in Rabin-Karp.
- Interview tip: Clarify pattern length, character set, and case sensitivity.
- Use `std::string` for dynamic operations (Week 3, Hour 1).