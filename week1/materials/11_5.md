# Deep Dive into C++ STL Unordered Maps and Multimaps

This document is an advanced exploration of STL `unordered_map` and `unordered_multimap` for students aiming to master these containers for coding interviews. It covers internals, advanced applications, and interview questions with detailed answers, building on Hours 1–10.

## Agenda
- Deep dive into `unordered_map` and `unordered_multimap` internals, operations, and optimizations.
- Illustrate complex scenarios with commented programs.
- Prepare for interviews with challenging questions and answers.

## Outcome Expected
Students will:
- Understand `unordered_map` and `unordered_multimap` internals (hash table).  
- Master advanced applications (e.g., frequency counting, two sum, caching).  
- Optimize performance and handle edge cases (e.g., hash collisions).  
- Answer complex interview questions confidently.

## Topics Covered
1. **Unordered Map Internals**  
   - Hash table structure and hashing mechanism.  
   - Performance characteristics (O(1) average, O(n) worst case).  
   - Real-world analogy: Unordered map as a dictionary with instant lookups.  
2. **Unordered Multimap Internals**  
   - Hash table structure with duplicate key support.  
   - Performance characteristics (O(1) average).  
   - Real-world analogy: Unordered multimap as a reverse index.  
3. **Advanced Applications**  
   - Frequency counting, two sum, and caching.  
   - Handling large datasets with hash-based containers.  
4. **Optimization and Pitfalls**  
   - Choosing `unordered_map` vs. `map`, `unordered_multimap` vs. `multimap`.  
   - Handling hash collisions and custom hash functions.

## Detailed Explanation

### 1. Unordered Map Internals
STL `unordered_map` is implemented as a hash table, storing unique key-value pairs with O(1) average-case complexity. Think of it as a dictionary with instant word lookups.

- **Structure**: Array of buckets, each containing a linked list for collisions.  
- **Performance**: O(1) average for `insert`, `erase`, `find`; O(n) worst case (collisions).  
- **Limitations**: Unordered; requires hashable keys.

**Example Program**: Custom hash function for unordered map.

```cpp
#include <iostream>
#include <unordered_map>
#include <string>
using namespace std;

struct CustomHash {
    size_t operator()(const string& s) const {
        size_t hash = 0;
        for (char c : s) {
            hash += c;
        }
        return hash;
    }
};

int main() {
    unordered_map<string, int, CustomHash> um;
    
    // Insert elements
    um["apple"] = 5; um["banana"] = 3;
    
    // Print size
    cout << "Size: " << um.size() << endl;  // Output: 2
    
    // Print elements
    cout << "Unordered map: ";
    for (const auto& pair : um) {
        cout << pair.first << ":" << pair.second << " ";  // Example output: banana:3 apple:5
    }
    cout << endl;
    
    return 0;
}
```

**Explanation**:  
- Custom hash function sums character values.  
- Hash table ensures O(1) average operations.

### 2. Unordered Multimap Internals
STL `unordered_multimap` uses a hash table, allowing duplicate keys. Think of it as a reverse index with multiple entries per key.

- **Structure**: Buckets with linked lists, supporting multiple pairs per hash.  
- **Performance**: O(1) average for operations.  
- **Limitations**: Unordered; no `operator[]` or `at`.

**Example Program**: Multi-value lookup with unordered multimap.

```cpp
#include <iostream>
#include <unordered_map>
#include <string>
using namespace std;

void printValues(const unordered_multimap<string, int>& umm, const string& key) {
    auto range = umm.equal_range(key);
    cout << "Values for " << key << ": ";
    for (auto it = range.first; it != range.second; ++it) {
        cout << it->second << " ";  // Output: 101 103
    }
    cout << endl;
}

int main() {
    unordered_multimap<string, int> umm;
    umm.insert({"apple", 101}); umm.insert({"apple", 103}); umm.insert({"banana", 102});
    printValues(umm, "apple");
    return 0;
}
```

**Explanation**:  
- `equal_range` retrieves all values for a key.  
- `count` checks number of occurrences.

### 3. Advanced Applications
Unordered maps and multimaps are ideal for problems requiring fast key-value lookups or duplicate key handling.

**Example Program**: Frequency counting.

```cpp
#include <iostream>
#include <unordered_map>
#include <vector>
using namespace std;

void printFrequency(const vector<int>& nums) {
    unordered_map<int, int> freq;
    for (int num : nums) {
        freq[num]++;
    }
    for (const auto& pair : freq) {
        cout << pair.first << ":" << pair.second << " ";  // Output: 1:2 2:1
    }
    cout << endl;
}

int main() {
    vector<int> nums = {1, 2, 1};
    printFrequency(nums);
    return 0;
}
```

**Explanation**:  
- `unordered_map` counts frequencies in O(n) average time.  
- Ideal for interview problems like finding most frequent elements.

### 4. Optimization and Pitfalls
- **Optimization**: Use `unordered_map` for fast lookups; `unordered_multimap` for duplicate keys.  
- **Pitfalls**: Handle hash collisions; avoid `operator[]` for read-only access (it inserts).

**Example Program**: Safe unordered map operations.

```cpp
#include <iostream>
#include <unordered_map>
#include <string>
using namespace std;

int main() {
    unordered_map<string, int> um;
    um["apple"] = 5;
    
    // Safe access with at()
    try {
        cout << "Apple count: " << um.at("apple") << endl;  // Output: 5
        cout << um.at("banana") << endl;  // Throws exception
    } catch (const out_of_range& e) {
        cout << "Key not found" << endl;  // Output: Key not found
    }
    
    // Safe find
    string key = "apple";
    auto it = um.find(key);
    if (it != um.end()) {
        it->second = 10;  // Modify value
        cout << "Updated apple: " << um[key] << endl;  // Output: 10
    }
    
    return 0;
}
```

**Explanation**:  
- Use `at` or `find` for safe access.  
- Modify values via iterator’s `second`.

## Interview Questions and Answers
Below are 15 advanced interview questions on unordered maps and multimaps.

1. **Question**: What is the primary difference between `unordered_map` and `map`?  
   **Answer**: `unordered_map` uses hash table (O(1) average); `map` uses red-black tree (O(log n), sorted).  
   **Interviewer’s Intention**: Tests container understanding.

2. **Question**: Why use a hash table for `unordered_map`?**  
   **Answer**: Enables O(1) average operations for fast lookups.  
   **Interviewer’s Intention**: Checks internal structure knowledge.

3. **Question**: What is the worst-case time complexity of `unordered_map::find`?**  
   **Answer**: O(n) due to hash collisions.  
   **Interviewer’s Intention**: Tests performance awareness.

4. **Question**: Write a program to count frequencies in an array.  
   **Answer**: (See above frequency example.)  
   **Interviewer’s Intention**: Tests `unordered_map` application.

5. **Question**: How do you handle duplicate keys in an `unordered_multimap`?**  
   **Answer**: Use `equal_range` or `count` for multiple values.  
   **Interviewer’s Intention**: Tests duplicate handling.

6. **Question**: What is the difference between `unordered_multimap` and `multimap`?**  
   **Answer**: `unordered_multimap` is hash-based (O(1) average); `multimap` is sorted (O(log n)).  
   **Interviewer’s Intention**: Tests container differences.

7. **Question**: Write a program to implement two sum.  
   **Answer**: (See LeetCode 1 solution below.)  
   **Interviewer’s Intention**: Tests key-value lookup.

8. **Question**: Why can’t you use `operator[]` in `unordered_multimap`?**  
   **Answer**: Duplicate keys make it ambiguous.  
   **Interviewer’s Intention**: Tests container limitations.

9. **Question**: When should you use `unordered_map` over `vector`?**  
   **Answer**: Use `unordered_map` for O(1) key-value lookups; `vector` for indexed access.  
   **Interviewer’s Intention**: Tests container selection.

10. **Question**: Write a program to check if strings are anagrams.  
    **Answer**: (See homework solution 10.)  
    **Interviewer’s Intention**: Tests string processing.

11. **Question**: What is the space complexity of `unordered_map`?**  
    **Answer**: O(n) for n key-value pairs.  
    **Interviewer’s Intention**: Tests complexity awareness.

12. **Question**: Write a program to implement an LRU cache.  
    **Answer**: (See LeetCode 146 solution below.)  
    **Interviewer’s Intention**: Tests advanced application.

13. **Question**: How do you create a custom hash function?**  
    **Answer**: Define a struct with `size_t operator()(const T&)` (see custom hash example).  
    **Interviewer’s Intention**: Tests advanced usage.

14. **Question**: What is a potential issue with `unordered_map`?**  
    **Answer**: Hash collisions can degrade performance to O(n).  
    **Interviewer’s Intention**: Tests optimization knowledge.

15. **Question**: Write a program to find the most frequent element.  
    **Answer**: (See homework solution 12.)  
    **Interviewer’s Intention**: Tests frequency analysis.

## Practice Recommendations
- Solve LeetCode problems like **Two Sum** and **LRU Cache**.  
- Experiment with custom hash functions.  
- Practice safe operations with `find`, `at`, and `equal_range`.