# Quiz: String Fundamentals and Array Connections

30 questions: 20 on string basics and array connections, 5 on advanced array techniques (Week 2, Hour 3), 5 on two-pointer basics (Week 2, Hour 2).

1. What is the difference between std::string and C-style strings?  
2. How can strings be treated as arrays in C++?  
3. Write code to check if a string is a palindrome.  
4. What is the time complexity of string concatenation?  
5. Write code to reverse a string in-place.  
6. How to check if two strings are anagrams?  
7. Write code to check if two strings are anagrams.  
8. What does std::string::find return if substring is not found?  
9. Write code to find the first occurrence of a substring.  
10. How to count occurrences of a character in a string?  
11. Write code to count occurrences of a character.  
12. True/False: std::string is immutable in C++.  
13. Write code to convert a string to lowercase.  
14. How to check if a string contains only digits?  
15. Write code to check if a string contains only digits.  
16. How to remove all occurrences of a character from a string?  
17. Write code to remove all occurrences of a character.  
18. What is the longest common prefix problem?  
19. Write code for longest common prefix.  
20. True/False: Two-pointer techniques apply to strings.  
21. (Advanced Arrays) What is Kadaneâ€™s algorithm used for?  
22. (Advanced Arrays) Write code for smallest subarray with sum >= k.  
23. (Advanced Arrays) How does prefix sum optimize range queries?  
24. (Advanced Arrays) Write code for subarrays with sum = k.  
25. (Advanced Arrays) Time complexity of max product subarray?  
26. (Two-Pointer) What are two types of two-pointer techniques?  
27. (Two-Pointer) Write code to remove duplicates from a sorted array.  
28. (Two-Pointer) Time complexity of pair sum in sorted array?  
29. (Two-Pointer) Write code to move zeros to the end.  
30. (Two-Pointer) Common error in two-pointer logic?

## Solutions for the Quiz

1. std::string is dynamic, resizable; C-style strings are null-terminated char arrays.  
2. Access via indexing (s[i]) or treat as char array.  
3. 
   ```cpp
   bool isPalindrome(std::string s) {
       int left = 0, right = s.length() - 1;
       while (left < right) {
           if (s[left++] != s[right--]) return false;
       }
       return true;
   }
   ```
4. O(n) for std::string concatenation.  
5. 
   ```cpp
   void reverseString(std::string& s) {
       int left = 0, right = s.length() - 1;
       while (left < right) std::swap(s[left++], s[right--]);
   }
   ```
6. Sort both strings or use frequency array.  
7. 
   ```cpp
   bool isAnagram(std::string s1, std::string s2) {
       if (s1.length() != s2.length()) return false;
       std::sort(s1.begin(), s1.end());
       std::sort(s2.begin(), s2.end());
       return s1 == s2;
   }
   ```
8. std::string::npos.  
9. 
   ```cpp
   int strStr(std::string haystack, std::string needle) {
       if (needle.empty()) return 0;
       for (int i = 0; i <= haystack.length() - needle.length(); i++) {
           if (haystack.substr(i, needle.length()) == needle) return i;
       }
       return -1;
   }
   ```
10. Iterate and count matching characters.  
11. 
   ```cpp
   int countChar(std::string s, char c) {
       int count = 0;
       for (char ch : s) if (ch == c) count++;
       return count;
   }
   ```
12. False, std::string is mutable.  
13. 
   ```cpp
   std::string toLowerCase(std::string s) {
       for (char& c : s) {
           if (c >= 'A' && c <= 'Z') c += 32;
       }
       return s;
   }
   ```
14. Check each character with isdigit().  
15. 
   ```cpp
   bool isDigitString(std::string s) {
       for (char c : s) if (!isdigit(c)) return false;
       return true;
   }
   ```
16. Use two-pointer or filter characters.  
17. 
   ```cpp
   std::string removeChar(std::string s, char c) {
       int write = 0;
       for (int read = 0; read < s.length(); read++) {
           if (s[read] != c) s[write++] = s[read];
       }
       return s.substr(0, write);
   }
   ```
18. Find longest prefix common to all strings in an array.  
19. 
   ```cpp
   std::string longestCommonPrefix(std::vector<std::string>& strs) {
       if (strs.empty()) return "";
       std::string prefix = strs[0];
       for (int i = 1; i < strs.size(); i++) {
           while (strs[i].find(prefix) != 0) {
               prefix = prefix.substr(0, prefix.length() - 1);
               if (prefix.empty()) return "";
           }
       }
       return prefix;
   }
   ```
20. True, e.g., palindrome check.  
21. Maximum subarray sum.  
22. 
   ```cpp
   int smallestSubarray(int arr[], int n, int k) {
       int sum = 0, minLen = n + 1, left = 0;
       for (int right = 0; right < n; right++) {
           sum += arr[right];
           while (sum >= k && left <= right) {
               minLen = std::min(minLen, right - left + 1);
               sum -= arr[left++];
           }
       }
       return minLen > n ? -1 : minLen;
   }
   ```
23. Precomputes sums for O(1) queries.  
24. 
   ```cpp
   int subarraySum(int arr[], int n, int k) {
       std::unordered_map<int, int> map;
       map[0] = 1;
       int sum = 0, count = 0;
       for (int i = 0; i < n; i++) {
           sum += arr[i];
           if (map.find(sum - k) != map.end()) count += map[sum - k];
           map[sum]++;
       }
       return count;
   }
   ```
25. O(n).  
26. Opposite ends, same direction.  
27. 
   ```cpp
   int removeDuplicates(int arr[], int n) {
       if (n <= 1) return n;
       int i = 0;
       for (int j = 1; j < n; j++) {
           if (arr[j] != arr[i]) arr[++i] = arr[j];
       }
       return i + 1;
   }
   ```
28. O(n) after O(n log n) sort.  
29. 
   ```cpp
   void moveZeroes(int arr[], int n) {
       int nonZeroPos = 0;
       for (int i = 0; i < n; i++) {
           if (arr[i] != 0) arr[nonZeroPos++] = arr[i];
       }
       while (nonZeroPos < n) arr[nonZeroPos++] = 0;
   }
   ```
30. Incorrect pointer updates or bounds checking.