# Project Quiz: Text Processing Tool

20 questions to test understanding of the project and related concepts.

1. What is the purpose of the KMP algorithm in the project?  
2. Write the LPS computation function for KMP.  
3. How does frequency counting help in anagram grouping?  
4. Write code to group anagrams.  
5. What is the expand-around-center technique?  
6. Write code for longest palindromic substring.  
7. How does in-place string compression work?  
8. Write code for string compression.  
9. True/False: KMP has O(n+m) time complexity.  
10. What is the role of file I/O in the project?  
11. Write code to read words from a file into a vector.  
12. How to handle empty input files?  
13. What is the time complexity of anagram grouping?  
14. Write code for Rabin-Karp as an alternative to KMP.  
15. True/False: Longest palindrome takes O(n^2) time with expand-around-center.  
16. How to optimize space in string compression?  
17. What are common edge cases in pattern matching?  
18. Write code to find all pattern matches using KMP.  
19. How does the project combine array and string techniques?  
20. What is the output format for anagram groups?

## Solutions for the Quiz

1. Efficiently find all occurrences of a pattern in text.  
2. 
   ```cpp
   std::vector<int> computeLPS(std::string pattern) {
       int m = pattern.length();
       std::vector<int> lps(m, 0);
       int len = 0, i = 1;
       while (i < m) {
           if (pattern[i] == pattern[len]) lps[i++] = ++len;
           else if (len != 0) len = lps[len - 1];
           else lps[i++] = 0;
       }
       return lps;
   }
   ```
3. Creates a unique key for anagrams based on character frequencies.  
4. 
   ```cpp
   std::vector<std::vector<std::string>> groupAnagrams(std::vector<std::string>& strs) {
       std::unordered_map<std::string, std::vector<std::string>> map;
       for (std::string s : strs) {
           std::vector<int> count(26, 0);
           for (char c : s) count[c - 'a']++;
           std::string key;
           for (int x : count) key += std::to_string(x) + "#";
           map[key].push_back(s);
       }
       std::vector<std::vector<std::string>> result;
       for (auto& pair : map) result.push_back(pair.second);
       return result;
   }
   ```
5. Expands around a center to find palindromes of odd and even lengths.  
6. 
   ```cpp
   std::string longestPalindrome(std::string s) {
       int n = s.length(), start = 0, maxLen = 1;
       for (int i = 0; i < n; i++) {
           int left = i, right = i;
           while (left >= 0 && right < n && s[left] == s[right]) {
               if (right - left + 1 > maxLen) {
                   start = left;
                   maxLen = right - left + 1;
               }
               left--; right++;
           }
           left = i; right = i + 1;
           while (left >= 0 && right < n && s[left] == s[right]) {
               if (right - left + 1 > maxLen) {
                   start = left;
                   maxLen = right - left + 1;
               }
               left--; right++;
           }
       }
       return s.substr(start, maxLen);
   }
   ```
7. Tracks consecutive characters and writes count in-place.  
8. 
   ```cpp
   std::string compress(std::string chars) {
       int n = chars.length(), write = 0, count = 1, start = 0;
       std::string result = chars;
       for (int i = 1; i <= n; i++) {
           if (i < n && chars[i] == chars[i - 1]) {
               count++;
           } else {
               result[write++] = chars[start];
               if (count > 1) {
                   std::string num = std::to_string(count);
                   for (char c : num) result[write++] = c;
               }
               start = i;
               count = 1;
           }
       }
       return result.substr(0, write);
   }
   ```
9. True.  
10. Reads text and words, writes processed results.  
11. 
   ```cpp
   std::vector<std::string> readWords(std::ifstream& inFile) {
       std::vector<std::string> words;
       std::string word;
       while (inFile >> word) words.push_back(word);
       return words;
   }
   ```
12. Check if file is empty or fails to open; return empty results.  
13. O(n*k) where n is number of words, k is max word length.  
14. 
   ```cpp
   std::vector<int> RabinKarp(std::string text, std::string pattern, int q) {
       int n = text.length(), m = pattern.length(), p = 0, t = 0, h = 1, d = 256;
       std::vector<int> result;
       for (int i = 0; i < m - 1; i++) h = (h * d) % q;
       for (int i = 0; i < m; i++) {
           p = (d * p + pattern[i]) % q;
           t = (d * t + text[i]) % q;
       }
       for (int i = 0; i <= n - m; i++) {
           if (p == t) {
               bool match = true;
               for (int j = 0; j < m; j++) {
                   if (text[i + j] != pattern[j]) { match = false; break; }
               }
               if (match) result.push_back(i);
           }
           if (i < n - m) {
               t = (d * (t - text[i] * h) + text[i + m]) % q;
               if (t < 0) t += q;
           }
       }
       return result;
   }
   ```
15. True.  
16. Use in-place operations to reduce space to O(1).  
17. Empty text, pattern longer than text, no matches.  
18. 
   ```cpp
   std::vector<int> KMPSearch(std::string text, std::string pattern) {
       int n = text.length(), m = pattern.length();
       std::vector<int> lps = computeLPS(pattern), result;
       int i = 0, j = 0;
       while (i < n) {
           if (text[i] == pattern[j]) { i++; j++; }
           if (j == m) { result.push_back(i - j); j = lps[j - 1]; }
           else if (i < n && text[i] != pattern[j]) {
               if (j != 0) j = lps[j - 1];
               else i++;
           }
       }
       return result;
   }
   ```
19. Uses frequency arrays for anagrams, sliding window for substring tasks.  
20. List of lists, each containing anagram groups.