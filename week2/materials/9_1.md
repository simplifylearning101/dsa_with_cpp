# Agenda: Review of Arrays and Strings

## Outcome Expected:
By the end of this hour, students will consolidate their understanding of arrays and strings, including key algorithms (two-pointer, sliding window, KMP, Rabin-Karp), optimization techniques, and common interview problems. Students will review cheatsheets, revisit critical programs, and reinforce logic for solving high-frequency interview questions.

## Topics Covered
1. Review of Array Concepts (Week 2).  
2. Review of String Concepts (Week 3).  
3. Cheatsheets for Arrays and Strings.  
4. Top 10 Interview Questions for Arrays and Strings.  
5. Review of Important Programs and Their Logic.

## Detailed Explanation of Topics Covered

### 1. Review of Array Concepts (Week 2)
- **Two-Pointer Technique** (Week 2, Hour 2): Used for problems like two-sum, removing duplicates, or merging arrays.  
  - Example: Two-sum (find indices of two numbers summing to target).
  - Time Complexity: O(n) with hash map, O(n log n) with sorting.
- **Sliding Window** (Week 2, Hour 3): Optimizes subarray problems like maximum sum or longest subarray.
  - Example: Maximum sum subarray (Kadane’s algorithm).
  - Time Complexity: O(n).
- **Frequency Counting** (Week 2, Hour 4): Use arrays or hash maps for counting elements.
  - Example: Group anagrams using frequency array.
  - Space Complexity: O(1) for fixed-size character sets.

### 2. Review of String Concepts (Week 3)
- **String Fundamentals** (Week 3, Hour 1): Operations like substring, concatenation, and palindrome checking.
  - Example: Longest common prefix.
- **Two-Pointer/Sliding Window for Strings** (Week 3, Hour 2): Used for substring problems like minimum window or longest substring with k distinct characters.
  - Example: Minimum window substring.
  - Time Complexity: O(n).
- **Advanced String Algorithms** (Week 3, Hour 3): KMP and Rabin-Karp for efficient pattern matching.
  - Example: KMP for substring search (O(n+m)).
- **String Optimization** (Week 3, Hour 4): In-place operations and dynamic programming.
  - Example: Edit distance (O(m*n)).

### 3. Cheatsheets for Arrays and Strings
**Array Cheatsheet:**
| Problem | Technique | Time Complexity | Space Complexity |
|---------|-----------|-----------------|------------------|
| Two-Sum | Hash Map | O(n) | O(n) |
| Merge Sorted Arrays | Two-Pointer | O(n+m) | O(1) |
| Maximum Subarray | Kadane’s | O(n) | O(1) |
| Group Anagrams | Frequency Array | O(n*k) | O(n) |

**String Cheatsheet:**
| Problem | Technique | Time Complexity | Space Complexity |
|---------|-----------|-----------------|------------------|
| KMP Pattern Search | LPS Array | O(n+m) | O(m) |
| Rabin-Karp | Rolling Hash | O(n+m) avg | O(1) |
| Minimum Window Substring | Sliding Window | O(n) | O(k) |
| Edit Distance | Dynamic Programming | O(m*n) | O(m*n) |

### 4. Top 10 Interview Questions
1. **Two-Sum** (Array): Find indices of two numbers summing to target.
2. **Maximum Subarray** (Array): Find subarray with maximum sum.
3. **Group Anagrams** (Array/String): Group strings that are anagrams.
4. **Longest Palindromic Substring** (String): Find longest palindrome.
5. **Minimum Window Substring** (String): Smallest substring containing all characters.
6. **Edit Distance** (String): Minimum operations to transform strings.
7. **Regular Expression Matching** (String): Match string with pattern.
8. **KMP Pattern Search** (String): Efficient substring search.
9. **String Compression** (String): Compress repeated characters in-place.
10. **Longest Valid Parentheses** (String): Longest valid parentheses substring.

### 5. Review of Important Programs
- **Two-Sum** (Week 2, Hour 2):
  ```cpp
  #include <vector>
  #include <unordered_map>
  std::vector<int> twoSum(std::vector<int>& nums, int target) {
      std::unordered_map<int, int> map;
      for (int i = 0; i < nums.size(); i++) {
          int complement = target - nums[i];
          if (map.count(complement)) return {map[complement], i};
          map[nums[i]] = i;
      }
      return {};
  }
  ```
  **Logic**: Use hash map to store number-index pairs, check for complement in O(1).

- **Maximum Subarray** (Week 2, Hour 3):
  ```cpp
  #include <vector>
  int maxSubArray(std::vector<int>& nums) {
      int maxSum = nums[0], currSum = nums[0];
      for (int i = 1; i < nums.size(); i++) {
          currSum = std::max(nums[i], currSum + nums[i]);
          maxSum = std::max(maxSum, currSum);
      }
      return maxSum;
  }
  ```
  **Logic**: Kadane’s algorithm tracks maximum sum ending at each index.

- **KMP Pattern Search** (Week 3, Hour 3):
  ```cpp
  #include <vector>
  #include <string>
  std::vector<int> computeLPS(std::string pattern) {
      int m = pattern.length();
      std::vector<int> lps(m, 0);
      int len = 0, i = 1;
      while (i < m) {
          if (pattern[i] == pattern[len]) lps[i++] = ++len;
          else if (len != 0) len = lps[len - 1];
          else lps[i++] = 0;
      }
      return lps;
  }
  int KMPSearch(std::string text, std::string pattern) {
      int n = text.length(), m = pattern.length();
      std::vector<int> lps = computeLPS(pattern);
      int i = 0, j = 0;
      while (i < n) {
          if (text[i] == pattern[j]) { i++; j++; }
          if (j == m) return i - j;
          if (i < n && text[i] != pattern[j]) {
              if (j != 0) j = lps[j - 1];
              else i++;
          }
      }
      return -1;
  }
  ```
  **Logic**: LPS array avoids redundant comparisons for O(n+m) time.

- **Edit Distance** (Week 3, Hour 4):
  ```cpp
  #include <string>
  #include <vector>
  int minDistance(std::string word1, std::string word2) {
      int m = word1.length(), n = word2.length();
      std::vector<std::vector<int>> dp(m + 1, std::vector<int>(n + 1, 0));
      for (int i = 0; i <= m; i++) dp[i][0] = i;
      for (int j = 0; j <= n; j++) dp[0][j] = j;
      for (int i = 1; i <= m; i++) {
          for (int j = 1; j <= n; j++) {
              if (word1[i - 1] == word2[j - 1]) dp[i][j] = dp[i - 1][j - 1];
              else dp[i][j] = std::min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;
          }
      }
      return dp[m][n];
  }
  ```
  **Logic**: DP table tracks minimum operations (insert, delete, replace).

## Points to Remember
- **Arrays**: Master two-pointer, sliding window, and frequency counting.
- **Strings**: Combine KMP, Rabin-Karp, sliding window, and DP for efficiency.
- **Common Errors**: Mishandling edge cases (empty inputs, single elements).
- **Interview Tips**: Clarify constraints, start with brute-force, then optimize.
- Use `std::vector` for arrays and `std::string` for strings in C++.