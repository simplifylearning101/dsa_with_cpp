# Project Deep Dive: Text Processing Tool

This deep dive explores the logic and implementation of the text processing tool.

## Key Components and Logic

### KMP Pattern Matching
**Logic**: Use LPS array to skip redundant comparisons, finding all pattern occurrences.
```cpp
std::vector<int> KMPSearch(std::string text, std::string pattern) {
    int n = text.length(), m = pattern.length();
    std::vector<int> lps = computeLPS(pattern), result;
    int i = 0, j = 0;
    while (i < n) {
        if (text[i] == pattern[j]) { i++; j++; }
        if (j == m) { result.push_back(i - j); j = lps[j - 1]; }
        else if (i < n && text[i] != pattern[j]) {
            if (j != 0) j = lps[j - 1];
            else i++;
        }
    }
    return result;
}
```
**Complexity**: O(n+m) time, O(m) space.

### Anagram Grouping
**Logic**: Create a frequency-based key for each word to group anagrams.
```cpp
std::vector<std::vector<std::string>> groupAnagrams(std::vector<std::string>& strs) {
    std::unordered_map<std::string, std::vector<std::string>> map;
    for (std::string s : strs) {
        std::vector<int> count(26, 0);
        for (char c : s) count[c - 'a']++;
        std::string key;
        for (int x : count) key += std::to_string(x) + "#";
        map[key].push_back(s);
    }
    std::vector<std::vector<std::string>> result;
    for (auto& pair : map) result.push_back(pair.second);
    return result;
}
```
**Complexity**: O(n*k) time, O(n) space.

### Longest Palindromic Substring
**Logic**: Expand around each index and between indices to find the longest palindrome.
```cpp
std::string longestPalindrome(std::string s) {
    int n = s.length(), start = 0, maxLen = 1;
    for (int i = 0; i < n; i++) {
        int left = i, right = i;
        while (left >= 0 && right < n && s[left] == s[right]) {
            if (right - left + 1 > maxLen) {
                start = left;
                maxLen = right - left + 1;
            }
            left--; right++;
        }
        left = i; right = i + 1;
        while (left >= 0 && right < n && s[left] == s[right]) {
            if (right - left + 1 > maxLen) {
                start = left;
                maxLen = right - left + 1;
            }
            left--; right++;
        }
    }
    return s.substr(start, maxLen);
}
```
**Complexity**: O(n^2) time, O(1) space.

### String Compression
**Logic**: Count consecutive characters and write compressed result.
```cpp
std::string compress(std::string chars) {
    int n = chars.length(), write = 0, count = 1, start = 0;
    std::string result = chars;
    for (int i = 1; i <= n; i++) {
        if (i < n && chars[i] == chars[i - 1]) {
            count++;
        } else {
            result[write++] = chars[start];
            if (count > 1) {
                std::string num = std::to_string(count);
                for (char c : num) result[write++] = c;
            }
            start = i;
            count = 1;
        }
    }
    return result.substr(0, write);
}
```
**Complexity**: O(n) time, O(1) space (excluding output).

## Interview Insights
- **KMP**: Explain LPS array’s role in avoiding backtracking.
- **Anagrams**: Frequency array vs. sorting trade-off (O(n*k) vs. O(n*k*log k)).
- **Palindrome**: Expand-around-center vs. Manacher’s algorithm.
- **Compression**: In-place operations reduce space complexity.
- **Pitfalls**: Mishandling file I/O, empty inputs, or case sensitivity.