# Hour 3 LeetCode Problem: Longest Substring Without Repeating Characters

This document illustrates **LeetCode 3: Longest Substring Without Repeating Characters**, a medium problem that leverages STL strings and sliding window techniques. It includes the problem description, coding pattern, brute-force and optimized solutions, complexity analysis, and test cases.

## Problem Statement: LeetCode 3 - Longest Substring Without Repeating Characters
**Link**: [LeetCode 3](https://leetcode.com/problems/longest-substring-without-repeating-characters/)

**Description**:  
Given a string `s`, find the length of the longest substring without repeating characters.

**Constraints**:
- `0 <= s.length <= 5 * 10^4`
- `s` consists of English letters, digits, symbols, and spaces.

**Example**:
- Input: `s = "abcabcbb"`  
  Output: `3`  
  Explanation: The longest substring is "abc" (length 3).

**Real-World Analogy**: Imagine scanning a book for the longest section of text where no letter repeats, like finding a unique sequence of characters in a story.

## Coding Pattern: Sliding Window with Hash Set
- Use a sliding window with two pointers (`left`, `right`).
- Maintain a set to track unique characters in the window.
- Shrink the window when a duplicate is found.

## Brute-Force Solution
**Algorithm**:
1. Check all possible substrings using nested loops.
2. For each substring, verify no repeating characters.
3. Track the maximum length.

**Code**:
```cpp
#include <string>
#include <unordered_set>
using namespace std;

class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int max_len = 0;
        // Check all substrings
        for (size_t i = 0; i < s.size(); ++i) {
            unordered_set<char> seen;
            for (size_t j = i; j < s.size(); ++j) {
                if (seen.count(s[j])) break; // Duplicate found
                seen.insert(s[j]);
                max_len = max(max_len, (int)(j - i + 1));
            }
        }
        return max_len;
    }
};
```

**Time Complexity**: O(n^2)  
- Nested loops check each substring: O(n^2).
- Set operations are O(1) per character.

**Space Complexity**: O(min(m, n)), where m is charset size  
- Set stores unique characters in a substring.

**Why It’s Not Optimal**: O(n^2) is too slow for large strings.

## Optimized Solution (Sliding Window)
**Algorithm**:
1. Use two pointers (`left`, `right`) for the window.
2. Use a set to track characters in the window.
3. Move `right` to expand; if duplicate found, shrink window by moving `left`.
4. Track maximum window size.

**Code**:
```cpp
#include <string>
#include <unordered_set>
using namespace std;

class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        unordered_set<char> seen;
        int max_len = 0, left = 0;
        
        // Slide window with right pointer
        for (int right = 0; right < s.size(); ++right) {
            // Shrink window while duplicate exists
            while (seen.count(s[right])) {
                seen.erase(s[left]);
                left++;
            }
            seen.insert(s[right]);
            max_len = max(max_len, right - left + 1);
        }
        
        return max_len;
    }
};
```

**Time Complexity**: O(n)  
- Each character is visited at most twice (by `left` and `right`): O(2n) = O(n).
- Set operations are O(1).

**Space Complexity**: O(min(m, n)), where m is charset size  
- Set stores unique characters in the window.

**Explanation**:
- `left` and `right` define the window.
- `seen` tracks characters; duplicates trigger window shrinking.
- `max_len` updates with the largest valid window.

## Test Cases
1. **Typical Case**: `s = "abcabcbb"` → Output: `3` ("abc")  
2. **No Repeats**: `s = "abcde"` → Output: `5`  
3. **All Repeats**: `s = "aaaaa"` → Output: `1`  
4. **Empty String**: `s = ""` → Output: `0`  
5. **Single Character**: `s = "a"` → Output: `1`  
6. **Spaces and Symbols**: `s = "pww kew"` → Output: `3` ("kew")  

**Test Case Implementation**:
```cpp
#include <iostream>
#include <string>
#include <unordered_set>
using namespace std;

int lengthOfLongestSubstring(string s) {
    unordered_set<char> seen;
    int max_len = 0, left = 0;
    for (int right = 0; right < s.size(); ++right) {
        while (seen.count(s[right])) {
            seen.erase(s[left]);
            left++;
        }
        seen.insert(s[right]);
        max_len = max(max_len, right - left + 1);
    }
    return max_len;
}

int main() {
    // Test cases
    cout << "Test 1: " << lengthOfLongestSubstring("abcabcbb") << endl; // 3
    cout << "Test 2: " << lengthOfLongestSubstring("abcde") << endl; // 5
    cout << "Test 3: " << lengthOfLongestSubstring("aaaaa") << endl; // 1
    cout << "Test 4: " << lengthOfLongestSubstring("") << endl; // 0
    cout << "Test 5: " << lengthOfLongestSubstring("a") << endl; // 1
    cout << "Test 6: " << lengthOfLongestSubstring("pww kew") << endl; // 3
    
    return 0;
}
```

**Output**:
```
Test 1: 3
Test 2: 5
Test 3: 1
Test 4: 0
Test 5: 1
Test 6: 3
```

## Optimization Mindset
- **Brute-Force**: O(n^2) checks all substrings, inefficient for large inputs.  
- **Optimized**: Sliding window with set reduces to O(n).  
- **Key Insight**: Use set to track duplicates efficiently; slide window to avoid redundant checks.  
- **Edge Cases**: Handle empty strings, single characters, and special characters.