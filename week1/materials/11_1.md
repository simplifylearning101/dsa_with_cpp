# Hour 11: Unordered Map and Unordered Multimap in STL

**Agenda**: Introduce students to C++ STL `unordered_map` and `unordered_multimap`, building on their understanding of vectors (Hour 1), arrays/deques (Hour 2), strings (Hour 3), stacks (Hour 4), queues (Hour 5), priority queues (Hour 6), sets (Hour 7), maps (Hour 8), multisets/multimaps (Hour 9), and unordered sets/multisets (Hour 10). Use real-world analogies and fully commented programs to simplify concepts. Emphasize practical usage, operations, and preparation for coding interviews.

**Outcome Expected**:  
By the end of this hour, students will:  
- Understand STL `unordered_map` (hash-based key-value container for unique keys) and `unordered_multimap` (hash-based, allows duplicate keys).  
- Master operations like `insert`, `erase`, `find`, `count`, and `operator[]`.  
- Compare `unordered_map` with `map` and `unordered_multimap` with `multimap`.  
- Write C++ programs using unordered maps and multimaps with proper syntax.  
- Be ready to solve LeetCode problems involving key-value lookups and frequency counting.

## Topics Covered
1. **STL Unordered Map: Hash-Based Key-Value Container**  
   - Declaration, initialization, and basic operations.  
   - Underlying structure: Hash table.  
   - Real-world analogy: Unordered map as a dictionary with instant word lookups.  
2. **STL Unordered Multimap: Hash-Based with Duplicate Keys**  
   - Declaration, initialization, and operations.  
   - Underlying structure: Hash table.  
   - Real-world analogy: Unordered multimap as a reverse index with multiple entries per key.  
3. **Unordered Map and Multimap Operations**  
   - `insert`, `erase`, `find`, `count`, `at`, `operator[]`, `size`, `empty`, `clear`.  
   - Iterating over unordered maps and multimaps.  
4. **Comparison with Map and Multimap**  
   - Unordered map vs. map (unordered vs. sorted, O(1) vs. O(log n)).  
   - Unordered multimap vs. multimap (duplicates with hashing vs. sorting).  

## Detailed Explanation of Topics Covered

### 1. STL Unordered Map: Hash-Based Key-Value Container
The STL `unordered_map` is a container that stores key-value pairs with unique keys using a hash table, providing O(1) average-case complexity for operations. Think of an `unordered_map` as a dictionary where each word (key) maps to a definition (value) with instant lookup.

**Key Features**:  
- **Declaration**: `unordered_map<Key, T> um;` (e.g., `unordered_map<string, int>` for word counts).  
- **Initialization**: Insert pairs, use `operator[]` for unique keys.  
- **Operations**: `insert`, `erase`, `find`, `count`, `at`, `operator[]`, `size`, `empty`, `clear`.  
- **Advantages**: O(1) average for insert/erase/find; fast key-value lookups.  
- **Limitations**: Unordered elements; requires hashable keys.

**Example Program**: Basic unordered map operations.

```cpp
#include <iostream>
#include <unordered_map>
#include <string>
using namespace std;

int main() {
    // Declare unordered_map
    unordered_map<string, int> word_count;

    // Insert elements
    word_count["apple"] = 5;  // O(1) average
    word_count.insert({"banana", 3});  // O(1) average
    word_count["apple"] = 7;  // Updates value

    // Print size
    cout << "Size: " << word_count.size() << endl;  // Output: 2

    // Print elements (order not guaranteed)
    cout << "Word counts: ";
    for (const auto& pair : word_count) {
        cout << pair.first << ":" << pair.second << " ";  // Example output: banana:3 apple:7
    }
    cout << endl;

    // Check if key exists
    cout << "Find apple: " << (word_count.find("apple") != word_count.end() ? "Found" : "Not found") << endl;  // Output: Found

    // Access value
    cout << "Apple count: " << word_count["apple"] << endl;  // Output: 7

    // Erase key
    word_count.erase("banana");
    cout << "After erasing banana, size: " << word_count.size() << endl;  // Output: 1

    return 0;
}
```

**Explanation**:  
- `#include <unordered_map>`: Imports the unordered map library.  
- `operator[]`: Inserts or updates key-value pair (O(1) average).  
- `find`: Returns iterator to pair or `end()` (O(1) average).  
- `erase`: Removes key-value pair (O(1) average).  
- Elements are unordered due to hashing.

### 2. STL Unordered Multimap: Hash-Based with Duplicate Keys
The STL `unordered_multimap` stores key-value pairs in a hash table, allowing duplicate keys, with O(1) average-case complexity. Think of it as a reverse index where a keyword can map to multiple documents.

**Key Features**:  
- **Declaration**: `unordered_multimap<Key, T> umm;` (e.g., `unordered_multimap<string, int>`).  
- **Operations**: `insert`, `erase`, `find`, `count`, `size`, `empty`, `clear`.  
- **Advantages**: O(1) average for operations; supports duplicate keys.  
- **Limitations**: Unordered; no `operator[]` or `at` (due to duplicates).

**Example Program**: Unordered multimap operations.

```cpp
#include <iostream>
#include <unordered_map>
#include <string>
using namespace std;

int main() {
    // Declare unordered_multimap
    unordered_multimap<string, int> keyword_docs;

    // Insert elements (duplicates allowed)
    keyword_docs.insert({"apple", 101});  // O(1) average
    keyword_docs.insert({"banana", 102});
    keyword_docs.insert({"apple", 103});  // Duplicate key

    // Print size
    cout << "Size: " << keyword_docs.size() << endl;  // Output: 3

    // Print elements (order not guaranteed)
    cout << "Keyword mappings: ";
    for (const auto& pair : keyword_docs) {
        cout << pair.first << ":" << pair.second << " ";  // Example output: apple:101 banana:102 apple:103
    }
    cout << endl;

    // Count occurrences of a key
    cout << "Count of apple: " << keyword_docs.count("apple") << endl;  // Output: 2

    // Find all values for a key
    auto range = keyword_docs.equal_range("apple");
    cout << "Documents for apple: ";
    for (auto it = range.first; it != range.second; ++it) {
        cout << it->second << " ";  // Output: 101 103
    }
    cout << endl;

    // Erase one occurrence
    auto it = keyword_docs.find("apple");
    if (it != keyword_docs.end()) {
        keyword_docs.erase(it);
        cout << "After erasing one apple, size: " << keyword_docs.size() << endl;  // Output: 2
    }

    return 0;
}
```

**Explanation**:  
- `#include <unordered_map>`: Imports `unordered_multimap`.  
- `count(key)`: Returns number of key occurrences (O(1) average).  
- `equal_range(key)`: Returns range of iterators for key.  
- `erase(iterator)`: Removes one occurrence; `erase(key)` removes all.

### 3. Unordered Map and Multimap Operations
Both `unordered_map` and `unordered_multimap` support operations for managing key-value pairs with O(1) average-case complexity.

**Key Operations**:  
- `insert({key, value})`: Adds pair (O(1) average).  
- `erase(iterator)` or `erase(key)`: Removes pair(s).  
- `find(key)`: Returns iterator to first occurrence or `end()`.  
- `count(key)`: Returns number of occurrences (0 or 1 for `unordered_map`).  
- `at(key)` (map only): Accesses value, throws if key not found.  
- `operator[]` (map only): Accesses or inserts key-value pair.  
- `size()`: Number of pairs.  
- `empty()`: Checks if container is empty.  
- `clear()`: Removes all pairs.

**Example Program**: Comparing unordered map and multimap.

```cpp
#include <iostream>
#include <unordered_map>
#include <string>
using namespace std;

int main() {
    // Unordered map
    unordered_map<string, int> um;
    um["apple"] = 1; um["apple"] = 2; um["banana"] = 3;
    cout << "Unordered map: ";
    for (const auto& pair : um) {
        cout << pair.first << ":" << pair.second << " ";  // Example output: banana:3 apple:2
    }
    cout << endl;
    cout << "Count of apple: " << um.count("apple") << endl;  // Output: 1

    // Unordered multimap
    unordered_multimap<string, int> umm;
    umm.insert({"apple", 1}); umm.insert({"apple", 2}); umm.insert({"banana", 3});
    cout << "Unordered multimap: ";
    for (const auto& pair : umm) {
        cout << pair.first << ":" << pair.second << " ";  // Example output: apple:1 apple:2 banana:3
    }
    cout << endl;
    cout << "Count of apple: " << umm.count("apple") << endl;  // Output: 2

    return 0;
}
```

**Explanation**:  
- `unordered_map` updates values for duplicate keys; `unordered_multimap` allows multiple pairs.  
- Order of elements is not guaranteed.

### 4. Comparison with Map and Multimap
- **Unordered Map vs. Map**: `unordered_map` uses hash table (O(1) average); `map` uses red-black tree (O(log n), sorted).  
- **Unordered Multimap vs. Multimap**: `unordered_multimap` allows duplicate keys with hashing; `multimap` sorts keys.

**Example Program**: Unordered map vs. map.

```cpp
#include <iostream>
#include <unordered_map>
#include <map>
#include <string>
using namespace std;

int main() {
    // Unordered map
    unordered_map<string, int> um;
    um["banana"] = 3; um["apple"] = 1;
    cout << "Unordered map size: " << um.size() << endl;  // Output: 2
    cout << "Unordered map: ";
    for (const auto& pair : um) {
        cout << pair.first << ":" << pair.second << " ";  // Example output: banana:3 apple:1
    }
    cout << endl;

    // Map
    map<string, int> m;
    m["banana"] = 3; m["apple"] = 1;
    cout << "Map size: " << m.size() << endl;  // Output: 2
    cout << "Map: ";
    for (const auto& pair : m) {
        cout << pair.first << ":" << pair.second << " ";  // Output: apple:1 banana:3
    }
    cout << endl;

    return 0;
}
```

**Explanation**:  
- `unordered_map`: Unordered, O(1) average.  
- `map`: Sorted by key, O(log n).

## Points to Remember (Interview Preparation)
1. **Unordered Map**: Hash-based, unique keys, O(1) average operations.  
2. **Unordered Multimap**: Hash-based, allows duplicate keys, O(1) average operations.  
3. **Time Complexities**:  
   - `insert`, `erase`, `find`, `count`: O(1) average, O(n) worst case (hash collisions).  
4. **Use Cases**: `unordered_map` for fast key-value lookups; `unordered_multimap` for multiple values per key.  
5. **Safety**: Check `find` results against `end()`; use `at` to avoid unintended insertions with `operator[]`.  
6. **Interview Questions**: Be ready for problems like two sum, frequency counting, or caching.  
7. **Common Errors**: Avoid assuming sorted order; ensure keys are hashable.