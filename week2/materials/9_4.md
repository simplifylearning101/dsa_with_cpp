# Quiz: Review of Arrays and Strings

30 questions: 15 on arrays (Week 2), 15 on strings (Week 3).

1. What is the two-pointer technique for arrays?  
2. Write code for two-sum.  
3. What is Kadane’s algorithm?  
4. Write code for maximum subarray.  
5. How to optimize group anagrams?  
6. Write code for group anagrams.  
7. True/False: Two-pointer always uses O(1) space.  
8. What is sliding window for arrays?  
9. Write code for maximum sum subarray of size k.  
10. How to handle duplicates in an array?  
11. Write code to remove duplicates from sorted array.  
12. What is frequency counting in arrays?  
13. Write code to find top k frequent elements.  
14. True/False: Kadane’s algorithm is O(n) time.  
15. Write code to merge two sorted arrays.  
16. What is the purpose of KMP algorithm?  
17. Write code for KMP pattern search.  
18. What is Rabin-Karp’s advantage?  
19. Write code for Rabin-Karp.  
20. How to find the longest palindromic substring?  
21. Write code for longest palindromic substring.  
22. What is minimum window substring?  
23. Write code for minimum window substring.  
24. True/False: Edit distance uses O(m*n) time.  
25. Write code for edit distance.  
26. What is regular expression matching?  
27. Write code for regular expression matching.  
28. How to optimize string compression?  
29. Write code for string compression.  
30. Write code for longest valid parentheses.

## Solutions for the Quiz

1. Uses two pointers to traverse array, reducing time complexity.  
2. 
   ```cpp
   std::vector<int> twoSum(std::vector<int>& nums, int target) {
       std::unordered_map<int, int> map;
       for (int i = 0; i < nums.size(); i++) {
           int complement = target - nums[i];
           if (map.count(complement)) return {map[complement], i};
           map[nums[i]] = i;
       }
       return {};
   }
   ```
3. Finds maximum sum subarray in O(n) time.  
4. 
   ```cpp
   int maxSubArray(std::vector<int>& nums) {
       int maxSum = nums[0], currSum = nums[0];
       for (int i = 1; i < nums.size(); i++) {
           currSum = std::max(nums[i], currSum + nums[i]);
           maxSum = std::max(maxSum, currSum);
       }
       return maxSum;
   }
   ```
5. Use frequency array instead of sorting.  
6. 
   ```cpp
   std::vector<std::vector<std::string>> groupAnagrams(std::vector<std::string>& strs) {
       std::unordered_map<std::string, std::vector<std::string>> map;
       for (std::string s : strs) {
           std::vector<int> count(26, 0);
           for (char c : s) count[c - 'a']++;
           std::string key;
           for (int x : count) key += std::to_string(x) + "#";
           map[key].push_back(s);
       }
       std::vector<std::vector<std::string>> result;
       for (auto& pair : map) result.push_back(pair.second);
       return result;
   }
   ```
7. True, excluding hash maps or temporary variables.  
8. Maintains dynamic window for subarray problems.  
9. 
   ```cpp
   int maxSumSubarrayK(std::vector<int>& nums, int k) {
       int maxSum = 0, currSum = 0;
       for (int i = 0; i < k; i++) currSum += nums[i];
       maxSum = currSum;
       for (int i = k; i < nums.size(); i++) {
           currSum += nums[i] - nums[i - k];
           maxSum = std::max(maxSum, currSum);
       }
       return maxSum;
   }
   ```
10. Use hash set or two-pointer for sorted arrays.  
11. 
   ```cpp
   int removeDuplicates(std::vector<int>& nums) {
       if (nums.empty()) return 0;
       int write = 1;
       for (int i = 1; i < nums.size(); i++) {
           if (nums[i] != nums[write - 1]) nums[write++] = nums[i];
       }
       return write;
   }
   ```
12. Count occurrences using array or hash map.  
13. 
   ```cpp
   #include <queue>
   std::vector<int> topKFrequent(std::vector<int>& nums, int k) {
       std::unordered_map<int, int> count;
       for (int num : nums) count[num]++;
       std::priority_queue<std::pair<int, int>> pq;
       for (auto& pair : count) pq.push({pair.second, pair.first});
       std::vector<int> result;
       while (k--) {
           result.push_back(pq.top().second);
           pq.pop();
       }
       return result;
   }
   ```
14. True.  
15. 
   ```cpp
   void merge(std::vector<int>& nums1, int m, std::vector<int>& nums2, int n) {
       int p1 = m - 1, p2 = n - 1, p = m + n - 1;
       while (p2 >= 0 && p1 >= 0) {
           nums1[p--] = nums1[p1] > nums2[p2] ? nums1[p1--] : nums2[p2--];
       }
       while (p2 >= 0) nums1[p--] = nums2[p2--];
   }
   ```
16. Efficient substring search with O(n+m) time.  
17. 
   ```cpp
   int KMPSearch(std::string text, std::string pattern) {
       int n = text.length(), m = pattern.length();
       std::vector<int> lps(m, 0);
       int len = 0, i = 1;
       while (i < m) {
           if (pattern[i] == pattern[len]) lps[i++] = ++len;
           else if (len != 0) len = lps[len - 1];
           else lps[i++] = 0;
       }
       i = 0; int j = 0;
       while (i < n) {
           if (text[i] == pattern[j]) { i++; j++; }
           if (j == m) return i - j;
           if (i < n && text[i] != pattern[j]) {
               if (j != 0) j = lps[j - 1];
               else i++;
           }
       }
       return -1;
   }
   ```
18. Rolling hash for average-case O(n+m).  
19. 
   ```cpp
   int RabinKarp(std::string text, std::string pattern, int q) {
       int n = text.length(), m = pattern.length(), p = 0, t = 0, h = 1, d = 256;
       for (int i = 0; i < m - 1; i++) h = (h * d) % q;
       for (int i = 0; i < m; i++) {
           p = (d * p + pattern[i]) % q;
           t = (d * t + text[i]) % q;
       }
       for (int i = 0; i <= n - m; i++) {
           if (p == t) {
               bool match = true;
               for (int j = 0; j < m; j++) {
                   if (text[i + j] != pattern[j]) { match = false; break; }
               }
               if (match) return i;
           }
           if (i < n - m) {
               t = (d * (t - text[i] * h) + text[i + m]) % q;
               if (t < 0) t += q;
           }
       }
       return -1;
   }
   ```
20. Expand around center or use Manacher’s algorithm.  
21. 
   ```cpp
   std::string longestPalindrome(std::string s) {
       int n = s.length(), start = 0, maxLen = 1;
       for (int i = 0; i < n; i++) {
           int left = i, right = i;
           while (left >= 0 && right < n && s[left] == s[right]) {
               if (right - left + 1 > maxLen) {
                   start = left;
                   maxLen = right - left + 1;
               }
               left--; right++;
           }
           left = i; right = i + 1;
           while (left >= 0 && right < n && s[left] == s[right]) {
               if (right - left + 1 > maxLen) {
                   start = left;
                   maxLen = right - left + 1;
               }
               left--; right++;
           }
       }
       return s.substr(start, maxLen);
   }
   ```
22. Find smallest substring containing all characters of another string.  
23. 
   ```cpp
   std::string minWindow(std::string s, std::string t) {
       std::unordered_map<char, int> tMap, sMap;
       for (char c : t) tMap[c]++;
       int required = tMap.size(), formed = 0, left = 0, minLen = s.size() + 1, minLeft = 0;
       for (int right = 0; right < s.size(); right++) {
           sMap[s[right]]++;
           if (tMap.count(s[right]) && sMap[s[right]] == tMap[s[right]]) formed++;
           while (formed == required && left <= right) {
               if (right - left + 1 < minLen) {
                   minLen = right - left + 1;
                   minLeft = left;
               }
               sMap[s[left]]--;
               if (tMap.count(s[left]) && sMap[s[left]] < tMap[s[left]]) formed--;
               left++;
           }
       }
       return minLen > s.size() ? "" : s.substr(minLeft, minLen);
   }
   ```
24. True.  
25. 
   ```cpp
   int minDistance(std::string word1, std::string word2) {
       int m = word1.length(), n = word2.length();
       std::vector<std::vector<int>> dp(m + 1, std::vector<int>(n + 1, 0));
       for (int i = 0; i <= m; i++) dp[i][0] = i;
       for (int j = 0; j <= n; j++) dp[0][j] = j;
       for (int i = 1; i <= m; i++) {
           for (int j = 1; j <= n; j++) {
               if (word1[i - 1] == word2[j - 1]) dp[i][j] = dp[i - 1][j - 1];
               else dp[i][j] = std::min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;
           }
       }
       return dp[m][n];
   }
   ```
26. Match string with pattern using '.' and '*'.  
27. 
   ```cpp
   bool isMatch(std::string s, std::string p) {
       int m = s.length(), n = p.length();
       std::vector<std::vector<bool>> dp(m + 1, std::vector<bool>(n + 1, false));
       dp[0][0] = true;
       for (int j = 1; j <= n; j++) {
           if (p[j - 1] == '*') dp[0][j] = dp[0][j - 2];
       }
       for (int i = 1; i <= m; i++) {
           for (int j = 1; j <= n; j++) {
               if (p[j - 1] == '*') {
                   dp[i][j] = dp[i][j - 2] || (dp[i - 1][j] && (s[i - 1] == p[j - 2] || p[j - 2] == '.'));
               } else if (p[j - 1] == '.' || s[i - 1] == p[j - 1]) {
                   dp[i][j] = dp[i - 1][j - 1];
               }
           }
       }
       return dp[m][n];
   }
   ```
28. Use in-place operations to reduce space.  
29. 
   ```cpp
   int compress(std::vector<char>& chars) {
       int n = chars.size(), write = 0, count = 1, start = 0;
       for (int i = 1; i <= n; i++) {
           if (i < n && chars[i] == chars[i - 1]) {
               count++;
           } else {
               chars[write++] = chars[start];
               if (count > 1) {
                   std::string num = std::to_string(count);
                   for (char c : num) chars[write++] = c;
               }
               start = i;
               count = 1;
           }
       }
       return write;
   }
   ```
30. 
   ```cpp
   int longestValidParentheses(std::string s) {
       std::stack<int> stack;
       stack.push(-1);
       int maxLen = 0;
       for (int i = 0; i < s.length(); i++) {
           if (s[i] == '(') {
               stack.push(i);
           } else {
               stack.pop();
               if (stack.empty()) {
                   stack.push(i);
               } else {
                   maxLen = std::max(maxLen, i - stack.top());
               }
           }
       }
       return maxLen;
   }
   ```