# Agenda: String Optimization and Common Interview Problems

## Outcome Expected:
By the end of this hour, students will master optimization techniques for string problems, including space and time efficiency, and solve common interview questions like regular expression matching, string compression, and edit distance. Students will integrate array techniques (Week 2) and advanced string algorithms (Week 3, Hour 3) to tackle complex problems.

## Topics Covered
1. Space and Time Optimization for Strings.  
2. Common String Interview Problems (e.g., Regular Expression, Edit Distance).  
3. Combining Array and String Techniques for Optimization.  
4. Handling Edge Cases in String Problems.  
5. Practical Interview Strategies for String Questions.

## Detailed Explanation of Topics Covered

### 1. Space and Time Optimization for Strings
- **Space Optimization**: Use in-place operations or fixed-size arrays (e.g., 26 for lowercase letters).
- **Time Optimization**: Leverage KMP, Rabin-Karp (Week 3, Hour 3), or sliding window (Week 3, Hour 2).

Example (String Compression - In-Place):
```cpp
#include <iostream>
#include <string>
int compress(std::string& chars) {
    int n = chars.length(), write = 0, count = 1, start = 0;
    for (int i = 1; i <= n; i++) {
        if (i < n && chars[i] == chars[i - 1]) {
            count++;
        } else {
            chars[write++] = chars[start];
            if (count > 1) {
                std::string num = std::to_string(count);
                for (char c : num) chars[write++] = c;
            }
            start = i;
            count = 1;
        }
    }
    return write;
}
int main() {
    std::string s = "aabbccc";
    int len = compress(s);
    for (int i = 0; i < len; i++) std::cout << s[i]; // Output: a2b2c3
    std::cout << std::endl;
    return 0;
}
```

### 2. Common String Interview Problems
- **Regular Expression Matching**: Use dynamic programming for pattern matching.
- **Edit Distance**: Compute minimum operations to transform one string to another.
- **String Compression**: Compress repeated characters in-place.

Example (Edit Distance):
```cpp
#include <iostream>
#include <string>
#include <vector>
int minDistance(std::string word1, std::string word2) {
    int m = word1.length(), n = word2.length();
    std::vector<std::vector<int>> dp(m + 1, std::vector<int>(n + 1, 0));
    for (int i = 0; i <= m; i++) dp[i][0] = i;
    for (int j = 0; j <= n; j++) dp[0][j] = j;
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (word1[i - 1] == word2[j - 1]) dp[i][j] = dp[i - 1][j - 1];
            else dp[i][j] = std::min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;
        }
    }
    return dp[m][n];
}
int main() {
    std::string word1 = "horse", word2 = "ros";
    std::cout << minDistance(word1, word2) << std::endl; // Output: 3
    return 0;
}
```

### 3. Combining Array and String Techniques
Use frequency arrays (Week 2, Hour 3) or sliding window (Week 3, Hour 2) with string algorithms.

Example (Group Anagrams with Frequency Array):
```cpp
#include <iostream>
#include <vector>
#include <string>
#include <unordered_map>
std::vector<std::vector<std::string>> groupAnagrams(std::vector<std::string>& strs) {
    std::unordered_map<std::string, std::vector<std::string>> map;
    for (std::string s : strs) {
        std::vector<int> count(26, 0);
        for (char c : s) count[c - 'a']++;
        std::string key;
        for (int x : count) key += std::to_string(x) + "#";
        map[key].push_back(s);
    }
    std::vector<std::vector<std::string>> result;
    for (auto& pair : map) result.push_back(pair.second);
    return result;
}
int main() {
    std::vector<std::string> strs = {"eat", "tea", "tan", "ate", "nat", "bat"};
    auto res = groupAnagrams(strs);
    for (auto& group : res) {
        for (std::string s : group) std::cout << s << " ";
        std::cout << std::endl;
    }
    // Output: eat tea ate
    //         tan nat
    //         bat
    return 0;
}
```

### 4. Handling Edge Cases
- **Empty Strings**: Check for empty inputs or patterns.
- **Single Characters**: Handle single-character strings or patterns.
- **Non-Alphanumeric**: Preprocess or ignore special characters.

### 5. Practical Interview Strategies
- Clarify constraints (e.g., case sensitivity, character set).
- Start with brute-force, then optimize using KMP or sliding window.
- Use diagrams to explain sliding window or DP tables.

**Cheatsheet:**
| Problem | Technique | Time Complexity | Space Complexity |
|---------|-----------|-----------------|------------------|
| String Compression | In-Place | O(n) | O(1) |
| Edit Distance | Dynamic Programming | O(m*n) | O(m*n) |
| Regular Expression | Dynamic Programming | O(m*n) | O(m*n) |

## Points to Remember
- Optimize space with in-place operations or fixed-size arrays.
- Use dynamic programming for complex string matching (e.g., edit distance).
- Combine sliding window (Week 3, Hour 2) with DP for hybrid problems.
- Time complexity: O(n) for in-place, O(m*n) for DP-based problems.
- Space complexity: Aim for O(1) with in-place or O(m*n) for DP.
- Common errors: Mishandling empty strings, incorrect DP initialization.
- Interview tip: Break down string problems into smaller subproblems.
- Use `std::string` for dynamic operations (Week 3, Hour 1).