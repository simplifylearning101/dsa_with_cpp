# Hour 6 LeetCode Problem: Merge k Sorted Lists

This document illustrates **LeetCode 23: Merge k Sorted Lists**, a hard problem that leverages STL `priority_queue` for efficient merging of sorted data. It includes the problem description, coding pattern, solution, complexity analysis, and test cases.

## Problem Statement: LeetCode 23 - Merge k Sorted Lists
**Link**: [LeetCode 23](https://leetcode.com/problems/merge-k-sorted-lists/)

**Description**:  
Given an array of `k` sorted linked lists, merge them into one sorted linked list and return it.

**Constraints**:
- `k == lists.length`
- `0 <= k <= 10^4`
- `0 <= lists[i].length <= 500`
- `-10^4 <= lists[i].val <= 10^4`
- Each `lists[i]` is sorted in ascending order.

**Example**:
- Input: `lists = [[1,4,5],[1,3,4],[2,6]]`  
  Output: `[1,1,2,3,4,4,5,6]`  
  Explanation: Merge lists into a single sorted list.

**Real-World Analogy**: Imagine merging multiple sorted queues of passengers into one line, where the person with the earliest boarding time goes first.

## Coding Pattern: Priority Queue for Merging
- Use a min-heap priority queue to store the current node of each list.  
- Pop the smallest node, add it to the result, and push the next node from the same list.  
- Continue until all nodes are processed.

## Solution
**Algorithm**:
1. Define a comparator for the priority queue to compare list nodes by value.
2. Initialize a min-heap with the first node of each non-empty list.
3. While the heap is not empty:
   - Pop the smallest node, add it to the result list.
   - Push the next node from the same list (if it exists).
4. Return the merged list.

**Code**:
```cpp
#include <queue>
#include <vector>
using namespace std;

// Definition for singly-linked list
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        // Min-heap for nodes
        struct Compare {
            bool operator()(ListNode* a, ListNode* b) {
                return a->val > b->val; // Min-heap on node value
            }
        };
        priority_queue<ListNode*, vector<ListNode*>, Compare> pq;
        
        // Push first node of each list
        for (ListNode* list : lists) {
            if (list) {
                pq.push(list);
            }
        }
        
        // Dummy node for result
        ListNode dummy(0);
        ListNode* tail = &dummy;
        
        // Merge lists
        while (!pq.empty()) {
            ListNode* curr = pq.top();
            pq.pop();
            tail->next = curr;
            tail = curr;
            if (curr->next) {
                pq.push(curr->next);
            }
        }
        
        return dummy.next;
    }
};
```

**Time Complexity**: O(n log k)  
- `n` is total number of nodes across all lists; `k` is number of lists.  
- Each push/pop is O(log k); total n nodes processed.

**Space Complexity**: O(k)  
- Priority queue stores at most k nodes.

**Explanation**:
- Min-heap ensures smallest node is always at the top.  
- Dummy node simplifies list construction.  
- Process each node exactly once, pushing next node if available.

## Test Cases
1. **Typical Case**: `lists = [[1,4,5],[1,3,4],[2,6]]` → Output: `[1,1,2,3,4,4,5,6]`  
2. **Empty Lists**: `lists = []` → Output: `[]`  
3. **Single List**: `lists = [[1,2,3]]` → Output: `[1,2,3]`  
4. **Empty List in Array**: `lists = [[],[1,2],[3,4]]` → Output: `[1,2,3,4]`  
5. **All Empty**: `lists = [[],[]]` → Output: `[]`

**Test Case Implementation**:
```cpp
#include <iostream>
#include <queue>
#include <vector>
using namespace std;

struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

ListNode* mergeKLists(vector<ListNode*>& lists) {
    struct Compare {
        bool operator()(ListNode* a, ListNode* b) {
            return a->val > b->val;
        }
    };
    priority_queue<ListNode*, vector<ListNode*>, Compare> pq;
    for (ListNode* list : lists) {
        if (list) {
            pq.push(list);
        }
    }
    ListNode dummy(0);
    ListNode* tail = &dummy;
    while (!pq.empty()) {
        ListNode* curr = pq.top();
        pq.pop();
        tail->next = curr;
        tail = curr;
        if (curr->next) {
            pq.push(curr->next);
        }
    }
    return dummy.next;
}

// Helper to create list
ListNode* createList(const vector<int>& vals) {
    ListNode dummy(0);
    ListNode* tail = &dummy;
    for (int val : vals) {
        tail->next = new ListNode(val);
        tail = tail->next;
    }
    return dummy.next;
}

// Helper to print list
void printList(ListNode* head) {
    cout << "[";
    while (head) {
        cout << head->val;
        head = head->next;
        if (head) cout << ",";
    }
    cout << "]" << endl;
}

int main() {
    // Test cases
    vector<ListNode*> lists1 = {createList({1, 4, 5}), createList({1, 3, 4}), createList({2, 6})};
    cout << "Test 1: "; printList(mergeKLists(lists1)); // [1,1,2,3,4,4,5,6]
    
    vector<ListNode*> lists2 = {};
    cout << "Test 2: "; printList(mergeKLists(lists2)); // []
    
    vector<ListNode*> lists3 = {createList({1, 2, 3})};
    cout << "Test 3: "; printList(mergeKLists(lists3)); // [1,2,3]
    
    vector<ListNode*> lists4 = {createList({}), createList({1, 2}), createList({3, 4})};
    cout << "Test 4: "; printList(mergeKLists(lists4)); // [1,2,3,4]
    
    vector<ListNode*> lists5 = {createList({}), createList({})};
    cout << "Test 5: "; printList(mergeKLists(lists5)); // []
    
    return 0;
}
```

**Output**:
```
Test 1: [1,1,2,3,4,4,5,6]
Test 2: []
Test 3: [1,2,3]
Test 4: [1,2,3,4]
Test 5: []
```

## Optimization Mindset
- **Efficiency**: Min-heap reduces merging to O(n log k).  
- **Key Insight**: Only store one node per list in the heap to minimize space.  
- **Edge Cases**: Handle empty lists, single list, and empty array of lists.